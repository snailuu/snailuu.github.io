[{"id":"3c194b2f2319e046c85e1bc082983d3c","title":"模板","content":"本篇文章作为跳转文章，如需阅读模板请点击下方各类按钮基础算法数据结构搜索与图论数学","slug":"模板","date":"2022-02-16T08:35:59.408Z","categories_index":"模板","tags_index":"","author_index":"Snailuu"},{"id":"40516069856649c61c80ebcc0b14851f","title":"杂乱笔记","content":"字符串\nstring类的插入insert(pos,string) 在下标pos和pos+1之间插入字符串string。\nstring类的删除earse(pos,num)从下标pos开始删除num个字符，如果num为空则删除pos后面的所有字符。\n\n数学\n\n\n取模的顺序：一定要优先对可能结果偏大的部分先取模，如果对小的数先取模，小的再去乘以一共大的可能就会溢出，再取模就是错的，所以要先对大的取模使其变小\n\n\n\n动态规划\n求每次只能选a或者选b ，问 n次操作后能不能到达 x点的直接用二进制（bitset） 存储每次操作的次数，最后询问  是否是 1即可\n\n\n2022.2.27 \n\n\n\n\n\n\n\n\n\n   迭代器指向前驱prev(it)，指向后继 next(it)\n\n\n\n\n\n\n\n\n\n\n   变量范围\n\n\n\n类型名\n位宽\n表示范围\n\n\n\nshort int\n16\n～\n\n\nunsigned short int\n16\n～\n\n\nint\n32\n～\n\n\nunsigned int\n32\n～\n\n\nlong int\n32\n～\n\n\nunsigned long int\n32\n～\n\n\nlong long int \n64\n～\n\n\nunsigned long long int\n64\n～\n\n\n\n\n\n\n\n\n\n\n\n\n   假设坐标上任意点（x，y）绕着点 （，） 旋转  度 ，设旋转后的坐标为（，），则\n   \n2022.2.27\n\n\n\n\n\n\n\n\n\n   全局变量声明迭代器，要在开头写上using list&lt;int&gt;::iterator\nusing iter=list&lt;int&gt;::iterator;\nconst int N=1e5+10;\niter pos[N];\n\n2022.2.28\n\n\n\n\n\n\n\n\n\n   斐波那契数列通项公式：\n","slug":"杂点笔记","date":"2022-02-16T04:06:58.194Z","categories_index":"笔记","tags_index":"数学,字符串,动态规划","author_index":"Snailuu"},{"id":"ef2958a60eebffed61302cfeed7e9fed","title":"错误之路","content":"本篇文章用于记录学习之路/比赛上看似不起眼的小错误却又不得不重视的，一直都在更新……\n2022.02.15 res=pow(a,b) 当res为int类型时，b应该为常量。当res为double类型时，b应该为常量、int、double。\n\n2022.02.19 \n\n\n\n\n\n\n\n\n\n   在遇到开根之类的，尽量弄成整数，比如 弄成5，等号另一边也开平方可减少精度误差。\n   遇到除法取模的要用到逆元，别直接除后取模。\n   由费马小定理可得：\n   可由快速幂求解\n\n2022.2.26 不要对临时变量加引用\n\n2022.2.28 在数据范围超1e9 时， 记得加上long long \n\n\n","slug":"错误之路","date":"2022-02-16T02:58:30.254Z","categories_index":"","tags_index":"","author_index":"Snailuu"},{"id":"92e9e21f40cabb2aa99ef90279e6b57e","title":"某些可能有用的链接","content":"2022/2/21 upd:\n不知道链接能活多久\n本文不定期更新\n支持推荐，如果有什么你觉得很有意义的文章/工具，欢迎把链接发送给我。\nTools (about Competitive Programming) :Csacademy Graph Editor（画“图”） Data Structure Visualization（算法/数据结构可视化） BZOJ 离线题库 模板题 OJ OIerDB（OIer数据库） 各大 OJ 做题量统计 OI Archive  \nAtcoder: AtCoder Rating Perdictor AtCoder Problems（题目列表、显示题目难度、显示做题情况）  \nTools (not about Competitive Programming) :Geogebra 图形计算器 Desmos 图形计算器 图床 sm.ms 图床 imgtu.com 图片压缩 GIF maker Ubuntu Pastebin 剪贴板 乱码修复 Stackedit（在线 Markdown 编辑器） Compiler Explorer（查看汇编码） OEIS（数列查询）  \nBlogs/Articles (about Competitive Programming) :OI Wiki 洛谷日报 OI-Public-Library（包含 IOI 中国国家候选队论文） list of useful blogs on codeforces The Ultimate Topic List (with Resources, Problems and Templates) 综合题单  \nUOJ 精神之源流（这个不算是实用性的，偏题了，只是我觉得大家都应该看一看）  \nBlogs/Articles (not about Competitive Programming) :C++ Reference Another C++ Reference LaTeX 数学公式大全 TheFreeDictionary（内含 wikipedia 镜像）\nGames我不确定要不要加这一栏？\n","slug":"不知名文章","date":"2022-02-21T13:33:14.265Z","categories_index":"","tags_index":"","author_index":"Snailuu"},{"id":"aa03b2f0abb625816c3d81ed8f81147b","title":"图论最短路问题","content":"朴素版Dijkstra算法(适用于稠密图)思路\n初始化距离数组和邻接矩阵（无穷大）\n处理重边问题在输入取最小值\n每次找到一个最小的未更新的答案点\n将其连边答案全部更新\n\n例题：Dijkstra算法朴素版\n代码实现如下：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 520, INF = 0x3f3f3f3f;\nint n, m;\nint g[N][N], dis[N];\nbool st[N];\n\nint dijkstra()\n{\n    dis[1] = 0; //每个点到一号点的最短距离\n    //如需求到s点的一开始将dis[s]定义为0即可\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (!st[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))\n                t = j; //找到当前未更新的最小点\n        }\n        for (int j = 1; j &lt;= n; j++)\n            dis[j] = min(dis[j], dis[t] + g[t][j]); //将t连接的点都更新最短距离\n        st[t] = true;\n    }\n    if (dis[n] == 0x3f3f3f3f)\n        return -1; // 1~n之间不连通，无法构成路径，也就没有最短距离\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(g[0], g[0] + N * N, INF);\n    fill(dis, dis + N, INF);\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        g[x][y] = min(g[x][y], c); //处理重边\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n\n堆优化版Dijkstra算法(适用于稀疏图)优点： \n\n堆可以动态维护一个集合中的最小值\n堆动态支持插入，删除，修改一个数\n\n优化部分：\nfor(int j=1;j&lt;=n;j++)\n{\n    if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n}\n//每次寻找一个最小值可以用堆来维护一个最小值\n//复杂度从O(n)-&gt;O(1)\n////////////////////////////////////////////\nfor(int j=1;j&lt;=n;j++)\n    dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n//每次将点更新在堆中修改复杂度为mlogm\n//复杂度从O(n)-&gt;O(mlogm)\n//////////////////////////////////////////////\n//总体复杂度从O(n^2)-&gt;O(mlogm)\n\n例题：Dijkstra算法堆优化版\n代码实现：\n#include &lt;bits/stdc++.h&gt;\n#define PII pair&lt;int, int&gt;\nusing namespace std;\n\nconst int N = 1e6 + 10, INF = 0x3f3f3f3f;\nint n, m;\nint h[N], e[N], ne[N], idx;\nint dis[N], w[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint dijkstra()\n{\n    fill(dis, dis + N, INF);\n    dis[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; //优先队列默认大根堆，这样子写可以维护小根堆,pair&lt;int,int&gt;第一个值存数值，第二个值存下标\n    heap.push({0, 1});\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver]) continue; //每次处理均为最小值且未处理过的\n        st[ver] = true;\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dis[j] &gt; dis[ver] + w[i]) //有更短路就替换\n            {\n                dis[j] = dis[ver] + w[i];\n                heap.push({dis[j], j}); //将新的方案加入到队列中\n            }\n        }\n    }\n    //队列为空即走完整个图\n    if (dis[n] == INF)\n        return -1;\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(h, h + N, -1); //将头结点数组全部初始化成-1\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        add(x, y, c);\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n\n\nSPFA算法（适用于稀疏图）Bellman-Ford太呆\n优点：\n\n每次只更新与结点有关点的最小距离\n\n例题：SPFA求最短路\n代码实现：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[N], ne[N], w[N], idx; //稀疏图用邻接表来存图\nint n, m;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint spfa()\n{\n    fill(dist, dist + N, INF); //先将每个到源点的距离初始化成正无穷\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        int t = q.front();\n        q.pop();\n        st[t] = false; //出队了\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) //更新t结点的所有距离\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])\n                {\n                    q.push(j); //更新的点第一次访问就进度，后面可能还能再利用其更新其他点\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    while (m--)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if (t == INF) //如果到n点还无法更新距离说明无法连通\n        puts(\"impossible\");\n    else\n        cout &lt;&lt; t &lt;&lt; endl;\n    return 0;\n}\n\n\n","slug":"图论最短路","date":"2022-02-20T13:19:08.472Z","categories_index":"图论","tags_index":"最短路,稠密图,稀疏图","author_index":"Snailuu"},{"id":"3066e00b6cf820c21780a6c4e3135165","title":"矩阵的数量V3","content":"题目链接：矩形的数量 V3\n\n 矩形的数量 V3\n\n\nTime limit : 1000ms        Memory limit: 131072 kb\n    \n\n\n一个m乘n的方格图，有多少个大小不同的正方形。\n例如：4*3的方格中共有20个，其中：\n 12个  6个  2个\nInput\n\n\n\n\n\n\n\n\n\n共一行：2个数m,n，对应方格图的长宽（1 &lt;= m, n &lt;= 1e9） \nOutput\n\n\n\n\n\n\n\n\n\n   输出对应的矩形种类 。\nSample\nInput\n\n\n\n\n\n\n\n\n\n   4        3\nOutput\n\n\n\n\n\n\n\n\n\n   20\n\n题意\n一个  的矩形，问里面有多少个大小不同的正方形\n\n思路暴力解法可以看出，设  \n边长为  的正方形个数：\n边长为  的正方形个数：\n边长为  的正方形个数：\n\n边长为  的正方形个数：\n所以最终答案为：\n但是用循环累加就会超时，就需要对上面的式子进行等价变换：\n\n\n\n\n其中   为定值\n可以分为以下两部分进行分解：\n\n\n故最终答案为：\n代码：\n#include &lt;iostream&gt;\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nint main()\n{\n    ll m, n;\n    cin &gt;&gt; m &gt;&gt; n;\n    if (m &lt; n)\n        swap(m, n);\n    ll ans = n * (n + 1) / 2;\n    if (ans % 3 == 0)\n        ans = ans / 3 % mod * (3 * m - n + 1) % mod;\n    else\n        ans = ans % mod * (3 * m - n + 1) / 3 % mod;\n    cout &lt;&lt; ans % mod &lt;&lt; endl;\n    return 0;\n}\n\n","slug":"矩阵的数量V3","date":"2022-02-19T09:53:53.021Z","categories_index":"杂题","tags_index":"数学知识","author_index":"Snailuu"},{"id":"65b0dc824c3fb7ee6bc785abb93cc693","title":"数学模板","content":"质数试除法判定质数\n时间复杂度：\n\nbool is_prime(int x)\n{\n    if (x &lt; 2) return false;\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\n试除法分解质因数\n时间复杂度： ~ \n\nvoid divide(int x)\n{\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        {\n            int s = 0;\n            while (x % i == 0) x /= i, s ++ ;\n            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;\n        }\n    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;\n    cout &lt;&lt; endl;\n}\n\n线性筛法求素数\nprimes[]存储所有素数，cnt记录素数个数，st[]存储x是否被筛掉\n\nint primes[N], cnt;\nbool st[N];\nvoid get_primes(int n)\n{\n    for (int i = 2; i &lt;= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n\n\n试除法求所有约数vector&lt;int&gt; get_divisors(int x)\n{\n    vector&lt;int&gt; res;\n    for (int i = 1; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        {\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);\n        }\n    sort(res.begin(), res.end());\n    return res;\n}\n\n约数个数和约数之和\n\n\n\n\n\n\n\n\n   假设一个数  可以表示为\n   \n    为素数\n   则  的约数个数为：\n   约数之和为：\nconst int mod = 1e9 + 7;\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    unordered_map&lt;int, int&gt; primes;\n    while (n--)\n    {\n        int x;\n        cin &gt;&gt; x;\n        for (int i = 2; i &lt;= x / i; i++)\n        {\n            while (x % i == 0)\n            {\n                x /= i;\n                primes[i]++;\n            }\n        }\n        if (x &gt; 1)\n            primes[x]++;\n    }\n    ll res = 1;\n    ////////////////求约数个数////////////////\n    for (auto p : primes)\n        res = res * (p.second + 1) % mod;\n    ////////////////求约数个数////////////////\n    ////////////////求约数之和////////////////\n    for (auto p : primes)\n    {\n        ll a = p.first, b = p.second;\n        ll t = 1;\n        while (b--)\n            t = (t * a + 1) % mod;\n        res = res * t % mod;\n    }\n    ////////////////求约数之和////////////////\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n   如果使用递归二分求等比数列\n   简写为：\n   若  为奇数时，就会有偶数项，则：\n   \n   然后分别从两边提取一个数  ，  ，……. ，\n   然后提取公因式可以得到：\n   \n   如果  是偶数的话，同理可得：\n   \nll ksm(ll a, ll b, ll p)\n{\n    ll ans = 1;\n    while (b)\n    {\n        if (b &amp; 1)\n            ans = (ans * a) % p;\n        b &gt;&gt;= 1;\n        a = (a * a) % p;\n    }\n    return ans;\n}\nll sum(ll p, ll n, ll mod)\n{\n    if (!n) return 1;\n    if (n == 1) return (1 + p) % mod;\n    if (n &amp; 1)\n        return ((1 + ksm(p, (n + 1) / 2, mod) % mod) * sum(p, (n - 1) / 2, mod) % mod) % mod;\n    else\n        return ((1 + ksm(p, n / 2, mod) % mod) * sum(p, n / 2 - 1, mod) % mod + ksm(p, n, mod)) % mod;\n}\n\n最大公约数/最小公倍数int gcd(int a,int b)\n{\n    return b==0?a:gcd(b,a%b);\n}\nint lcm(int a,int b)\n{\n    return a/gcd(a,b)*b;\n}\n\n\n\n欧拉函数\n欧拉函数，即  ，表示的是小于等于  和  互质的数的个数。\n比如  ,\n当  是质数的时候，显然有 \n\n求n的欧拉值\n\n\n\n\n\n\n\n\n   欧拉函数是一个积性函数，当  互质时，，特别地，当  是奇数时 \n   由唯一分解定理知： \n   因此 \n   由容斥定理可得：\n   、、、 只与质因子有关，跟质因子的次数无关。\n朴素版求欧拉函数int phi(int x)\n{\n    int res = x;\n    for (int i = 2; i &lt;= x / i; i++)\n    {\n        if (x % i == 0)\n        {\n            res = res / i * (i - 1);\n            while (x % i == 0)\n                x /= i;\n        }\n    }\n    if (x &gt; 1)\n        res = res / x * (x - 1);\n    return res;\n}\n\n筛法求欧拉函数\n\n\n\n\n\n\n\n\n\n质数  的欧拉函数即为eular[i-1]：～ 均与  互质，共有  个\n\neular[primes[j]*i] 分为两种情况：\ni%primes[j]==0：primes[j] 是id的最小质因子，也是primes[j]*i的最小质因子，因此i-1/primes[j]这一项在eular[i]中计算过了即\ni%primes[j]!=0：primes[j]不是i的质因子，只是primes[j]*i的最小质因子，所以只需要多加一项1-1/primes[j]，即\n进一步化简可得：\n\n\nint primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\nvoid get_eulers(int n)\n{\n    euler[1] = 1;\n    for (int i = 2; i &lt;= n; i ++ )\n    {\n        if (!st[i])\n        {\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        }\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        {\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            {\n                euler[t] = euler[i] * primes[j];\n                break;\n            }\n            euler[t] = euler[i] * (primes[j] - 1);\n        }\n    }\n}\n\n欧拉定理\n\n\n\n\n\n\n\n\n   若 ，则\n拓展欧拉定理\n\n\n\n\n\n\n\n\n   \n快速幂\n\n\n\n\n\n\n\n\n   设  为一个数的幂，将  用二进制表示，以此来分割成更小的任务\n   比如：\n   于是我们只需要知道  的  次幂的序列就可以求出  的  次幂，举个例子：\n   \n   \n   \n   \n   因此计算  就只需要将其二进制位为  的整系数幂乘起来即可：\n   \n快速幂\n时间复杂度：\n\nint qmi(int m, int k, int p)\n{\n    int res = 1 % p, t = m;\n    while (k)\n    {\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p;\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n\n\n\n快速幂求逆元\n\n\n\n\n\n\n\n\n   当  为质数时，可以用快速幂求逆元\n   \n   \n   \n   同： \n   由费马小定理可知，当  为质数时\n   所以当  为质数时，  的逆元 \n\n   如果  不是质数时可以用拓展欧几里得算法求逆元：\n    有逆元的充要条件是  与  互质，所以 \n   假设  的逆元为  ，那么 \n   等价于 \n乘法逆元定义：\n\n\n\n\n\n\n\n\n\n   若整数 b，m 互质，并且对于任意的整数 a，如果满足 ，则存在一个整数 x，使得 ，则称 x 为 b 的模 m 乘法逆元，记为 。   b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，即为 b 的乘法逆元。\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\ntypedef long long LL;\nLL ksm(int a, int b, int p)\n{\n    LL res = 1;\n    while (b)\n    {\n        if (b &amp; 1)\n            res = res * a % p;\n        a = a * (LL)a % p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &amp;n);\n    while (n--)\n    {\n        int a, p;\n        scanf(\"%d%d\", &amp;a, &amp;p);\n        if (a % p == 0) puts(\"impossible\");\n        else printf(\"%lld\\n\", ksm(a, p - 2, p));\n    }\n\n    return 0;\n}\n\n矩阵快速幂\n利用结构体构造矩阵，并将其初始化成单位矩阵\nstruct mat{\n    int m[N][N];\n    mat() { // 用构造函数初始化成 单位矩阵E\n        memset(m, 0, sizeof m);\n        for (int i = 0; i &lt; N; i ++) m[i][i] = 1;\n    }\n}\n\n\n\n矩阵乘法： 比如两个矩阵  和  ，每一次相乘总是   的行与  的列，所以可以用两层循环表示  的行的数量的变化和  的列的数量进行变化，因为  的列和  的行数量是相同的，可以用第三层循环解决。\nmat multi(mat a, mat b) { \n    mat c;\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            c.m[i][j] = 0;\n            for (int k = 0; k &lt; n; k++) {\n                c.m[i][j] += a.m[i][k] * b.m[k][j]; // 累加\n            }\n            c.m[i][j] %= mod;\n        }\n    }\n    return c;\n}\n\n矩阵快速幂（核心）：将数变成结构体矩阵即可\n// 矩阵快速幂（核心）\nmat fastpow(mat a, int k) { \n    mat res;\n    while (k) {\n        if (k &amp; 1) res = multi(res, a);\n        a = multi(a, a);\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n\n拓展欧几里得算法\n\n\n\n\n\n\n\n\n   由裴蜀定理可知：设 、 是不全为零的整数，则存在整数 、 使得 \n   下面用  表示 、 的最大公约数\n拓展欧几里得算法\n\n\n\n\n\n\n\n\n   \n   如果  ，则有 ，即存在一组解为： 使得 \n   如果  ，则有 \n   用  来表示  , \n   代入可得：\n   即：\n   \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n{\n    if (!b)//b==0\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= a / b * x;//b!=0\n    return d;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &amp;n);\n    while (n -- )\n    {\n        int a, b;\n        scanf(\"%d%d\", &amp;a, &amp;b);\n        int x, y;\n        exgcd(a, b, x, y);\n        printf(\"%d %d\\n\", x, y);\n    }\n    return 0;\n}\n\n\n\n线性同余方程\n\n\n\n\n\n\n\n\n   给定一个、、 ，是否存在一个数 使得  \n   即是否存在一个整数  使得：\n   进一步化简并令  ， 可得：\n   此时如果  即存在，如果要求最小正整数解就将   两边再乘以  即可\n   反之不存在\n   最小正整数可以：  \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\ntypedef long long LL;\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n{\n    if (!b)\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &amp;n);\n    while (n -- )\n    {\n        int a, b, m;\n        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;m);\n        int x, y;\n        int d = exgcd(a, m, x, y);\n        if (b % d) puts(\"impossible\");\n        else printf(\"%d\\n\", (LL)b / d * x % m);\n    }\n    return 0;\n}\n\n\n\n中国剩余定理高斯消元解线性方程组解异或线性方程组求组合数\n时间复杂度询问次数10w，数据范围：1&lt;=b&lt;=a&lt;=2000\n\n\n\n\n\n\n\n\n\n    表示从  个苹果中选出  个的方案数，第  个苹果可以分为选和不选，选：  ，不选： 总的根据加法计数原理可得：\nvoid init()\n{\n    for (int i = 0; i &lt; N; i++)\n        for (int j = 0; j &lt;= i; j++)\n            if (!j) f[i][j] = 1;\n            else f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mod;\n}\n\n时间复杂度：询问次数10w，数据范围：1&lt;=b&lt;=a&lt;=100000\n\n如果模数是质数用费马小定理求解逆元，逆元通过快速幂求解，反之用拓展欧几里得求解。\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define ll long long \n\nusing namespace std;\n\nconst int N = 1e5+10,mod=1e9+7;\nint infact[N],fact[N];\n\nint ksm(int a,int b,int p)\n{\n    int res=1;\n    while(b)\n    {\n        if(b&amp;1)res=(ll)res*a%p;\n        a=(ll)a*a%p;\n        b&gt;&gt;=1;\n    }\n    return res;\n}\nint main()\n{\n    fact[0]=infact[0]=1;\n    for(int i=1;i&lt;=N;i++)\n    {\n        fact[i]=(ll)fact[i-1]*i%mod;\n        infact[i]=(ll)infact[i-1]*ksm(i,mod-2,mod)%mod;\n    }\n    int n;\n    cin&gt;&gt;n;\n    while (n -- )\n    {\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;(ll)fact[a]*infact[b]%mod*infact[a-b]%mod&lt;&lt;endl;\n    }\n    return 0;\n}\n\nLucas定理，时间复杂度询问次数20，数据范围：1&lt;=b&lt;=a&lt;=1e18\n\n#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\nint ksm(int a, int b, int p)\n{\n    int res = 1;\n    while (b)\n    {\n        if (b &amp; 1)\n            res = (ll)res * a % p;\n        a = (ll)a * a % p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint C(int a, int b, int p)\n{\n    if (b &gt; a)\n        return 0;\n    int res = 1;\n    for (int i = 1, j = a; i &lt;= b; i++, j--)\n    {\n        res = (ll)res * j % p;\n        res = (ll)res * ksm(i, p - 2, p) % p;\n    }\n    return res;\n}\nint lucas(ll a, ll b, int p)\n{\n    if (a &lt; p &amp;&amp; b &lt; p)\n        return C(a, b, p);\n    return (ll)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;\n}\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    while (n--)\n    {\n        ll a, b;\n        int p;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n        cout &lt;&lt; lucas(a, b, p) &lt;&lt; endl;\n    }\n    return 0;\n}\n\n高精度由唯一分解定理可知：一个数可以分解成：\n 中的质因子  的个数等于 ～ 每个数包含质因子  的个数之和\n阶乘分解质因子\n求解 n 中 p 因子的个数\nint get(int n,int p)\n{\n    int res=0;\n    while(n)\n    {\n        res+=n/p;\n        n/=p;\n    }\n    return res;\n}\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N=5010;\nint primes[N],cnt;\nbool st[N];\nint sum[N];\n\nvoid get_primes(int n)\n{\n    for(int i=2;i&lt;=n;i++)\n    {\n        if(!st[i])primes[cnt++]=i;\n        for(int j=0;primes[j]&lt;=n/i;j++)\n        {\n            st[primes[j]*i]=true;\n            if(primes[j]%i==0)break;\n        }\n    }\n}\nint get(int n,int p)\n{\n    int res=0;\n    while(n)\n    {\n        res+=n/p;\n        n/=p;\n    }\n    return res;\n}\nvector&lt;int&gt; mul(vector&lt;int&gt;a,int b)\n{\n    vector&lt;int&gt;c;\n    int t=0;\n    for(int i=0;i&lt;a.size();i++)\n    {\n        t+=a[i]*b;\n        c.push_back(t%10);\n        t/=10;\n    }\n    while(t)\n    {\n        c.push_back(t%10);\n        t/=10;\n    }\n    return c;\n}\nint main()\n{\n    int a,b;\n    cin&gt;&gt;a&gt;&gt;b;\n    get_primes(a);\n    for(int i=0;i&lt;cnt;i++)\n    {\n        int p=primes[i];\n        sum[i]+=get(a,p)-get(b,p)-get(a-b,p);\n    }\n    vector&lt;int&gt;res;\n    res.push_back(1);\n    for(int i=0;i&lt;cnt;i++)\n    {\n        for(int j=0;j&lt;sum[i];j++)\n        {\n            res=mul(res,primes[i]);\n        }\n    }\n    for(int i=res.size()-1;i&gt;=0;i--) cout&lt;&lt;res[i];\n    cout&lt;&lt;endl;\n    return 0;\n}\n\n卡特兰数容斥定理奇加偶减 ：多个集合的并集可以表示成：单独一个集合相加 - 两两成型的集合+三个一起的集合 - 四个团聚的集合+….-….直到所有集合合成一个。\n\n例题：能被整除的数\n\n\n\n\n\n\n\n\n\n   以这道题为例： ，故 \n   每个集合不需要知道具体元素，只需要数量，即 ，并集的话就只需要除以相乘的数，即\n   对于每个集合的状态，这里可以用二进制表示，比如  表示选中第一，二，四个集合，根据公式，前面的系数为 \n代码\n#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\n\nconst int N = 20;\nint p[N], n, m;\n\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i];\n    int res = 0;\n    for (int i = 1; i &lt; 1 &lt;&lt; m; i++)//用二进制表示每个种集合选中方式\n    {\n        int t = 1, s = 0;//t表示对应质数的乘积,s表示选中集合数量\n        for (int j = 0; j &lt; m; j++)//枚举当前状态的每一位\n        {\n            if (i &gt;&gt; j &amp; 1)//如果为1则表示选中\n            {\n                if ((ll)t * p[j] &gt; n)//如果当前乘积大于n则n/t=0,跳出循环\n                {\n                    t = -1;\n                    break;\n                }\n                s++;//集合数量+1\n                t *= p[j];//当前集合质数乘积\n            }\n        }\n        if (t == -1)continue;\n        if (s &amp; 1) res += n / t;//如果有奇数个集合，系数是1\n        else res -= n / t;//反之是-1\n    }\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n\n\n\n博弈论Nim游戏","slug":"数学模板","date":"2022-02-17T13:59:00.749Z","categories_index":"模板","tags_index":"模板,数学","author_index":"Snailuu"},{"id":"d11324b19b05ce1c671aea0ac57ea0cf","title":"搜索与图论模板","content":"树与图的存储\n树是一种特殊的图（无向无环图），与图的存储方式相同\n\n无向图就是特殊的有向图，存储两条边  和 \n\n邻接矩阵：g[a][b]存储边 \n\n邻接表：\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n// 添加一条边a-&gt;b\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);\n\n树与图的遍历\n时间复杂度：， 表示点数， 表示边数\n\n深度优先遍历int dfs(int u)\n{\n    st[u] = true; // st[u] 表示点u已经被遍历过\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    }\n}\n\n宽度优先遍历queue&lt;int&gt; q;\nst[1] = true; // 表示1号点已经被遍历过\nq.push(1);\nwhile (q.size())\n{\n    int t = q.front();\n    q.pop();\n\n    for (int i = h[t]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j])\n        {\n            st[j] = true; // 表示点j已经被遍历过\n            q.push(j);\n        }\n    }\n}\n\n例：\n拓扑排序\n时间复杂度：， 表示点数， 表示边数\n\nbool topsort()\n{\n    int hh = 0, tt = -1;\n    // d[i] 存储点i的入度\n    for (int i = 1; i &lt;= n; i ++ )\n        if (!d[i])\n            q[ ++ tt] = i;\n    while (hh &lt;= tt)\n    {\n        int t = q[hh ++ ];\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (-- d[j] == 0)\n                q[ ++ tt] = j;\n        }\n    }\n    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt == n - 1;\n}\n\n朴素版Dijkstra算法\n时间复杂度：， 表示点数， 表示边数\ng[][]存储每条边，dist[] 存储1号点到每个点的最短距离，st[] 存储每个点的最短路是否已经确定\n如果要求某个点到其他点的最短路，在一开始只需要将dist[a]初始化成0即可\n\n\n\n\n\n\n\n\n\n\n\n初始化距离数组，dist[1] = 0， dist[i] = inf;\nfor n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离\n将不在 S 中dist_min的点t\nt  S加入最短路集合\n用 t 更新到其他点的距离\n\nint g[N][N],dist[N];\nbool st[N];\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    for (int i = 0; i &lt; n - 1; i ++ )\n    {\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j &lt;= n; j ++ )\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))\n                t = j;\n        // 用t更新其他点的距离\n        for (int j = 1; j &lt;= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        st[t] = true;\n    }\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\n堆优化版Dijkstra算法\n时间复杂度： ， 表示点数， 表示边数\nn表示点的数量，dist[] 存储1号点到其他点的距离，st[]存储每个点的最短距离是否已确定\n\n\n\n\n\n\n\n\n\n\n\n利用邻接表，优先队列\n在priority_queue[HTML_REMOVED],greater[HTML_REMOVED] &gt; heap；中将返回堆顶\n利用堆顶来更新其他点，并加入堆中类似宽搜\n\ntypedef pair&lt;int, int&gt; PII;\nint n;\nint h[N], w[N], e[N], ne[N], idx;// 邻接表存储所有边\nint dist[N];\nbool st[N];\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push({0, 1});// first存储距离，second存储节点编号\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver]) continue;//已经确定最短距离的就不用处理\n        st[ver] = true;\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; distance + w[i])\n            {\n                dist[j] = distance + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n    if (dist[n] == 0x3f3f3f3f) return -1;//找不到\n    return dist[n];\n}\n\n\n\nBellman-Ford算法\n时间复杂度：， 表示点数， 表示边数\nn表示点数，m表示边数，dist[]存储1到x的最短路距离\n\n\n\n\n\n\n\n\n\n\n\n注意连锁想象需要备份, struct Edge{int a,b,c} Edge[M];\n初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w);\n松弛k次，每次访问m条边\n\nint n, m;\nint dist[N];\nstruct Edge// 边，a表示出点，b表示入点，w表示边的权重\n{\n    int a, b, w;\n}edges[M];\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    //如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径\n    //由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i &lt; n; i ++ )\n    {\n        for (int j = 0; j &lt; m; j ++ )\n        {\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] = dist[a] + w;\n        }\n    }\n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n}\n\n\n\nSpfa 算法（队列优化的Bellman-Ford算法）\n时间复杂度：平均情况下 ，最坏情况下 ， 表示点数， 表示边数\nn总点数，dist[]存储每个点到1号点的最短距离，st[]存储每个点是否在队列中\n\n\n\n\n\n\n\n\n\n\n\n利用队列优化仅加入修改过的地方\nfor k次\nfor 所有边利用宽搜模型去优化bellman_ford算法\n更新队列中当前点的所有出边\n\nint n;\nint h[N], w[N], e[N], ne[N], idx;// 邻接表存储所有边\nint dist[N];\nbool st[N];\n// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\n判断图中是否存在负环\n方法：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环\ncnt[]存储1到x的最短路中经过的点数\n\nint n;\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N], cnt[N];\nbool st[N];\n// 如果存在负环，则返回true，否则返回false。\nbool spfa()\n{\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; i ++ )\n    {\n        q.push(i);\n        st[i] = true;\n    }\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\nFloyd算法\n时间复杂度： ， 表示点数\nd[a][b] 表示  到  的最短距离\n\n\n\n\n\n\n\n\n\n\n\n初始化d\nk, i, j 去更新d\n\n//初始化：\n    for (int i = 1; i &lt;= n; i ++ )\n        for (int j = 1; j &lt;= n; j ++ )\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\nvoid floyd()\n{\n    for (int k = 1; k &lt;= n; k ++ )\n        for (int i = 1; i &lt;= n; i ++ )\n            for (int j = 1; j &lt;= n; j ++ )\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\n最小生成树朴素版prim算法\n时间复杂度：， 表示点数， 表示边数\nn表示点数，g[][]邻接矩阵，存储所有边，dist[]存储其他点到当前最小生成树的距离st[]存储每个点是否已经在生成树中\n\nint n;\nint g[N][N];\nint dist[N];\nbool st[N];\n// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n{\n    memset(dist, 0x3f, sizeof dist);\n    int res = 0;\n    for (int i = 0; i &lt; n; i ++ )\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j ++ )\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))\n                t = j;\n        if (i &amp;&amp; dist[t] == INF) return INF;\n        if (i) res += dist[t];\n        st[t] = true;\n        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);\n    }\n    return res;\n}\n\n\n\nKruskal算法\n时间复杂度：， 表示点数， 表示边数\nn表示点数，m表示边数，p[]并查集的父节点数组\n\nint n, m;\nint p[N];\nstruct Edge     // 存储边\n{\n    int a, b, w;\n    bool operator&lt; (const Edge &amp;W)const\n    {\n        return w &lt; W.w;\n    }\n}edges[M];\nint find(int x)     // 并查集核心操作\n{\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\nint kruskal()\n{\n    sort(edges, edges + m);\n    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i ++ )\n    {\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n        a = find(a), b = find(b);\n        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并\n        {\n            p[a] = b;\n            res += w;\n            cnt ++ ;\n        }\n    }\n    if (cnt &lt; n - 1) return INF;\n    return res;\n}\n\n\n\n染色法判别二分图\n时间复杂度：， 表示点数， 表示边数\nn表示点数，color[]表示每个点的颜色\n\nint n;\nint h[N], e[M], ne[M], idx;// 邻接表存储图\nint color[N];// -1表示未染色，0表示白色，1表示黑色\n// 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n{\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (color[j] == -1)\n        {\n            if (!dfs(j, !c)) return false;\n        }\n        else if (color[j] == c) return false;\n    }\n    return true;\n}\nbool check()\n{\n    memset(color, -1, sizeof color);\n    bool flag = true;\n    for (int i = 1; i &lt;= n; i ++ )\n        if (color[i] == -1)\n            if (!dfs(i, 0))\n            {\n                flag = false;\n                break;\n            }\n    return flag;\n}\n\n\n\n匈牙利算法\n时间复杂度：， 表示点数， 表示边数\nn1表示第一个集合中的点数，n2表示第二个集合中的点数\nmatch[]存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个，st[]表示第二个集合中的每个点是否已经被遍历过\n\nint n1, n2;\nint h[N], e[M], ne[M], idx;\nint match[N];\nbool st[N];\nbool find(int x)\n{\n    for (int i = h[x]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j])\n        {\n            st[j] = true;\n            if (match[j] == 0 || find(match[j]))\n            {\n                match[j] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\n// 在加边的时候只需要加第一个集合到第二个集合的边\nint res = 0;\nfor (int i = 1; i &lt;= n1; i ++ )\n{\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"搜索与图论模板","date":"2022-02-17T03:41:35.497Z","categories_index":"模板","tags_index":"模板,图论,搜索","author_index":"Snailuu"},{"id":"c28259cd908768634e0a4505c18b8177","title":"Misha and Forest","content":"原题链接：Codeforces Round #285 (Div. 2)C. Misha and Forest\nC. Misha and Forest\n\n\n    Time limit:1000ms      Memory limit:262144kb\n\n\nLet’s define a forest as a non-directed acyclic graph (also without loops and parallel edges). One day Misha played with the forest consisting of  vertices. For each vertex  from  to he wrote down two integers,  and , were the first integer is the number of vertices adjacent to vertex , and the second integer is the XOR sum of the numbers of vertices adjacent to  (if there were no adjacent vertices, he wrote down ).\nNext day Misha couldn’t remember what graph he initially had. Misha has values  and  left, though. Help him find the number of edges and the edges of the initial graph. It is guaranteed that there exists a forest that corresponds to the numbers written by Misha.\nInput\n\n\n\n\n\n\n\n\n\n   The first line contains integer  (1 ≤  ≤ ), the number of vertices in the graph.\n   The -th of the next lines contains numbers degreei and si (0 ≤ ≤ , 0 ≤ &lt;), separated by a space.\nOutput\n\n\n\n\n\n\n\n\n\n   In the first line print number , the number of edges of the graph.\n   Next print lines, each containing two distinct numbers,  and  (0 ≤ ≤ , 0 ≤  ≤ ), corresponding to edge (,).\n   Edges can be printed in any order; vertices of the edge can also be printed in any order.\nExamples\n\ninput\n\n3\n2 3\n1 0\n1 0\n\n\noutput\n\n2\n1 0\n2 0\n\n\ninput\n\n2\n1 1\n1 0\n\n\noutput\n\n1\n0 1\n\nNote\nThe XOR sum of numbers is the result of bitwise adding numbers modulo . This operation exists in many modern programming languages. For  example, in languages C++, Java and Python it is represented as ^, and in Pascal — as “xor”.\n\n题目大意定义一个森林为无向无环图（没有重边和环），给出个点，编号为～，接下来有  行数据，每行数据表示第  个点的度数和与邻接点的异或和的值，要求输出原来图的每条边。\n思路\n由于是无向无环图，所以就是一棵树，那么一定有叶子节点（度数为1）。\n可以找出所有的叶子节点，利用异或和性质a^b^c^a=b^c求出另外一个点的异或和值。\n利用拓扑排序的方式求出边\n\n题解\n找所有度数为  的节点入队，遍历他的连接叶子节点。\n连接叶子节点度数  ，如果为  就入队，直至队列为空。\n\nCode#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\nconst ll N = (1 &lt;&lt; 16) + 10;\nll degree[N], s[N];\nqueue&lt;int&gt; q;\npair&lt;int, int&gt; res[N];\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; degree[i] &gt;&gt; s[i];//度数，异或和值\n        if (degree[i] == 1)\n            q.push(i); //相连点只有一个，叶子\n    }\n    int cnt = 0;//用来记录边数\n    while (q.size())\n    {\n        int now = q.front();//取出队头，将它和连接叶子节点进行操作\n        q.pop();\n        if (degree[now] == 1)//在后面可能有一个点连接两个不同点，这里要加个判断\n        {\n            int next = s[now];        //叶子节点的异或和是父节点\n            res[cnt].first = now;     //子节点\n            res[cnt++].second = next; //父节点\n            degree[next]--;           //父节点连接点--\n            s[next] ^= now;           //a^b^c^a==b^c\n            if (degree[next] == 1)    //如果度数为1就入队\n                q.push(next);\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; endl;\n    for (int i = 0; i &lt; cnt; i++)//题目不要求顺序\n        cout &lt;&lt; res[i].first &lt;&lt; \" \" &lt;&lt; res[i].second &lt;&lt; endl;\n    return 0;\n}\n\n\n\n","slug":"Misha and Forest","date":"2022-02-16T12:26:41.888Z","categories_index":"codeforecs","tags_index":"位运算,拓扑排序,树","author_index":"Snailuu"},{"id":"2c4ac29383b35bd575e7e033cc42c68d","title":"STL算法","content":"数组相关nth_element//重新排序[first,last)中的元素，使得新的nth元素前的所有元素小于或等于新的nth元素后的所有元素\nstd::nth_element(first, nth, last, cmp);\n//默认排序规则从小到大\n\n\n应用：求第  大/小的数\n\nmax_element和min_element\n时间复杂度均为\n\nmax_element(a,a+n)返回数组中最大值的迭代器\n\nmin_element(a,a+n)返回数组中最小值的迭代器\n\n\nnext_permutation和prev_permutation\nnext_permutation按照全排列输出下一次排列\n\nprev_permutation按照全排列输出上一次排列\nint a[5]={1,3,2,4,5};\nnext_permutation(a,a+5);// 1 3 2 5 4\nprev_permutation(a,a+5);// 1 2 5 4 3\n\n","slug":"STL算法","date":"2022-02-16T10:51:19.371Z","categories_index":"STL","tags_index":"STL算法","author_index":"Snailuu"},{"id":"dd310f63c22e1adb321e0e6222b0b1f9","title":"STL容器","content":"vector\n可变数组，倍增的思想\n设vector&lt;int&gt;a,b\n\na.size()返回a元素个数\n\na.empty()返回a是否为空\n\na.clear()清空数组a\n\na.resize()调整a空间大小\n\na.swap(b) 将a中的元素和b中的元素整体交换\n\na.front()/back() 返回a的第一个元素/最后一个元素\n\na.push_back()/pop_back() 从尾部插入一个数/删除a的第一个元素\n\na.begin()/end() 返回容器中起始元素的迭代器/末尾的迭代器\n\na[i]访问第 i个元素\n\n注：如果还没开辟空间，不能直接用a[i]下标访问方法存储，要用push_back()存储\n\n\n\n\n\n\n\n\n\n\n   几个常用算法：\n   sort(a.begin(),a.end());对a中的从a.begin( )（包括它）到a.end( )（不包括它）的元素进行从小到大排列\n   reverse(a.begin(),a.end());对a中的从a.begin()（包括它）到a.end( )（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1\n   copy(a.begin(),a.end(),b.begin()+1);把a中的从a.begin( )（包括它）到a.end( )（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素\n    find(a.begin(),a.end(),10);在a中的从a.begin( )（包括它）到a.end( )（不包括它）的元素中查找10，若存在返回其在向量中的位置\n\n\n\">pari&lt;int,int&gt;\nfirst第一个元素\n\nsecond第二个元素\n\n\n\n\n\n\n\n\n\n   支持比较运算，运算规则以first为第一关键字，以second为第二关键字（字典序）\n\n\nstring\nsize()/length() 返回字符串长度\nempty() 返回是否为空\nclear()清空\nsubstr(pos,num)返回从pos开始num个长度的子串\nc_str() 返回字符串所在字符数组的起始地址\nstring.insert(pos,string)从下标pos和pos+1之间插入字符串\nstring.earse(pos,num)从下标pos开始删除num个字符，如果num为空则删除pos后面的所有字符。\n\nqueue\nsize()返回长度\nempty()返回是否为空\npush()向队尾插入一个元素\nfront() 返回对头元素\nback()返回队尾元素\npop()弹出队头元素\n\npriority_queue\n优先队列，默认是大根堆\n\nsize() 返回大小\n\nempty()返回是否为空\n\npush()插入一个元素\n\ntop()返回堆顶元素\n\npop()弹出堆顶元素\n\n\n\n\n\n\n\n\n\n   小根堆定义：\n   priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\n\nstack\nsize()返回大小\nempty()返回是否为空\npush() 向栈顶插入一个元素\ntop() 返回栈顶元素\npop() 弹出栈顶元素\n\ndeque\nsize()返回大小\n\nempty()返回是否为空\n\nclear()清空\n\nfront()/back()返回队头元素/队尾元素\n\npush_back()/pop_back()向队尾插入/删除一个元素\n\npush_front()/pop_front()向对头插入/删除一个元素\n\nbegin()/end()/返回队头/队尾的迭代器\n\n\n\n\n\n\n\n\n\n和vector一样支持下标访问\n\n\nset，map\n\n\n\n\n\n\n\n\n   基于平衡二叉树（红黑树），动态维护有序序列\n\nsize() 返回大小\nempty() 返回是否为空\nclear() 清空\nbegin()/end() 返回起始/末尾迭代器\n++,-- 返回前驱和后继，时间复杂度\n\nset/multiset\ninsert()插入一个元素\nfind()查找一个元素，返回该元素的迭代器，找不到则返回end()\ncount()返回某一个元素的个数\nerase() \nerase(x)删除所有值为x的元素，时间复杂度\nearse(pos)删除迭代器为pos的元素\n\n\nower_bound()/upper_bound()\nlower_bound(x)  返回大于等于x的最小的数的迭代器\n`upper_bound(x)`  返回大于x的最小的数的迭代器\n\n\n\n\n\nmap/multimap\ninsert() 插入一个pair元素\n\nearse()输入的参数是pair或者迭代器\n\nfind() 返回key相等的第一个元素，找不到返回end()\n\nlower_bound()/upper_bound()\n\n\n\n\n\n\n\n\n\nmultimap不支持[ ]访问\n\n\nunordered_set，unordered_map，unordered_multiset，unordered_multimap\n\n\n\n\n\n\n\n\n   哈希表，增删改查的时间复杂度是\n   不支持lower_bound()/upper_bound()，迭代器的++,--\nbitset\n\n\n\n\n\n\n\n\n   以二进制保存，不支持++,--\n   支持各种位运算，如：~， &amp;， |， ^，&gt;&gt;， &lt;&lt;，==，!=，[]\n   正数存储的是原码，负数存储的是补码（反码+1）\n\ncount() 返回有多少个 \nany() 判断是否至少有一个 \nnone()判断是否全为 \nset() 把所有位置成 \nset(k,v)将第k为变成v\nreset() 把所有为变成 \nflip()等价于~\nflip(k)把第k位取反\n\n","slug":"STL容器","date":"2022-02-16T09:21:30.340Z","categories_index":"STL","tags_index":"STL容器","author_index":"Snailuu"},{"id":"1df484034a65ae4d42f3134f61bf20af","title":"数据结构模板","content":"单链表\nhead存储表头，e[]存储节点的值,ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n// 初始化\nvoid init()\n{\n    head = -1;\n    idx = 0;\n}\n// 在链表头插入一个数a\nvoid insert(int a)\n{\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n}\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n{\n    head = ne[head];\n}\n\n\n双链表\ne[]表示节点的值 l[]表示节点的左指针 r[]表示节点的右指针 idx表示当前用到了哪个节点\n\n先将插入点的左右指针修改，再修改左节点指向的节点的左指针，再修改原本左节点的右指针\nint e[N], l[N], r[N], idx;\n// 初始化\nvoid init()\n{\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n{\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n}\n// 删除节点a\nvoid remove(int a)\n{\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n\n\n栈\ntt表示栈顶，初始化为0，如果  表示栈为空\nint stk[N], tt = 0;\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n// 从栈顶弹出一个数\ntt -- ;\n// 栈顶的值\nstk[tt];\n// 判断栈是否为空\nif (tt &gt; 0)\n{\n\n}\n\n普通队列\nhh 表示对头，tt表示队尾，如果  表示队列为空\nint q[N], hh = 0, tt = -1;\n// 向队尾插入一个数\nq[ ++ tt] = x;\n// 从队头弹出一个数\nhh ++ ;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh &lt;= tt)\n{\n\n}\n\n循环队列\nhh 表示对头，tt 表示队尾的后一个位置，如果  表示队列为空\nint q[N], hh = 0, tt = 0;\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh != tt)\n{\n\n}\n\n单调栈\n从栈顶到栈底的元素是严格递增（or递减）\n\n常见模型：找出每个数左边离它最近的比它大/小的数，也可以说是求数组每个数的往左第一个比他小的数，或往右第一个比他小的数\nint tt = 0;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n}\n\n例题：单调栈\n\n\n单调队列\n从队列头到队列尾的元素是严格递增\n\n常见模型：找出滑动窗口中的最大值/最小值\nint hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++ )\n{\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] = i;\n}\n例题：滑动窗口\n\n\nKMP\ns[] 是母串 p[]是子串 n是 s的长度， m是p的长度，next[]是前缀后缀相同数组\n//求子串的Next数组\nfor (int i = 1, j = 0; i &lt; m; i ++)\n{\n    //如果两个字符不一样就跳转到它前一位下标所指向的位置\n    while (j &amp;&amp; p[i] != p[j]) j = Next[j-1];\n    if (s[i] == s[j]) j++;\n    Next[i] = j;\n}\n//匹配过程\nfor (int i = 0, j = 0; i &lt;= n; i ++)\n{\n\twhile (j &amp;&amp; s[i] != p[j]) j = ne[j-1];\n    if (s[i] == p[j+1]) j++;\n    if (j == m) j=ne[j-1];//匹配成功了继续往后寻找是否还存在\n}\n\n例题：KMP\n\n\nTrie树/字典树\n应用场景：字符串检索、词频统计、字符串排序、前缀匹配\n\nson[][]存储树种每个节点的子节点cnt[]存储以每个节点结尾的单词数量，0号点既是根节点，又是空节点\nint son[N][26], cnt[N], idx;\n//插入一个字符串\nvoid insert(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            son[p][u] = ++idx; //如果没有出现过就创建一个新节点\n        p = son[p][u];\n    }\n    cnt[p]++; //以当前字符结尾的单词数量\n}\nvoid insert(char *str) //利用取址符\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int &amp;s = son[p][str[i] - 'a'];\n        if (!s)\n            s = ++idx;\n        p = s;\n    }\n    cnt[p]++;\n}\n//查询字符串出现的次数\nint query_num(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}\n\n例题：字符串统计、最大异或对\n\n\n并查集朴素并查集\np[]存储每个节点的祖宗节点\nint p[N];\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]); //路径压缩，每个点直接存最祖先\n    return p[x];\n}\nfor (int i = 1; i &lt;= n; i++) p[i] = i;\n//合并a和b所在的两个集合\np[find(a)] = find(b);\n\n例题：合并集合\n\n\n维护集合数量\np[]储存每个点的祖宗节点，num[] 只有祖宗节点才有意义，表示祖宗节点所在集合中的点的数量\nint p[N], num[N];\nfor (int i = 1; i &lt;= n; i++) p[i] = i, num[i] = 1;\nwhile (k--) //操作次数\n{\n      int a, b;\n      cin &gt;&gt; a &gt;&gt; b;\n      int k1 = find(a), k2 = find(b);\n      if (k1 != k2)\n      {\n            num[k2] += num[k1]; //把k1所在集合的点数全部加到k2集合中\n            p[k1] = k2;         //将k1的祖宗节点更改为k2\n      }\n}\n\n例题：联通块中点的数量\n\n\n维护到祖宗节点距离\np[]存储每个点的祖宗节点，d[]存储x到p[x](该点的祖宗节点)的距离\n// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x)\n    {\n       int u = find(p[x]);\n       d[x] += d[p[x]];\n       p[x] = u;\n    }\n   return p[x];\n}\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i &lt;= n; i++)\n{\n    p[i] = i;\n    d[i] = 0;\n}\n// 合并a和b所在的两个集合：\np[find(a)] = find(b);\nd[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n\n堆\nh[N]存储堆中的值，h[1]是堆顶，[x]的左儿子是2x，右儿子是2x+1\n\nph[k] 存储第k个插入的点在堆中的位置，hp[k]存储堆中下标是k的点是第几个插入的\n\n大根堆符合父亲  儿子，小根堆符合父亲  儿子\nint h[N], ph[N], hp[N], size;\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n//向下调整\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)\n    {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n//向上调整\nvoid up(int u)\n{\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])\n    {\n        heap_swap(u, u / 2);\n        u &gt;&gt;= 1;\n    }\n}\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);\n\n一般哈希拉链法\n核心：如果有两个哈希值一样的值则将他们用链表方式链接在这个哈希值位置\nint h[N], e[N], ne[N], idx;\n// 向哈希表中插入一个数\nvoid insert(int x)\n{\n    int k = (x % N + N) % N;\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx ++ ;\n}\n// 在哈希表中查询某个数是否存在\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i])\n        if (e[i] == x)\n            return true;\n    return false;\n}\n\n开放寻址法\n核心：如果当前哈希值位置被占领，则挪向下一个没有被占用的位置（上厕所）\nint h[N];\n// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\nint find(int x)\n{\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x)\n    {\n        t ++ ;\n        if (t == N) t = 0;\n    }\n    return t;\n}\n\n字符串哈希\n核心：将字符串看成是P进制数，P的取值通常为131或者13331\n\n技巧：取模的数用，这样子直接用unsigned long long 存储，溢出的结果就是取模的结果\n\n应用：判别字符串是否相同\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n}\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\n例题：字符串哈希\n\n\n","slug":"数据结构模板","date":"2022-02-16T06:09:33.395Z","categories_index":"模板","tags_index":"模板,数据结构","author_index":"Snailuu"},{"id":"768c5d200987ad0ffa01337632098c22","title":"回文字符串","content":"最长回文子序列\n最长回文子序列 LPS（Longest Palindromic Subsequence）\n\n状态表示：表示从  到  序列的最长回文子序列\n\n      \n\n      \n\n代码\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\n//动态规划求解最长回文子序列，时间复杂度为O(n^2)\nint lis_hw(char *str, int n)\n{\n    int dp[10][10], tmp;\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i &lt; n; ++i)\n        dp[i][i] = 1;\n\n    for (int i = 1; i &lt; n; ++i)\n    {\n        tmp = 0;\n        //考虑所有连续的长度为i+1的子串，str[j....j+i]\n        for (int j = 0; j + i &lt; n; j++)\n        {\n            //如果首尾相同\n            if (str[j] == str[j + i])\n                tmp = dp[j + 1][j + i - 1] + 2;\n            //如果首尾不同\n            else\n                tmp = max(dp[j + 1][j + i], dp[j][j + i - 1]);\n            dp[j][j + i] = tmp;\n        }\n    }\n    return dp[0][n - 1]; //返回字符串str[0...n-1]的最长回文子序列长度\n}\n\nint main()\n{\n    char str[10] = \"cabbeaf\";\n    int res = lpsDp(str, strlen(str));\n    cout &lt;&lt; res &lt;&lt; endl;\n    getchar();\n    return 0;\n}\n\n\n最长回文子序列长度\n\n状态表示：表示从  到  之间最长的回文字符串长度\n\n\n\n由于需要如果首尾字符相同，需要用到    和  所以 要递减枚举，  要递增枚举\n\n代码：\n   int lis_hw_len(string a)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); //开辟一个n*n的空间\n    for (int i = n - 1; i &gt;= 0; i--)\n    {\n        dp[i][i] = 1;\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (a[i] == a[j])\n                dp[i][j] = dp[i + 1][j - 1] + 2;//如果首尾相同+2\n            else\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);//首尾不同取最大\n        }\n    }\n    return \n        dp[0][n - 1]\n}\n\n\n回文子序列的个数\n\n状态表示：表示第  到第  个字符之间的回文字符串个数。\n\n如果头尾字符不同，由于要用到  和   这两个区间的数量，因此  被计算了两次，所以结果需要再减去  。\n\n如果头尾字符相同，就只需要用到两端点的右侧和左侧的数量相加，最后再+1即可。\nint lis_hw_num(string str)\n{\n    int len = str.length();\n    vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));\n    for (int j = 0; j &lt; len; j++)\n    {\n        dp[j][j] = 1;\n        for (int i = j - 1; i &gt;= 0; i--)\n        {\n            dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];\n            if (str[i] == str[j])\n                dp[i][j] += 1 + dp[i + 1][j - 1];\n        }\n    }\n    return dp[0][len - 1];\n}\n\n\n\n最长回文子串\n动态规划\n 表示子串 不是回文串，反之则是。\n状态转移：当且仅当   并且   ，反之则.\n\n\n\n","slug":"回文字符串","date":"2022-02-15T03:47:30.314Z","categories_index":"杂题","tags_index":"回文字符串,回文序列","author_index":"Snailuu"},{"id":"321148201d6e624da674378719102cb9","title":"二进制问题","content":"异或OR（半加法）：\n异或符合加法性质（奇偶性）\n\n奇+奇==偶 \n\n奇+偶==奇\n\n偶+偶==偶\n\n偶+奇==奇\n｀｀\n注：奇数-1，偶数+1\n\n\n\n\n\nbitset\nbitset&lt;32&gt;q(n)定义为一个空间大小为，名为，内容为（可以为整数，）\n\nbitset就像普通的整数一样，可以进行与（&amp;）、或（|），异或（^），左移（&lt;&lt;），右移（&gt;&gt;）等操作\n\n对于一个叫做的，可以有以下操作\nq.size() //返回大小（位数）\nq.count() //返回1的个数\nq.any() //返回是否有1\nq.none() //返回是否没有1\nq.set() //全都变成1\nq.set(p) //将第p + 1位变成1\nq.set(p, x) //将第p + 1位变成x\nq.reset() //全都变成0\nq.reset(p) //将第p + 1位变成0\nq.flip() //全都取反\nq.flip(p) //将第p + 1位取反\nq.to_ulong() //返回它转换为unsigned long的结果，如果超出范围则报错\nq.to_ullong() //返回它转换为unsigned long long的结果，如果超出范围则报错\nq.to_string() //返回它转换为string的结果\n\n特别：如果要求一个负数的补码，直接q.flip() 即可。\n\n\n","slug":"二进制","date":"2022-02-14T07:37:34.676Z","categories_index":"二进制","tags_index":"位运算,二进制,bitset","author_index":"Snailuu"},{"id":"cad29d88a5e84162d8735ff1cbc7e6a8","title":"基础算法模板","content":"归并排序\n确定分界点，\n\n递归排序\n\n归并——合二为一\n\n\nvoid merge_sort(int q[], int l, int r)//q数组从l到r排序\n{\n    if (l &gt;= r) return;//出口\n\n    int mid = l + r &gt;&gt; 1;//分界点\n\n    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//递归排序\n\n    int k = 0, i = l, j = mid + 1;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)//用两个指针分别指向两个有序数组\n        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//两个数组中较小的数放入新数组中\n        else tmp[k ++ ] = q[j ++ ];\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//当指针还没遍历第一个数组末尾将剩下全部加入新数组\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//当指针还没遍历第二个数组末尾将剩下全部加入新数组\n\n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];//将新数组的答案覆盖到原数组中\n}\n\n应用：求逆序对数量\n二分算法整数二分bool check(int x) {/* ... */} // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l &lt; r)\n    {\n        int mid = l + r &gt;&gt; 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n{\n    while (l &lt; r)\n    {\n        int mid = l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n\n浮点二分bool check(double x) {/* ... */} // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n{\n    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n\n\n\n高精度算法高精度加法// C = A + B, A &gt;= 0, B &gt;= 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n{\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size(); i ++ )\n    {\n        t += A[i];\n        if (i &lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n\n    if (t) C.push_back(t);\n    return C;\n}\n\n高精度减法// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n{\n    vector&lt;int&gt; C;\n    for (int i = 0, t = 0; i &lt; A.size(); i ++ )\n    {\n        t = A[i] - t;\n        if (i &lt; B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t = 1;\n        else t = 0;\n    }\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n高精度乘低精度// A / b = C ... r, A &gt;= 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n{\n    vector&lt;int&gt; C;\n    r = 0;\n    for (int i = A.size() - 1; i &gt;= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n高精度除以低精度// A / b = C ... r, A &gt;= 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n{\n    vector&lt;int&gt; C;\n    r = 0;\n    for (int i = A.size() - 1; i &gt;= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n前缀和与差分一维前缀和for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i];\n\nsum[i]表示～之间之和\nsum[r]-sum[l-1]表示～ｒ之间之和\n一维差分b[l] += c, b[r + 1] -= c;\n\n表示从到区间每个数加上，后面做一遍前缀和即可。\n二维前缀和在一维前缀和前提下，将和相加后多了这一部分。\n\nfor (int i = 1; i &lt;= n; i++)\n    sum[i][1] = a[i][1];\nfor (int i = 1; i &lt;= n; i++)\n    sum[1][i] = a[1][i];\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = 1; j &lt;= n; j++)\n        sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + a[i][j] - sum[i - 1][j - 1];\n\n求某一个区域～的总和\n\nint check(int x1, int y1, int x2, int y2)\n{\n    return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];\n}\n\n二维差分\nint change(int x1, int y1, int x2, int y2)\n{\n    s[x1][y1] += c, s[x2 + 1][y2] += c;\n    s[x1][y2 + 1] -= c, s[x2][y1 + 1] -= c;\n}\n\n\n\n\n\n\n\n\n\n","slug":"基础算法模板","date":"2022-02-14T04:49:54.725Z","categories_index":"模板","tags_index":"模板,基础算法","author_index":"Snailuu"},{"id":"32c803d1fefb525b38a8f636ccbac12b","title":"背包问题","content":"\n01背包例题：01背包问题\n\n描述：有  件物品和一个容量为  的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。\n\n\n\n\n\n\n\n\n\n\n   动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 i 个物品的做出决策，「0-1」正好代表不选与选两种决定。\n\n代码实现\n\n二维状态转移方程\n状态f[i][j]定义：前个物品，在容量下的最大价值\n\n\n\n\n\n\n\n\n\n   \n\n一维状态转移方程\n对于二维状态，可以看出第  种状态只由第种状态转移而成，因而可以压成一维(体积记得倒序遍历)\n\n\n\n\n\n\n\n\n\n   \n注：对于体积倒序遍历，因为要用到上次的状态，如果从小到大，用到的将会是本次状态\n\n\n\n\n\n\n\n\n\n   比如:   = 4 ,   =  9,  , \n   二维：  = \n   ​            这里的  和  都来自上一次的状态\n   一维：  \n   ​            这里的  和  也得保证是上一次的状态\n   如果按照顺序更新， \n   往后遍历到的就是本轮的状态而不是上一次的状态了。\n\n核心代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; v[i] &gt;&gt; w[i]; //每个物品占用空间及价值\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= v[i]; j--)\n            f[j] = max(f[j], f[j - v[i]] + w[i]);\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n输入优化版本：不用开两个数组记录体积和价值\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int v, w;\n        cin &gt;&gt; v &gt;&gt; w; // 边输入边处理\n        for (int j = m; j &gt;= v; j--)\n            f[j] = max(f[j], f[j - v] + w);\n    }\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n题目推荐：\n\n完全背包例题：完全背包问题\n\n描述：有  种物品和一个容量是  的背包，每种物品都有无限件可用。\n\n代码实现：\n\n朴素版本（时间复杂度)\nfor(int i = 1; i &lt;= n; i ++ )\n        for(int j = 0; j &lt;= m; j ++ )\n            for(int k = 0; k * v[i] &lt;= j; k ++ )\n                [i][j] = max([i][j], [i - 1][j - k * v[i]] + k * w[i]);\n\n优化思路：\n\n\n\n\n\n\n\n\n\n      由上两式，可得出如下递推关系：                       \n因此可以将代码写成：\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = v[i]; j &lt;= m; j++) //注意了，这里的j是从小到大枚举，和01背包不一样\n    {\n        f[j] = max(f[j], f[j - v[i]] + w[i]);\n    }\n\n\n\n题目推荐：\n\n多重背包例题：多重背包\n\n描述：与完全背包的区别就是每种物品有限制\n\n代码实现：\n\n朴素版本：\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = 0; j &lt;= m; j++)\n        for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)//s[i]表示每种物品最大数量\n            f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);\n\n优化思路：\n\n\n\n\n\n\n\n\n\n   可以分为二进制优化和单调队列优化，这里只做二进制优化解释\n   一个数字可以分成多个数字相加，而这个数字也可以表示为\n   举几个例子：\n\n\n\n\n\n\n   因此在输入的时候就可以将每个物品的数量用二进制的方式储存起来\n代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int cnt = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int a, b, s;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;//分别为体积、价值、数量\n        int k = 1;\n        while (k &lt;= s)\n        {\n            cnt++;\n            v[cnt] = a * k;//将每个二进制数量及其体积储存起来\n            w[cnt] = b * k;//将每个二进制数量及其价值储存起来\n            s -= k;\n            k *= 2;\n        }\n        if (s &gt; 0)//s分成2的cnt次幂后所剩下的数\n        {\n            cnt++;\n            v[cnt] = a * s;\n            w[cnt] = b * s;\n        }\n    }\n\n    n = cnt;\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= v[i]; j--)\n            f[j] = max(f[j], f[j - v[i]] + w[i]);//01背包做法\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n\n\n题目推荐：\n\n分组背包例题：分组背包\n\n描述： 每个组别只能取一种物品，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。\n\n思路：从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。\n\n代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; s[i];//第i组数量\n        for (int j = 0; j &lt; s[i]; j++)\n            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];//第i组第j个物品的体积和价值\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= 0; j--)\n            for (int k = 0; k &lt; s[i]; k++)//第i组的每一个进行遍历\n                if (j &gt;= v[i][k])\n                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);//与01背包一样\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n题目推荐：\n\n二维费用背包例题：P1855 榨取kkksc03\n\n描述：跟01背包问题相似，不同的是选一个物品会消耗两种东西\n\n思路：状态转移方程式基本不变，只需要再开一维数组存储\n\n代码实现：\nint main()\n{\n    int n, M, T;\n    cin &gt;&gt; n &gt;&gt; M &gt;&gt; T;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; m[i] &gt;&gt; t[i];\n        for (int j = M; j &gt;= m[i]; j--)\n            for (int k = T; k &gt;= t[i]; k--)\n                f[j][k] = max(f[j][k], f[j - m[i]][k - t[i]] + 1);//同时减少金钱和时间\n    }\n    cout &lt;&lt; f[M][T];\n    return 0;\n}\n\n题目推荐：\n\n四方定理\n\n\n有依赖的背包例题：P1064 [NOIP2006 提高组] 金明的预算方案\n\n描述：这种背包问题其实就是如果选第   件物品，就必须选第   件物品，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就称不依赖于别的物品的物品称为「主件」，依赖于某主件的物品称为「附件」。\n\n\n\n\n\n\n\n\n\n   对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。\n\n例题解析：\n\n像是01背包的升级版本，就是情况多了几种：\n不买主件\n买主件\n买主件和附件1\n买主件和附件2\n买主件和附件1+附件2\n\n\n状态转移方程式可以写成：\n买主件：\n买主件和附件1：\n买主件和附件2：\n买主件和附件1+附件2：\n\n\n\n\n代码：\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N = 2e5 + 10;\nint n, m, main_w[N], main_v[N], fu_v[N][3], fu_w[N][3], f[N];\n// n是总金钱,m是总物品,main_w主件物品的重量,main_v主件物品的价值,fu_w附件物品的重量，fu_v附件物品的价值\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int q, v, p;\n        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;\n        if (!q)\n        {\n            main_w[i] = v;\n            main_v[i] = v * p; //价值==价格*重要度\n        }\n        else\n        {\n            fu_w[q][0]++;\n            int k = fu_w[q][0];\n            fu_w[q][k] = v;\n            fu_v[q][k] = v * p;\n        }\n    }\n    for (int i = 1; i &lt;= m; i++)\n        for (int j = n; j &gt;= main_w[i]; j--)\n        {\n            f[j] = max(f[j], f[j - main_w[i]] + main_v[i]); //主件\n            if (j &gt;= fu_w[i][1] + main_w[i])//主件+附件1\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][1]] + main_v[i] + fu_v[i][1]);\n            if (j &gt;= fu_w[i][2] + main_w[i]) //主件+附件2\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][2]] + main_v[i] + fu_v[i][2]);\n            if (j &gt;= fu_w[i][1] + fu_w[i][2] + main_w[i]) //主件+附件1+附件2\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][1] - fu_w[i][2]] + main_v[i] + fu_v[i][1] + fu_v[i][2]);\n        }\n    cout &lt;&lt; f[n] &lt;&lt; endl;\n    return 0;\n}\n\n背包杂项小优化\n\n\n\n\n\n\n\n\n   根据贪心原理，当费用相同时，只需保留价值最高的；\n   当价值一定时，只需保留费用最低的；\n   当有两件物品  且   的价值大于    的价值并且  的费用小于   的费用是，只需保留 。\n输出方案\n\n\n\n\n\n\n\n\n   用二维数组来记录，path[m][n]， 表示物品（ 物品数 ）， 表示背包状态（ 背包容量 ）\n   比如path[i][j]表示物品  放在了状态为  的背包中。前提条件：path 数组全部为  。\n//记录路径\nfor (int i = 0; i &lt; n; i++)\n    for (int j = V; j &gt;= v[i]; j--)\n        if (f[j] &lt; f[j - v[i]] + w[i])\n        {\n            f[j] = f[j - v[i]] + w[i];\n            path[i][j] = 1; //把装进去的物品标记一下\n        }\n//读取路径\nint i = n - 1, j = V; // V：背包容量。n个物品\nwhile (i &gt;= 0 &amp;&amp; j &gt;= 0)\n{\n    if (path[i][j]) //物品i在j里\n    {\n        printf(\"%d \", i); //把物品i的编号输出\n        j -= v[i];        //读完了物品i，找下一个背包状态\n    }\n    i--;\n}\n\n\n\n求方案数量\n\n\n\n\n\n\n\n\n   对于给定的一个背包容量、物品费用、其他关系等等的问题，求装到一定容量的方案总数。\n   这种问题就是把求最大值换成求和即可。\n   初始条件：dp[0]=1（容量为  也算一种方案，即什么都不装）\n求最优方案总数将01背包里面的数组定义修改，状态为只能放前  个物品的情况下，容量为  的背包“正好装满”所能达到的最大总价值。\n这样修改后每种状态都可以用一个来表示方案总数\n 表示只考虑前个物品时背包体积正好是时的最大价值。\n 表示只考虑前个物品时背包体积正好是时的方案数。\n\n\n\n\n\n\n\n\n\n   转移方程：\n\n如果且说明我们此时不选择把物品放入背包更优，方案数由 转移过来。\n如果且说明我们此时不选择把物品放入背包更优，方案数由 转移过来。\n如果且说明放入或者不放入都能取得最优解，方案数由 转移过来。\n\n//初始条件\nmemset(f, 0x3f3f, sizeof(f));  // 避免没有装满而进行了转移\nf[0] = 0;\ng[0] = 1;  // 什么都不装是一种方案\n//////////////////////////////////////\nfor (int i = 0; i &lt; N; i++)\n{\n    for (int j = V; j &gt;= v[i]; j--)\n    {\n        int tmp = max(dp[j], dp[j - v[i]] + w[i]);\n        int c = 0;\n        if (tmp == dp[j])\n            c += cnt[j]; // 如果从dp[j]转移\n        if (tmp == dp[j - v[i]] + w[i])\n            c += cnt[j - v[i]]; // 如果从dp[j-v[i]]转移\n        dp[j] = tmp;\n        cnt[j] = c;\n    }\n}\nint max = 0; // 寻找最优解\nfor (int i = 0; i &lt;= V; i++)\n{\n    max = max(max, dp[i]);\n}\nint res = 0;\nfor (int i = 0; i &lt;= V; i++)\n{\n    if (dp[i] == max)\n    {\n        res += cnt[i]; // 求和最优解方案数\n    }\n}\n\n\n\n","slug":"背包问题","date":"2022-02-13T12:09:32.829Z","categories_index":"动态规划","tags_index":"动态规划,背包","author_index":"Snailuu"},{"id":"f83333b56248d745b141d3885b656c81","title":"最小生成树","content":"假设表示图中点数，表示图中边数\n朴素版Prim算法（适用于稠密图，复杂度O())思路：将条边到另一条边的距离初始化成从遍历到找到集合外距离最小的点标记为，用来更新它到集合的距离，标记一下\n例题：Prim算法求最小生成树\n核心代码：\n// st[i] 表示点i是否在当前生成树集合中\n// dist[i] 表示点i到当前集合的最短边的长度\n// g[i][j] 表示点i和点j之间边的长度\n// 返回值：最小生成树中所有边的总长度\nint prim()\n{\n    memset(dist, 0x3f, sizeof(dist));\n    int res = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) //第一次找到或者找到更小的\n                t = j;\n        if (i &amp;&amp; dist[t] == INF)\n            return INF; //无法生成最小树\n        if (i)\n            res += dist[t];\n        st[t] = 1;\n        for (int j = 1; j &lt;= n; j++) //更新t所有连接点\n            dist[j] = min(dist[j], g[t][j]);\n    }\n    return res;\n}\n\n\n\nKruskal算法（适用于稀疏图，复杂度O())思路：将所有边权按小到大排序，从小到大挑不多余的边\n代码实现：\nstruct Edge\n{ //用结构体储存点a到b的边权w\n    int a, b, w;\n    bool operator&lt;(const Edge &amp;W) const\n    {\n        return w &lt; W.w;\n    }\n} edge[M];\nint find(int x)\n{\n    if (p[x] != x)\n        p[x] = find(p[x]);\n    return p[x];\n}\nint kruskal()\n{\n    sort(edge, edge + m);\n    for (int i = 1; i &lt;= n; i++)\n        p[i] = i; //初始化并查集\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i++)\n    {\n        int a = edge[i].a, b = edge[i].b, w = edge[i].w;\n        a = find(a), b = find(b);\n        if (a != b) //如果两个联通块不连通，将这两个联通块合并\n        {\n            p[a] = b;\n            res += w; //最小生成树的边权和\n            cnt++;    //加入点的数量\n        }\n    }\n    if (cnt &lt; n - 1)\n        return INF;\n    return res;\n}\n\n","slug":"最小生成树","date":"2022-02-13T07:22:11.269Z","categories_index":"图论","tags_index":"图论,生成树","author_index":"Snailuu"},{"id":"01d132f13ac67dff21350f57c338a855","title":"拓扑排序","content":"拓扑排序应用场景在做某些事的时候他们之间有前后关系（顺序关系或者依赖关系），比如安排座位，穿衣服先后，课程学习等等。\n拓扑排序只对于有向无环图而言(Directed Acyclic Graph简称DAG)\n\n\n\n\n\n\n\n\n\n   如果有a,b,c,d等件事情，a的优先级最高，d的优先级最低，那么abcd或者acbd都是可行的排序。\n基于BFS的拓扑排序\n无前驱的顶点优先\n\n将入度为零的点入队\n\n访问对头所有的邻接点，并将其入度减，如果此时的入度为就将其入队\n\n当队列为空时，如果还有点从未进入队列中，说明这个图不是DAG，不存在拓扑排序。\n反之如果全部进过队列了，队列依次输出的就是拓扑排序。\n\n\n\n\n部分代码：\nvoid topsort()\n{\n    for (int i = 1; i &lt;= n; i++)\n        if (!in[i])\n            num[i] = 1, q.push(i);\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i]; //枚举当前队头的所有邻接点\n            in[j]--;      //减少入度\n            if (!in[j])\n                q.push(j); //如果入度为0就入队\n        }\n    }\n}\n\n\n\n无后继的顶点优先\n就是无前去顶点优先的逆过程，将入度为改成出度为的点入队，后面情况跟前面的一样，最后队列输出的是拓扑排序的逆序。\n\n\n\n注意：如果有要求要字典序输出，将队列弄成一个优先队列，依据题意建大根堆或者小根堆。\n例题Codeforces Round #285 (Div. 2)C. Misha and Forest","slug":"拓扑排序","date":"2022-02-13T07:19:11.215Z","categories_index":"图论","tags_index":"图论,排序","author_index":"Snailuu"},{"id":"60a84708f3c49aa5488e16601f40a652","title":"算法选择","content":"数据范围推断算法选择\n\n\n数据范围\n时间复杂度\n算法\n\n\n\n\n指数级别\ndfs+剪枝，状态压缩dp\n\n\n\n\nfloyd，dp，高斯消元\n\n\n\n，\ndp，二分，朴素版Dijkstra，朴素版Prim，Bellman-Ford\n\n\n\n\n块状链表，分块，莫队\n\n\n\n\n各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，kruskal，spfa，求凸包，求平面交，二分，CDQ分治，整体二分，后缀数组，树链部分，动态树\n\n\n\n及常数较小的的算法\n单调队列，hash，双指针扫描，并查集，kmp，AC自动机，sort，树状数组，heap，dijkstra，spfa\n\n\n\n\n双指针扫描，kmp，AC自动机，线性筛素数\n\n\n\n\n判断质数\n\n\n\n\n最大公约数，快速幂，数位DP\n\n\n\n\n高精度加减乘除\n\n\n\n，k表示位数\n高精度加减，FFT/NTT\n\n\n\n图论中算法选择\n\n\n\n\n\n\n\n\n   一个图中，顶点数记为n，边数记为m\n   当m时，称之为稀疏图\n   当m相对比较大时，称之为稠密图\n\n\n\n","slug":"算法选择","date":"2022-02-13T07:09:10.466Z","categories_index":"数据范围","tags_index":"算法选择","author_index":"Snailuu"}]