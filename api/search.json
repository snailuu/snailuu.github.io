[{"id":"f83333b56248d745b141d3885b656c81","title":"最小生成树","content":"假设表示图中点数，表示图中边数\n朴素版Prim算法（适用于稠密图，复杂度O()思路：将条边到另一条边的距离初始化成从遍历到找到集合外距离最小的点标记为，用来更新它到集合的距离，标记一下\n例题：Prim算法求最小生成树\n核心代码：\n// st[i] 表示点i是否在当前生成树集合中\n// dist[i] 表示点i到当前集合的最短边的长度\n// g[i][j] 表示点i和点j之间边的长度\n// 返回值：最小生成树中所有边的总长度\nint prim()\n{\n    memset(dist,0x3f,sizeof(dist));\n    int res=0;\n    for(int i=0;i&lt;n;i++)\n    {\n        int t=-1;\n        for(int j=1;j&lt;=n;j++)\n            if(!st[j]&amp;&amp;(t==-1||dist[t]&gt;dist[j]))//第一次找到或者找到更小的\n                t=j;\n        if(i&amp;&amp;dist[t]==INF) return INF;//无法生成最小树\n        if(i) res+=dist[t];\n        st[t]=1;\n        for(int j=1;j&lt;=n;j++)//更新t所有连接点\n            dist[j]=min(dist[j],g[t][j]);\n    }\n    return res;\n}\n\n\n\nKruskal算法（适用于稀疏图，复杂度O()思路：将所有边权按小到大排序，从小到大挑不多余的边\n代码实现：\nstruct Edge{//用结构体储存点a到b的边权w\n    int a,b,w;\n    bool operator&lt;(const Edge &amp;W)const{\n        return w&lt;W.w;\n}\n}edge[M];\nint find(int x)\n{\n    if(p[x]!=x)p[x]=find(p[x]);\n    return p[x];\n}\nint kruskal()\n{\n    sort(edge,edge+m);\n    for(int i=1;i&lt;=n;i++)p[i]=i;//初始化并查集\n    int res=0,cnt=0;\n    for(int i=0;i&lt;m;i++)\n    {\n        int a=edge[i].a,b=edge[i].b,w=edge[i].w;\n        a=find(a),b=find(b);\n        if(a!=b)//如果两个联通块不连通，将这两个联通块合并\n        {\n            p[a]=b;\n            res+=w;//最小生成树的边权和\n            cnt++;//加入点的数量\n        }\n    }\n    if(cnt&lt;n-1)return INF;\n    return res;\n}\n\n","slug":"最小生成树","date":"2022-02-13T07:22:11.269Z","categories_index":"图论","tags_index":"图论,生成树","author_index":"Snailuu"},{"id":"aa03b2f0abb625816c3d81ed8f81147b","title":"图论最短路问题","content":"朴素版Dijkstra算法(适用于稠密图)思路\n初始化距离数组和邻接矩阵（无穷大）\n处理重边问题在输入取最小值\n每次找到一个最小的未更新的答案点\n将其连边答案全部更新\n\n例题：Dijkstra算法朴素版\n代码实现如下：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N=520,INF=0x3f3f3f3f;\nint n,m;\nint g[N][N],dis[N];\nbool st[N];\n\nint dijkstra()\n{\n    dis[1]=0;//每个点到一号点的最短距离\n    //如需求到s点的一开始将dis[s]定义为0即可\n    for(int i=0;i&lt;n-1;i++)\n    {\n        int t=-1;\n        for(int j=1;j&lt;=n;j++)\n        {\n            if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n        }\n        for(int j=1;j&lt;=n;j++)\n            dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n        st[t]=true;\n    }\n    if(dis[n]==0x3f3f3f3f)return -1;//1~n之间不连通，无法构成路径，也就没有最短距离\n    return dis[n];\n}\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;m;\n    fill(g[0],g[0]+N*N,INF);\n    fill(dis,dis+N,INF);\n    while(m--)\n    {\n        int x,y,c;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;\n        g[x][y]=min(g[x][y],c);//处理重边\n    }\n    cout&lt;&lt;dijkstra()&lt;&lt;endl;\n    return 0;\n}\n\n堆优化版Dijkstra算法(适用于稀疏图)优点： \n\n堆可以动态维护一个集合中的最小值\n堆动态支持插入，删除，修改一个数\n\n优化部分：\nfor(int j=1;j&lt;=n;j++)\n        {\n            if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n        }\n//每次寻找一个最小值可以用堆来维护一个最小值\n//复杂度从O(n)-&gt;O(1)\n////////////////////////////////////////////\nfor(int j=1;j&lt;=n;j++)\n            dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n//每次将点更新在堆中修改复杂度为mlogm\n//复杂度从O(n)-&gt;O(mlogm)\n//////////////////////////////////////////////\n//总体复杂度从O(n^2)-&gt;O(mlogm)\n\n例题：Dijkstra算法堆优化版\n代码实现：\n#include&lt;bits/stdc++.h&gt;\n#define PII pair&lt;int,int&gt;\nusing namespace std;\n\nconst int N=1e6+10,INF=0x3f3f3f3f;\nint n,m;\nint h[N],e[N],ne[N],idx;\nint dis[N],w[N];\nbool st[N];\n\nvoid add(int a,int b,int c)\n{\n    e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;\n}\nint dijkstra()\n{\n    fill(dis,dis+N,INF);\n    dis[1]=0;\n    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt; heap;//优先队列默认大根堆，这样子写可以维护小根堆,pair&lt;int,int&gt;第一个值存数值，第二个值存下标\n    heap.push({0,1});\n    while(heap.size())\n    {\n        auto t=heap.top();\n        heap.pop();\n        int ver=t.second,distance=t.first;\n        if(st[ver])continue;//每次处理均为最小值且未处理过的\n        st[ver]=true;\n        for(int i=h[ver];i!=-1;i=ne[i])\n        {\n            int j=e[i];\n            if(dis[j]&gt;dis[ver]+w[i])//有更短路就替换\n            {\n                dis[j]=dis[ver]+w[i];\n                heap.push({dis[j],j});//将新的方案加入到队列中\n            }\n        }\n    }\n    //队列为空即走完整个图\n    if(dis[n]==INF)return -1;\n    return dis[n];\n}\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;m;\n    fill(h,h+N,-1);//将头结点数组全部初始化成-1\n    while(m--)\n    {\n        int x,y,c;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;\n        add(x,y,c);\n    }\n    cout&lt;&lt;dijkstra()&lt;&lt;endl;\n    return 0;\n}\n\n\nSPFA算法（适用于稀疏图）Bellman-Ford太呆\n优点：\n\n每次只更新与结点有关点的最小距离\n\n例题：SPFA求最短路\n代码实现：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[N], ne[N], w[N], idx;//稀疏图用邻接表来存图\nint n, m;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint spfa()\n{\n    fill(dist, dist + N, INF);//先将每个到源点的距离初始化成正无穷\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        int t = q.front();\n        q.pop();\n        st[t] = false; //出队了\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])//更新t结点的所有距离\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])\n                {\n                    q.push(j);//更新的点第一次访问就进度，后面可能还能再利用其更新其他点\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    while (m--)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if (t == INF)//如果到n点还无法更新距离说明无法连通\n        puts(\"impossible\");\n    else\n        cout &lt;&lt; t &lt;&lt; endl;\n    return 0;\n}\n\n\n","slug":"最短路","date":"2022-02-13T07:19:11.220Z","categories_index":"图论","tags_index":"最短路,稠密图,稀疏图","author_index":"Snailuu"},{"id":"60a84708f3c49aa5488e16601f40a652","title":"算法选择","content":"数据范围推断算法选择\n\n\n数据范围\n时间复杂度\n算法\n\n\n\n\n指数级别\ndfs+剪枝，状态压缩dp\n\n\n\n\nfloyd，dp，高斯消元\n\n\n\n，\ndp，二分，朴素版Dijkstra，朴素版Prim，Bellman-Ford\n\n\n\n\n块状链表，分块，莫队\n\n\n\n\n各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，kruskal，spfa，求凸包，求平面交，二分，CDQ分治，整体二分，后缀数组，树链部分，动态树\n\n\n\n及常数较小的的算法\n单调队列，hash，双指针扫描，并查集，kmp，AC自动机，sort，树状数组，heap，dijkstra，spfa\n\n\n\n\n双指针扫描，kmp，AC自动机，线性筛素数\n\n\n\n\n判断质数\n\n\n\n\n最大公约数，快速幂，数位DP\n\n\n\n\n高精度加减乘除\n\n\n\n，k表示位数\n高精度加减，FFT/NTT\n\n\n\n图论中算法选择\n\n\n\n\n\n\n\n\n   一个图中，顶点数记为n，边数记为m\n   当m时，称之为稀疏图\n   当m相对比较大时，称之为稠密图\n\n\n\n","slug":"算法选择","date":"2022-02-13T07:09:10.466Z","categories_index":"数据范围","tags_index":"算法选择","author_index":"Snailuu"},{"id":"01d132f13ac67dff21350f57c338a855","title":"拓扑排序","content":"拓扑排序应用场景在做某些事的时候他们之间有前后关系（顺序关系或者依赖关系），比如安排座位，穿衣服先后，课程学习等等。\n拓扑排序只对于有向无环图而言(Directed Acyclic Graph简称DAG)\n\n\n\n\n\n\n\n\n\n   如果有a,b,c,d等件事情，a的优先级最高，d的优先级最低，那么abcd或者acbd都是可行的排序。\n基于BFS的拓扑排序\n无前驱的顶点优先\n\n将入度为零的点入队\n\n访问对头所有的邻接点，并将其入度减，如果此时的入度为就将其入队\n\n当队列为空时，如果还有点从未进入队列中，说明这个图不是DAG，不存在拓扑排序。\n反之如果全部进过队列了，队列依次输出的就是拓扑排序。\n\n\n\n\n部分代码：\nvoid topsort()\n{\n    for(int i=1;i&lt;=n;i++)\n        if(!in[i])\n            num[i]=1,q.push(i);\n    while(q.size())\n    {\n        auto t=q.front();\n        q.pop();\n        for(int i=h[t];i!=-1;i=ne[i])\n        {\n            int j=e[i];//枚举当前队头的所有邻接点\n            in[j]--;//减少入度\n            if(!in[j])q.push(j);//如果入度为0就入队\n        }\n    }\n}\n\n\n\n无后继的顶点优先\n就是无前去顶点优先的逆过程，将入度为改成出度为的点入队，后面情况跟前面的一样，最后队列输出的是拓扑排序的逆序。\n\n\n\n注意：如果有要求要字典序输出，将队列弄成一个优先队列，依据题意建大根堆或者小根堆。\n","slug":"拓扑排序","date":"2022-02-13T07:19:11.215Z","categories_index":"图论","tags_index":"图论,排序","author_index":"Snailuu"}]