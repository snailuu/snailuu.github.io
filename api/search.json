[{"id":"3c194b2f2319e046c85e1bc082983d3c","title":"模板","content":"本篇文章作为跳转文章，如需阅读模板请点击下方各类按钮基础算法数据结构","slug":"模板","date":"2022-02-16T08:35:59.408Z","categories_index":"模板","tags_index":"","author_index":"Snailuu"},{"id":"40516069856649c61c80ebcc0b14851f","title":"杂乱笔记","content":"字符串\nstring类的插入insert(pos,string) 在下标pos和pos+1之间插入字符串string。\nstring类的删除earse(pos,num)从下标pos开始删除num个字符，如果num为空则删除pos后面的所有字符。\n\n","slug":"杂点笔记","date":"2022-02-16T04:06:58.194Z","categories_index":"笔记","tags_index":"字符串","author_index":"Snailuu"},{"id":"ef2958a60eebffed61302cfeed7e9fed","title":"错误之路","content":"本篇文章用于记录学习之路/比赛上看似不起眼的小错误却又不得不重视的，一直都在更新……\n2022.02.15 res=pow(a,b) 当res为int类型时，b应该为常量。当res为double类型时，b应该为常量、int、double。\n\n","slug":"错误之路","date":"2022-02-16T02:58:30.254Z","categories_index":"","tags_index":"","author_index":"Snailuu"},{"id":"1df484034a65ae4d42f3134f61bf20af","title":"数据结构模板","content":"单链表\nhead存储表头，e[]存储节点的值,ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n// 初始化\nvoid init()\n{\n    head = -1;\n    idx = 0;\n}\n// 在链表头插入一个数a\nvoid insert(int a)\n{\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n}\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n{\n    head = ne[head];\n}\n\n\n双链表\ne[]表示节点的值 l[]表示节点的左指针 r[]表示节点的右指针 idx表示当前用到了哪个节点\n\n先将插入点的左右指针修改，再修改左节点指向的节点的左指针，再修改原本左节点的右指针\nint e[N], l[N], r[N], idx;\n// 初始化\nvoid init()\n{\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n{\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n}\n// 删除节点a\nvoid remove(int a)\n{\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n\n\n栈\ntt表示栈顶，初始化为0，如果  表示栈为空\nint stk[N], tt = 0;\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n// 从栈顶弹出一个数\ntt -- ;\n// 栈顶的值\nstk[tt];\n// 判断栈是否为空\nif (tt &gt; 0)\n{\n\n}\n\n普通队列\nhh 表示对头，tt表示队尾，如果  表示队列为空\nint q[N], hh = 0, tt = -1;\n// 向队尾插入一个数\nq[ ++ tt] = x;\n// 从队头弹出一个数\nhh ++ ;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh &lt;= tt)\n{\n\n}\n\n循环队列\nhh 表示对头，tt 表示队尾的后一个位置，如果  表示队列为空\nint q[N], hh = 0, tt = 0;\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh != tt)\n{\n\n}\n\n单调栈\n从栈顶到栈底的元素是严格递增（or递减）\n\n常见模型：找出每个数左边离它最近的比它大/小的数，也可以说是求数组每个数的往左第一个比他小的数，或往右第一个比他小的数\nint tt = 0;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n}\n\n例题：单调栈\n\n\n单调队列\n从队列头到队列尾的元素是严格递增\n\n常见模型：找出滑动窗口中的最大值/最小值\nint hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++ )\n{\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] = i;\n}\n例题：滑动窗口\n\n\nKMP\ns[] 是母串 p[]是子串 n是 s的长度， m是p的长度，next[]是前缀后缀相同数组\n//求子串的Next数组\nfor (int i = 1, j = 0; i &lt; m; i ++)\n{\n    //如果两个字符不一样就跳转到它前一位下标所指向的位置\n    while (j &amp;&amp; p[i] != p[j]) j = Next[j-1];\n    if (s[i] == s[j]) j++;\n    Next[i] = j;\n}\n//匹配过程\nfor (int i = 0, j = 0; i &lt;= n; i ++)\n{\n\twhile (j &amp;&amp; s[i] != p[j]) j = ne[j-1];\n    if (s[i] == p[j+1]) j++;\n    if (j == m) j=ne[j-1];//匹配成功了继续往后寻找是否还存在\n}\n\n例题：KMP\n\n\nTrie树/字典树\n应用场景：字符串检索、词频统计、字符串排序、前缀匹配\n\nson[][]存储树种每个节点的子节点cnt[]存储以每个节点结尾的单词数量，0号点既是根节点，又是空节点\nint son[N][26], cnt[N], idx;\n//插入一个字符串\nvoid insert(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            son[p][u] = ++idx; //如果没有出现过就创建一个新节点\n        p = son[p][u];\n    }\n    cnt[p]++; //以当前字符结尾的单词数量\n}\nvoid insert(char *str) //利用取址符\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int &amp;s = son[p][str[i] - 'a'];\n        if (!s)\n            s = ++idx;\n        p = s;\n    }\n    cnt[p]++;\n}\n//查询字符串出现的次数\nint query_num(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}\n\n例题：字符串统计、最大异或对\n\n\n并查集朴素并查集\np[]存储每个节点的祖宗节点\nint p[N];\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]); //路径压缩，每个点直接存最祖先\n    return p[x];\n}\nfor (int i = 1; i &lt;= n; i++) p[i] = i;\n//合并a和b所在的两个集合\np[find(a)] = find(b);\n\n维护集合数量\np[]储存每个点的祖宗节点，num[] 只有祖宗节点才有意义，表示祖宗节点所在集合中的点的数量\nint p[N], num[N];\nfor (int i = 1; i &lt;= n; i++) p[i] = i, num[i] = 1;\nwhile (k--) //操作次数\n{\n      int a, b;\n      cin &gt;&gt; a &gt;&gt; b;\n      int k1 = find(a), k2 = find(b);\n      if (k1 != k2)\n      {\n            num[k2] += num[k1]; //把k1所在集合的点数全部加到k2集合中\n            p[k1] = k2;         //将k1的祖宗节点更改为k2\n      }\n}\n\n维护到祖宗节点距离\np[]存储每个点的祖宗节点，d[]存储x到p[x](该点的祖宗节点)的距离\n// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x)\n    {\n       int u = find(p[x]);\n       d[x] += d[p[x]];\n       p[x] = u;\n    }\n   return p[x];\n}\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i &lt;= n; i++)\n{\n    p[i] = i;\n    d[i] = 0;\n}\n// 合并a和b所在的两个集合：\np[find(a)] = find(b);\nd[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n\n\n\n例题：合并集合、联通块中点的数量\n\n\n堆\nh[N]存储堆中的值，h[1]是堆顶，[x]的左儿子是2x，右儿子是2x+1\n\nph[k] 存储第k个插入的点在堆中的位置，hp[k]存储堆中下标是k的点是第几个插入的\n\n大根堆符合父亲  儿子，小根堆符合父亲  儿子\nint h[N], ph[N], hp[N], size;\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n//向下调整\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)\n    {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n//向上调整\nvoid up(int u)\n{\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])\n    {\n        heap_swap(u, u / 2);\n        u &gt;&gt;= 1;\n    }\n}\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);\n\n一般哈希拉链法\n核心：如果有两个哈希值一样的值则将他们用链表方式链接在这个哈希值位置\nint h[N], e[N], ne[N], idx;\n// 向哈希表中插入一个数\nvoid insert(int x)\n{\n    int k = (x % N + N) % N;\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx ++ ;\n}\n// 在哈希表中查询某个数是否存在\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i])\n        if (e[i] == x)\n            return true;\n    return false;\n}\n\n开放寻址法\n核心：如果当前哈希值位置被占领，则挪向下一个没有被占用的位置（上厕所）\nint h[N];\n// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\nint find(int x)\n{\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x)\n    {\n        t ++ ;\n        if (t == N) t = 0;\n    }\n    return t;\n}\n\n字符串哈希\n核心：将字符串看成是P进制数，P的取值通常为131或者13331\n\n技巧：取模的数用，这样子直接用unsigned long long 存储，溢出的结果就是取模的结果\n\n应用：判别字符串是否相同\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n}\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\n例题：字符串哈希\n\n\n","slug":"数据结构模板","date":"2022-02-16T06:09:33.395Z","categories_index":"模板","tags_index":"模板,数据结构","author_index":"Snailuu"},{"id":"768c5d200987ad0ffa01337632098c22","title":"回文字符串","content":"最长回文子序列\n最长回文子序列 LPS（Longest Palindromic Subsequence）\n\n状态表示：表示从  到  序列的最长回文子序列\n\n      \n\n      \n\n代码\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\n//动态规划求解最长回文子序列，时间复杂度为O(n^2)\nint lis_hw(char *str, int n)\n{\n    int dp[10][10], tmp;\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i &lt; n; ++i)\n        dp[i][i] = 1;\n\n    for (int i = 1; i &lt; n; ++i)\n    {\n        tmp = 0;\n        //考虑所有连续的长度为i+1的子串，str[j....j+i]\n        for (int j = 0; j + i &lt; n; j++)\n        {\n            //如果首尾相同\n            if (str[j] == str[j + i])\n                tmp = dp[j + 1][j + i - 1] + 2;\n            //如果首尾不同\n            else\n                tmp = max(dp[j + 1][j + i], dp[j][j + i - 1]);\n            dp[j][j + i] = tmp;\n        }\n    }\n    return dp[0][n - 1]; //返回字符串str[0...n-1]的最长回文子序列长度\n}\n\nint main()\n{\n    char str[10] = \"cabbeaf\";\n    int res = lpsDp(str, strlen(str));\n    cout &lt;&lt; res &lt;&lt; endl;\n    getchar();\n    return 0;\n}\n\n\n最长回文子序列长度\n\n状态表示：表示从  到  之间最长的回文字符串长度\n\n\n\n由于需要如果首尾字符相同，需要用到    和  所以 要递减枚举，  要递增枚举\n\n代码：\n   int lis_hw_len(string a)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); //开辟一个n*n的空间\n    for (int i = n - 1; i &gt;= 0; i--)\n    {\n        dp[i][i] = 1;\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (a[i] == a[j])\n                dp[i][j] = dp[i + 1][j - 1] + 2;//如果首尾相同+2\n            else\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);//首尾不同取最大\n        }\n    }\n    return \n        dp[0][n - 1]\n}\n\n\n回文子序列的个数\n\n状态表示：表示第  到第  个字符之间的回文字符串个数。\n\n如果头尾字符不同，由于要用到  和   这两个区间的数量，因此  被计算了两次，所以结果需要再减去  。\n\n如果头尾字符相同，就只需要用到两端点的右侧和左侧的数量相加，最后再+1即可。\nint lis_hw_num(string str)\n{\n    int len = str.length();\n    vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));\n    for (int j = 0; j &lt; len; j++)\n    {\n        dp[j][j] = 1;\n        for (int i = j - 1; i &gt;= 0; i--)\n        {\n            dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];\n            if (str[i] == str[j])\n                dp[i][j] += 1 + dp[i + 1][j - 1];\n        }\n    }\n    return dp[0][len - 1];\n}\n\n\n\n最长回文子串\n动态规划\n 表示子串 不是回文串，反之则是。\n状态转移：当且仅当   并且   ，反之则.\n\n\n\n","slug":"回文字符串","date":"2022-02-15T03:47:30.314Z","categories_index":"杂题","tags_index":"回文字符串,回文序列","author_index":"Snailuu"},{"id":"321148201d6e624da674378719102cb9","title":"二进制问题","content":"异或OR（半加法）：\n异或符合加法性质（奇偶性）\n\n奇+奇==偶 \n\n奇+偶==奇\n\n偶+偶==偶\n\n偶+奇==奇\n｀｀\n注：奇数-1，偶数+1\n\n\n\n\n\nbitset\nbitset&lt;32&gt;q(n)定义为一个空间大小为，名为，内容为（可以为整数，）\n\nbitset就像普通的整数一样，可以进行与（&amp;）、或（|），异或（^），左移（&lt;&lt;），右移（&gt;&gt;）等操作\n\n对于一个叫做的，可以有以下操作\nq.size() //返回大小（位数）\nq.count() //返回1的个数\nq.any() //返回是否有1\nq.none() //返回是否没有1\nq.set() //全都变成1\nq.set(p) //将第p + 1位变成1\nq.set(p, x) //将第p + 1位变成x\nq.reset() //全都变成0\nq.reset(p) //将第p + 1位变成0\nq.flip() //全都取反\nq.flip(p) //将第p + 1位取反\nq.to_ulong() //返回它转换为unsigned long的结果，如果超出范围则报错\nq.to_ullong() //返回它转换为unsigned long long的结果，如果超出范围则报错\nq.to_string() //返回它转换为string的结果\n\n特别：如果要求一个负数的补码，直接q.flip() 即可。\n\n\n","slug":"二进制","date":"2022-02-14T07:37:34.676Z","categories_index":"二进制","tags_index":"位运算,二进制,bitset","author_index":"Snailuu"},{"id":"cad29d88a5e84162d8735ff1cbc7e6a8","title":"基础算法模板","content":"归并排序\n确定分界点，\n\n递归排序\n\n归并——合二为一\n\n\nvoid merge_sort(int q[], int l, int r)//q数组从l到r排序\n{\n    if (l &gt;= r) return;//出口\n\n    int mid = l + r &gt;&gt; 1;//分界点\n\n    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//递归排序\n\n    int k = 0, i = l, j = mid + 1;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)//用两个指针分别指向两个有序数组\n        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//两个数组中较小的数放入新数组中\n        else tmp[k ++ ] = q[j ++ ];\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//当指针还没遍历第一个数组末尾将剩下全部加入新数组\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//当指针还没遍历第二个数组末尾将剩下全部加入新数组\n\n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];//将新数组的答案覆盖到原数组中\n}\n\n应用：求逆序对数量\n二分算法整数二分bool check(int x) {/* ... */} // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l &lt; r)\n    {\n        int mid = l + r &gt;&gt; 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n{\n    while (l &lt; r)\n    {\n        int mid = l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n\n浮点二分bool check(double x) {/* ... */} // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n{\n    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n\n\n\n高精度算法高精度加法// C = A + B, A &gt;= 0, B &gt;= 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n{\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size(); i ++ )\n    {\n        t += A[i];\n        if (i &lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n\n    if (t) C.push_back(t);\n    return C;\n}\n\n高精度减法// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n{\n    vector&lt;int&gt; C;\n    for (int i = 0, t = 0; i &lt; A.size(); i ++ )\n    {\n        t = A[i] - t;\n        if (i &lt; B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t = 1;\n        else t = 0;\n    }\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n高精度乘低精度// A / b = C ... r, A &gt;= 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n{\n    vector&lt;int&gt; C;\n    r = 0;\n    for (int i = A.size() - 1; i &gt;= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n高精度除以低精度// A / b = C ... r, A &gt;= 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n{\n    vector&lt;int&gt; C;\n    r = 0;\n    for (int i = A.size() - 1; i &gt;= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n前缀和与差分一维前缀和for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i];\n\nsum[i]表示～之间之和\nsum[r]-sum[l-1]表示～ｒ之间之和\n一维差分b[l] += c, b[r + 1] -= c;\n\n表示从到区间每个数加上，后面做一遍前缀和即可。\n二维前缀和在一维前缀和前提下，将和相加后多了这一部分。\n\nfor (int i = 1; i &lt;= n; i++)\n    sum[i][1] = a[i][1];\nfor (int i = 1; i &lt;= n; i++)\n    sum[1][i] = a[1][i];\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = 1; j &lt;= n; j++)\n        sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + a[i][j] - sum[i - 1][j - 1];\n\n求某一个区域～的总和\n\nint check(int x1, int y1, int x2, int y2)\n{\n    return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];\n}\n\n二维差分\nint change(int x1, int y1, int x2, int y2)\n{\n    s[x1][y1] += c, s[x2 + 1][y2] += c;\n    s[x1][y2 + 1] -= c, s[x2][y1 + 1] -= c;\n}\n\n\n\n\n\n\n\n\n\n","slug":"基础算法模板","date":"2022-02-14T04:49:54.725Z","categories_index":"模板","tags_index":"模板,基础算法","author_index":"Snailuu"},{"id":"32c803d1fefb525b38a8f636ccbac12b","title":"背包问题","content":"\n01背包例题：01背包问题\n\n描述：有  件物品和一个容量为  的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。\n\n\n\n\n\n\n\n\n\n\n   动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 i 个物品的做出决策，「0-1」正好代表不选与选两种决定。\n\n代码实现\n\n二维状态转移方程\n状态f[i][j]定义：前个物品，在容量下的最大价值\n\n\n\n\n\n\n\n\n\n   \n\n一维状态转移方程\n对于二维状态，可以看出第  种状态只由第种状态转移而成，因而可以压成一维(体积记得倒序遍历)\n\n\n\n\n\n\n\n\n\n   \n注：对于体积倒序遍历，因为要用到上次的状态，如果从小到大，用到的将会是本次状态\n\n\n\n\n\n\n\n\n\n   比如:   = 4 ,   =  9,  , \n   二维：  = \n   ​            这里的  和  都来自上一次的状态\n   一维：  \n   ​            这里的  和  也得保证是上一次的状态\n   如果按照顺序更新， \n   往后遍历到的就是本轮的状态而不是上一次的状态了。\n\n核心代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; v[i] &gt;&gt; w[i]; //每个物品占用空间及价值\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= v[i]; j--)\n            f[j] = max(f[j], f[j - v[i]] + w[i]);\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n输入优化版本：不用开两个数组记录体积和价值\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int v, w;\n        cin &gt;&gt; v &gt;&gt; w; // 边输入边处理\n        for (int j = m; j &gt;= v; j--)\n            f[j] = max(f[j], f[j - v] + w);\n    }\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n题目推荐：\n\n完全背包例题：完全背包问题\n\n描述：有  种物品和一个容量是  的背包，每种物品都有无限件可用。\n\n代码实现：\n\n朴素版本（时间复杂度)\nfor(int i = 1; i &lt;= n; i ++ )\n        for(int j = 0; j &lt;= m; j ++ )\n            for(int k = 0; k * v[i] &lt;= j; k ++ )\n                [i][j] = max([i][j], [i - 1][j - k * v[i]] + k * w[i]);\n\n优化思路：\n\n\n\n\n\n\n\n\n\n      由上两式，可得出如下递推关系：                       \n因此可以将代码写成：\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = v[i]; j &lt;= m; j++) //注意了，这里的j是从小到大枚举，和01背包不一样\n    {\n        f[j] = max(f[j], f[j - v[i]] + w[i]);\n    }\n\n\n\n题目推荐：\n\n多重背包例题：多重背包\n\n描述：与完全背包的区别就是每种物品有限制\n\n代码实现：\n\n朴素版本：\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = 0; j &lt;= m; j++)\n        for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)//s[i]表示每种物品最大数量\n            f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);\n\n优化思路：\n\n\n\n\n\n\n\n\n\n   可以分为二进制优化和单调队列优化，这里只做二进制优化解释\n   一个数字可以分成多个数字相加，而这个数字也可以表示为\n   举几个例子：\n\n\n\n\n\n\n   因此在输入的时候就可以将每个物品的数量用二进制的方式储存起来\n代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int cnt = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int a, b, s;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;//分别为体积、价值、数量\n        int k = 1;\n        while (k &lt;= s)\n        {\n            cnt++;\n            v[cnt] = a * k;//将每个二进制数量及其体积储存起来\n            w[cnt] = b * k;//将每个二进制数量及其价值储存起来\n            s -= k;\n            k *= 2;\n        }\n        if (s &gt; 0)//s分成2的cnt次幂后所剩下的数\n        {\n            cnt++;\n            v[cnt] = a * s;\n            w[cnt] = b * s;\n        }\n    }\n\n    n = cnt;\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= v[i]; j--)\n            f[j] = max(f[j], f[j - v[i]] + w[i]);//01背包做法\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n\n\n题目推荐：\n\n分组背包例题：分组背包\n\n描述： 每个组别只能取一种物品，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。\n\n思路：从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。\n\n代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; s[i];//第i组数量\n        for (int j = 0; j &lt; s[i]; j++)\n            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];//第i组第j个物品的体积和价值\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= 0; j--)\n            for (int k = 0; k &lt; s[i]; k++)//第i组的每一个进行遍历\n                if (j &gt;= v[i][k])\n                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);//与01背包一样\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n题目推荐：\n\n二维费用背包例题：P1855 榨取kkksc03\n\n描述：跟01背包问题相似，不同的是选一个物品会消耗两种东西\n\n思路：状态转移方程式基本不变，只需要再开一维数组存储\n\n代码实现：\nint main()\n{\n    int n, M, T;\n    cin &gt;&gt; n &gt;&gt; M &gt;&gt; T;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; m[i] &gt;&gt; t[i];\n        for (int j = M; j &gt;= m[i]; j--)\n            for (int k = T; k &gt;= t[i]; k--)\n                f[j][k] = max(f[j][k], f[j - m[i]][k - t[i]] + 1);//同时减少金钱和时间\n    }\n    cout &lt;&lt; f[M][T];\n    return 0;\n}\n\n题目推荐：\n\n四方定理\n\n\n有依赖的背包例题：P1064 [NOIP2006 提高组] 金明的预算方案\n\n描述：这种背包问题其实就是如果选第   件物品，就必须选第   件物品，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就称不依赖于别的物品的物品称为「主件」，依赖于某主件的物品称为「附件」。\n\n\n\n\n\n\n\n\n\n   对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。\n\n例题解析：\n\n像是01背包的升级版本，就是情况多了几种：\n不买主件\n买主件\n买主件和附件1\n买主件和附件2\n买主件和附件1+附件2\n\n\n状态转移方程式可以写成：\n买主件：\n买主件和附件1：\n买主件和附件2：\n买主件和附件1+附件2：\n\n\n\n\n代码：\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N = 2e5 + 10;\nint n, m, main_w[N], main_v[N], fu_v[N][3], fu_w[N][3], f[N];\n// n是总金钱,m是总物品,main_w主件物品的重量,main_v主件物品的价值,fu_w附件物品的重量，fu_v附件物品的价值\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int q, v, p;\n        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;\n        if (!q)\n        {\n            main_w[i] = v;\n            main_v[i] = v * p; //价值==价格*重要度\n        }\n        else\n        {\n            fu_w[q][0]++;\n            int k = fu_w[q][0];\n            fu_w[q][k] = v;\n            fu_v[q][k] = v * p;\n        }\n    }\n    for (int i = 1; i &lt;= m; i++)\n        for (int j = n; j &gt;= main_w[i]; j--)\n        {\n            f[j] = max(f[j], f[j - main_w[i]] + main_v[i]); //主件\n            if (j &gt;= fu_w[i][1] + main_w[i])//主件+附件1\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][1]] + main_v[i] + fu_v[i][1]);\n            if (j &gt;= fu_w[i][2] + main_w[i]) //主件+附件2\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][2]] + main_v[i] + fu_v[i][2]);\n            if (j &gt;= fu_w[i][1] + fu_w[i][2] + main_w[i]) //主件+附件1+附件2\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][1] - fu_w[i][2]] + main_v[i] + fu_v[i][1] + fu_v[i][2]);\n        }\n    cout &lt;&lt; f[n] &lt;&lt; endl;\n    return 0;\n}\n\n背包杂项\n小优化：\n\n\n\n\n\n\n\n\n\n   根据贪心原理，当费用相同时，只需保留价值最高的；当价值一定时，只需保留费用最低的；当有两件物品  且   的价值大于    的价值并且  的费用小于   的费用是，只需保留 。\n\n输出方案：\n\n\n\n\n\n\n\n\n\n用二维数组来记录，`path[m][n] `。其中$m$表示物品（$m\\leq$物品数），$n$表示背包状态（$n\\leq$背包容量）。\n\n   比如 path[i][j] 表示物品  放在了状态 的背包中。 前提条件：数组全部为0，\n//记录路径\nfor (int i = 0; i &lt; n; i++)\n    for (int j = V; j &gt;= v[i]; j--)\n        if (f[j] &lt; f[j - v[i]] + w[i])\n        {\n            f[j] = f[j - v[i]] + w[i];\n            path[i][j] = 1; //把装进去的物品标记一下\n        }\n//读取路径\nint i = n - 1, j = V; // V：背包容量。n个物品\nwhile (i &gt;= 0 &amp;&amp; j &gt;= 0)\n{\n    if (path[i][j]) //物品i在j里\n    {\n        printf(\"%d \", i); //把物品i的编号输出\n        j -= v[i];        //读完了物品i，找下一个背包状态\n    }\n    i--;\n}\n\n\n\n求方案数量：\n\n\n\n\n\n\n\n\n\n对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。\n\n   这种问题就是把求最大值换成求和即可。\n   初始条件： （容量为0也算一个方案，即什么都不装）\n\n求最优方案总数：将01背包里面的数组定义修改，状态为只能放前  个物品的情况下，容量为  的背包“正好装满”所能达到的最大总价值。\n这样修改后每种状态都可以用一个来表示方案总数\n表示只考虑前个物品时背包体积正好是时的最大价值。\n表示只考虑前个物品时背包体积正好是时的方案数。\n\n\n\n\n\n\n\n\n\n   转移方程：\n\n如果且说明我们此时不选择把物品放入背包更优，方案数由 转移过来。\n如果且说明我们此时不选择把物品放入背包更优，方案数由 转移过来。\n如果且说明放入或者不放入都能取得最优解，方案数由 转移过来。\n\n//初始条件\nmemset(f, 0x3f3f, sizeof(f));  // 避免没有装满而进行了转移\nf[0] = 0;\ng[0] = 1;  // 什么都不装是一种方案\n//////////////////////////////////////\nfor (int i = 0; i &lt; N; i++)\n{\n    for (int j = V; j &gt;= v[i]; j--)\n    {\n        int tmp = max(dp[j], dp[j - v[i]] + w[i]);\n        int c = 0;\n        if (tmp == dp[j])\n            c += cnt[j]; // 如果从dp[j]转移\n        if (tmp == dp[j - v[i]] + w[i])\n            c += cnt[j - v[i]]; // 如果从dp[j-v[i]]转移\n        dp[j] = tmp;\n        cnt[j] = c;\n    }\n}\nint max = 0; // 寻找最优解\nfor (int i = 0; i &lt;= V; i++)\n{\n    max = max(max, dp[i]);\n}\nint res = 0;\nfor (int i = 0; i &lt;= V; i++)\n{\n    if (dp[i] == max)\n    {\n        res += cnt[i]; // 求和最优解方案数\n    }\n}\n\n","slug":"背包问题","date":"2022-02-13T12:09:32.829Z","categories_index":"动态规划","tags_index":"动态规划,背包","author_index":"Snailuu"},{"id":"f83333b56248d745b141d3885b656c81","title":"最小生成树","content":"假设表示图中点数，表示图中边数\n朴素版Prim算法（适用于稠密图，复杂度O())思路：将条边到另一条边的距离初始化成从遍历到找到集合外距离最小的点标记为，用来更新它到集合的距离，标记一下\n例题：Prim算法求最小生成树\n核心代码：\n// st[i] 表示点i是否在当前生成树集合中\n// dist[i] 表示点i到当前集合的最短边的长度\n// g[i][j] 表示点i和点j之间边的长度\n// 返回值：最小生成树中所有边的总长度\nint prim()\n{\n    memset(dist, 0x3f, sizeof(dist));\n    int res = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) //第一次找到或者找到更小的\n                t = j;\n        if (i &amp;&amp; dist[t] == INF)\n            return INF; //无法生成最小树\n        if (i)\n            res += dist[t];\n        st[t] = 1;\n        for (int j = 1; j &lt;= n; j++) //更新t所有连接点\n            dist[j] = min(dist[j], g[t][j]);\n    }\n    return res;\n}\n\n\n\nKruskal算法（适用于稀疏图，复杂度O())思路：将所有边权按小到大排序，从小到大挑不多余的边\n代码实现：\nstruct Edge\n{ //用结构体储存点a到b的边权w\n    int a, b, w;\n    bool operator&lt;(const Edge &amp;W) const\n    {\n        return w &lt; W.w;\n    }\n} edge[M];\nint find(int x)\n{\n    if (p[x] != x)\n        p[x] = find(p[x]);\n    return p[x];\n}\nint kruskal()\n{\n    sort(edge, edge + m);\n    for (int i = 1; i &lt;= n; i++)\n        p[i] = i; //初始化并查集\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i++)\n    {\n        int a = edge[i].a, b = edge[i].b, w = edge[i].w;\n        a = find(a), b = find(b);\n        if (a != b) //如果两个联通块不连通，将这两个联通块合并\n        {\n            p[a] = b;\n            res += w; //最小生成树的边权和\n            cnt++;    //加入点的数量\n        }\n    }\n    if (cnt &lt; n - 1)\n        return INF;\n    return res;\n}\n\n","slug":"最小生成树","date":"2022-02-13T07:22:11.269Z","categories_index":"图论","tags_index":"图论,生成树","author_index":"Snailuu"},{"id":"aa03b2f0abb625816c3d81ed8f81147b","title":"图论最短路问题","content":"朴素版Dijkstra算法(适用于稠密图)思路\n初始化距离数组和邻接矩阵（无穷大）\n处理重边问题在输入取最小值\n每次找到一个最小的未更新的答案点\n将其连边答案全部更新\n\n例题：Dijkstra算法朴素版\n代码实现如下：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 520, INF = 0x3f3f3f3f;\nint n, m;\nint g[N][N], dis[N];\nbool st[N];\n\nint dijkstra()\n{\n    dis[1] = 0; //每个点到一号点的最短距离\n    //如需求到s点的一开始将dis[s]定义为0即可\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (!st[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))\n                t = j; //找到当前未更新的最小点\n        }\n        for (int j = 1; j &lt;= n; j++)\n            dis[j] = min(dis[j], dis[t] + g[t][j]); //将t连接的点都更新最短距离\n        st[t] = true;\n    }\n    if (dis[n] == 0x3f3f3f3f)\n        return -1; // 1~n之间不连通，无法构成路径，也就没有最短距离\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(g[0], g[0] + N * N, INF);\n    fill(dis, dis + N, INF);\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        g[x][y] = min(g[x][y], c); //处理重边\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n\n堆优化版Dijkstra算法(适用于稀疏图)优点： \n\n堆可以动态维护一个集合中的最小值\n堆动态支持插入，删除，修改一个数\n\n优化部分：\nfor(int j=1;j&lt;=n;j++)\n{\n    if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n}\n//每次寻找一个最小值可以用堆来维护一个最小值\n//复杂度从O(n)-&gt;O(1)\n////////////////////////////////////////////\nfor(int j=1;j&lt;=n;j++)\n    dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n//每次将点更新在堆中修改复杂度为mlogm\n//复杂度从O(n)-&gt;O(mlogm)\n//////////////////////////////////////////////\n//总体复杂度从O(n^2)-&gt;O(mlogm)\n\n例题：Dijkstra算法堆优化版\n代码实现：\n#include &lt;bits/stdc++.h&gt;\n#define PII pair&lt;int, int&gt;\nusing namespace std;\n\nconst int N = 1e6 + 10, INF = 0x3f3f3f3f;\nint n, m;\nint h[N], e[N], ne[N], idx;\nint dis[N], w[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint dijkstra()\n{\n    fill(dis, dis + N, INF);\n    dis[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; //优先队列默认大根堆，这样子写可以维护小根堆,pair&lt;int,int&gt;第一个值存数值，第二个值存下标\n    heap.push({0, 1});\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver])\n            continue; //每次处理均为最小值且未处理过的\n        st[ver] = true;\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dis[j] &gt; dis[ver] + w[i]) //有更短路就替换\n            {\n                dis[j] = dis[ver] + w[i];\n                heap.push({dis[j], j}); //将新的方案加入到队列中\n            }\n        }\n    }\n    //队列为空即走完整个图\n    if (dis[n] == INF)\n        return -1;\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(h, h + N, -1); //将头结点数组全部初始化成-1\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        add(x, y, c);\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n\n\nSPFA算法（适用于稀疏图）Bellman-Ford太呆\n优点：\n\n每次只更新与结点有关点的最小距离\n\n例题：SPFA求最短路\n代码实现：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[N], ne[N], w[N], idx; //稀疏图用邻接表来存图\nint n, m;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint spfa()\n{\n    fill(dist, dist + N, INF); //先将每个到源点的距离初始化成正无穷\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        int t = q.front();\n        q.pop();\n        st[t] = false; //出队了\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) //更新t结点的所有距离\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])\n                {\n                    q.push(j); //更新的点第一次访问就进度，后面可能还能再利用其更新其他点\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    while (m--)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if (t == INF) //如果到n点还无法更新距离说明无法连通\n        puts(\"impossible\");\n    else\n        cout &lt;&lt; t &lt;&lt; endl;\n    return 0;\n}\n\n\n","slug":"图论最短路","date":"2022-02-13T07:19:11.220Z","categories_index":"图论","tags_index":"最短路,稠密图,稀疏图","author_index":"Snailuu"},{"id":"01d132f13ac67dff21350f57c338a855","title":"拓扑排序","content":"拓扑排序应用场景在做某些事的时候他们之间有前后关系（顺序关系或者依赖关系），比如安排座位，穿衣服先后，课程学习等等。\n拓扑排序只对于有向无环图而言(Directed Acyclic Graph简称DAG)\n\n\n\n\n\n\n\n\n\n   如果有a,b,c,d等件事情，a的优先级最高，d的优先级最低，那么abcd或者acbd都是可行的排序。\n基于BFS的拓扑排序\n无前驱的顶点优先\n\n将入度为零的点入队\n\n访问对头所有的邻接点，并将其入度减，如果此时的入度为就将其入队\n\n当队列为空时，如果还有点从未进入队列中，说明这个图不是DAG，不存在拓扑排序。\n反之如果全部进过队列了，队列依次输出的就是拓扑排序。\n\n\n\n\n部分代码：\nvoid topsort()\n{\n    for (int i = 1; i &lt;= n; i++)\n        if (!in[i])\n            num[i] = 1, q.push(i);\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i]; //枚举当前队头的所有邻接点\n            in[j]--;      //减少入度\n            if (!in[j])\n                q.push(j); //如果入度为0就入队\n        }\n    }\n}\n\n\n\n无后继的顶点优先\n就是无前去顶点优先的逆过程，将入度为改成出度为的点入队，后面情况跟前面的一样，最后队列输出的是拓扑排序的逆序。\n\n\n\n注意：如果有要求要字典序输出，将队列弄成一个优先队列，依据题意建大根堆或者小根堆。\n","slug":"拓扑排序","date":"2022-02-13T07:19:11.215Z","categories_index":"图论","tags_index":"图论,排序","author_index":"Snailuu"},{"id":"60a84708f3c49aa5488e16601f40a652","title":"算法选择","content":"数据范围推断算法选择\n\n\n数据范围\n时间复杂度\n算法\n\n\n\n\n指数级别\ndfs+剪枝，状态压缩dp\n\n\n\n\nfloyd，dp，高斯消元\n\n\n\n，\ndp，二分，朴素版Dijkstra，朴素版Prim，Bellman-Ford\n\n\n\n\n块状链表，分块，莫队\n\n\n\n\n各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，kruskal，spfa，求凸包，求平面交，二分，CDQ分治，整体二分，后缀数组，树链部分，动态树\n\n\n\n及常数较小的的算法\n单调队列，hash，双指针扫描，并查集，kmp，AC自动机，sort，树状数组，heap，dijkstra，spfa\n\n\n\n\n双指针扫描，kmp，AC自动机，线性筛素数\n\n\n\n\n判断质数\n\n\n\n\n最大公约数，快速幂，数位DP\n\n\n\n\n高精度加减乘除\n\n\n\n，k表示位数\n高精度加减，FFT/NTT\n\n\n\n图论中算法选择\n\n\n\n\n\n\n\n\n   一个图中，顶点数记为n，边数记为m\n   当m时，称之为稀疏图\n   当m相对比较大时，称之为稠密图\n\n\n\n","slug":"算法选择","date":"2022-02-13T07:09:10.466Z","categories_index":"数据范围","tags_index":"算法选择","author_index":"Snailuu"}]