[{"id":"3c194b2f2319e046c85e1bc082983d3c","title":"模板","content":"本篇文章作为跳转文章，如需阅读模板请点击下方各类按钮基础算法数据结构搜索与图论数学算法选择","slug":"模板","date":"2022-02-16T08:35:59.408Z","categories_index":"模板","tags_index":"","author_index":"Snailuu"},{"id":"40516069856649c61c80ebcc0b14851f","title":"杂乱笔记","content":"字符串\nstring类的插入insert(pos,string) 在下标pos和pos+1之间插入字符串string。\nstring类的删除earse(pos,num)从下标pos开始删除num个字符，如果num为空则删除pos后面的所有字符。\n\n数学\n\n\n取模的顺序：一定要优先对可能结果偏大的部分先取模，如果对小的数先取模，小的再去乘以一共大的可能就会溢出，再取模就是错的，所以要先对大的取模使其变小\n\n\n\n动态规划\n求每次只能选a或者选b ，问 n次操作后能不能到达 x点的直接用二进制（bitset） 存储每次操作的次数，最后询问  是否是 1即可\n\n贪心问题均分纸牌问题\n\n\n\n\n\n\n\n\n   要求答案每一堆数量相同，求至少需要几次操作？（每次操作-每一堆只能给左右两边，第一项和最后一项只能给右边和左边）\n   解法：遍历数组，将每个数值与平均值做差，差值加个下一个数，操作数加一，当某一个数刚好是平均数就跳过不进行做差。\n2022.2.27\n\n\n\n\n\n\n\n\n   迭代器指向前驱prev(it)，指向后继 next(it)\n\n\n\n\n\n\n\n\n\n\n   变量范围\n\n\n\n类型名\n位宽\n表示范围\n\n\n\nshort int\n16\n～\n\n\nunsigned short int\n16\n～\n\n\nint\n32\n～\n\n\nunsigned int\n32\n～\n\n\nlong int\n32\n～\n\n\nunsigned long int\n32\n～\n\n\nlong long int \n64\n～\n\n\nunsigned long long int\n64\n～\n\n\n\n\n\n\n\n\n\n\n\n\n   假设坐标上任意点（x，y）绕着点 （，） 旋转  度 ，设旋转后的坐标为（，），则\n   \n\n\n\n\n\n\n\n\n\n\n   全局变量声明迭代器，要在开头写上using list&lt;int&gt;::iterator\n   using iter=list&lt;int&gt;::iterator;\nconst int N=1e5+10;\niter pos[N];\n\n2022.2.28\n\n\n\n\n\n\n\n\n   斐波那契数列通项公式：\n2022.3.1\n\n\n\n\n\n\n\n\n   遇到组合数询问次数过多时可利用杨辉三角+二维前缀和进行优化，将每次查询的时间复杂度从  降低到了  \n   例题：组合数问题\n\n\n\n\n\n\n\n\n\n\n   需要二进制判断某一位可以结合函数一起进行运算\n   例题:并查集\n   在本题如果将结果用字符串储存最后在进行转换会导致结果太大引发RE错误，在处理的时候res=((res&lt;&lt;1)|query(a,b))%mod;一起，前面的数&lt;&lt;1末尾会多出0，然后后面函数判断返回1或者0可以用|运算达到目的\n2022.3.6\n\n\n\n\n\n\n\n\n   液体的浓度可以有下面多种表达形式：\n\n质量分数（%）溶质的质量除以溶液的质量(溶剂质量+溶质质量)\n摩尔分数（%）溶质的摩尔数除以溶液的摩尔数(溶剂摩尔数+溶质摩尔数)\n物质的量浓度（mol/L）溶质的摩尔数除以溶液的体积\n质量摩尔浓度（mol/kg）溶质的摩尔数除以溶液的质量\n\n2022.3.8\n\n\n\n\n\n\n\n\n   string  类用scanf(\"%s\",&amp;a[0])读取和printf(\"%s\", a.c_str()); 输出。\n   在读取前要先分配空间大小，如果想从下标1开始保存要先填充a[0]位\n2020.3.9\n\n\n\n\n\n\n\n\n   结构体重载运算符 记得在函数括号后面再加const\n   bool operator&lt;(const node B)const {\n\t\treturn l&lt;B.l;\n\t}\n\n   排序顺序如果有多关键字，按照顺序为第一、第二关键词等排序\n2022.3.10\n\n\n\n\n\n\n\n\n   全局变量声明变量后局部不要再次声明，否则全局调用时变量为0\n\n   memcpy(a,b,sizeof a) ，将b的数据拷贝给a\n2022.3.11\n\n\n\n\n\n\n\n\n   string 读取一整行字符串（有空格）的时候使用getline(cin,a)，在使用之前记得用cin.ignore()清除换行符\n2022.3.16\n\n\n\n\n\n\n\n\n   求  的前  位：\n   设 \n   \n   即  ：整数 + 小数\n   确定小数点的位置\n   确定具体的数字\n   前  位：\ndouble res=k*log10(n)-(int)(k*log10(n));//求出小数部分\n   int ans=pow(10,res)*100;//10^x * N 就是前N位\n\n\n\n2022.3.18\n\n\n\n\n\n\n\n\n   map二分查找返回的是一个迭代器\nmap&lt;int,int&gt;q;\nint k;//要查找的数字\nauto res=q.upper_bound(k);//找到第一个大于等于k的数的迭代器\nauto res=q.lower_bound(k);//找到第一个大于k的数的迭代器\ncout&lt;&lt;res-&gt;first&gt;&gt;res-&gt;second&gt;&gt;endl;\n//输出key和v\n\n\n\n2022.3.28\n\n\n\n\n\n\n\n\n   均值不等式，对于非负实数a、b有\n   \n   \n   \n   \n   \n   \n   \n2022.3.30\n\n\n\n\n\n\n\n\n   用不了next和prev前提下，可以重新开一个新的迭代器数组，指向STL容器的每一个元素的地址\n   例题：自行车停放\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;list&gt;\n#define ll long long \nusing namespace std;\nconst int N=1e5+10;\nlist&lt;int&gt;::iterator loc[N];\nll n,x,a,b,c;\nvoid print(list&lt;int&gt;L){\n\tlist&lt;int&gt;::iterator it=L.begin();\n\tfor(it;it!=L.end();it++){\n\t\tcout&lt;&lt;*it&lt;&lt;\" \";\n\t}\n} \nint main(){\n\tll i;\n\tlist&lt;int&gt;L;\n\tscanf(\"%lld%lld\",&amp;n,&amp;x);\n\tL.push_back(x);\n\tloc[x]=L.begin();\n\tlist&lt;int&gt;::iterator temp;//临时迭代器 \n\tfor(int i=1;i&lt;n;i++){\n\t\tscanf(\"%lld%lld%lld\",&amp;a,&amp;b,&amp;c);\n\t\ttemp=loc[b];\n\t\tif(!c){\n\t\t\tL.insert(temp,a);\n\t\t\tloc[a]=--temp;\n\t\t}\n\t\telse{\n\t\t\tL.insert(++temp,a);\n\t\t\tloc[a]=--temp;\n\t\t}\n\t}\n\tprint(L);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n求一个数有几位数可以直接用log10[n]+1\n2022.4.18给定一个数组，每次操作可以将第一个数放到最后一个，求多次操作后的最小逆序对\n\n\n\n\n\n\n\n\n\n   对于第 i 个数a[i]，比它小的数一共有a[i]-1个，如果进行一次操作的话，会减少逆序对数量a[i]-1个，对于后面比它大的数一共有n-1-(a[i]-1)个，这是操作后会增加的数量，两者相加起来可以得到每次操作逆序对数量的变化n-2*a[i]+1个\n2022.4.29\n\n\n\n\n\n\n\n\n   负数取模=（负数+mod）% mod\n","slug":"杂点笔记","date":"2022-02-16T04:06:58.194Z","categories_index":"笔记","tags_index":"动态规划,数学,字符串","author_index":"Snailuu"},{"id":"ef2958a60eebffed61302cfeed7e9fed","title":"错误之路","content":"本篇文章用于记录学习之路/比赛上看似不起眼的小错误却又不得不重视的，一直都在更新……单词专区\n\n\n\n\n\n\n\n\n   the maximal possible product of elements ：最大可能乘积的元素，product 乘积\n   positive integer：正整数\n   non-X ：非X的数，Nonnegative \n   letter ：字母，单个字符\n\n2022.02.15 res=pow(a,b) 当res为int类型时，b应该为常量。当res为double类型时，b应该为常量、int、double。\n\n2022.02.19 \n\n\n\n\n\n\n\n\n\n   在遇到开根之类的，尽量弄成整数，比如 弄成5，等号另一边也开平方可减少精度误差。\n   遇到除法取模的要用到逆元，别直接除后取模。\n   由费马小定理可得：\n   可由快速幂求解\n\n2022.2.26 不要对临时变量加引用\n\n2022.2.28 在数据范围超1e9 时， 记得加上long long \n\n2022.3.1 \n\n用string作为变量的时候，检查是否出现过，用if(string==\"\")空字符判断\n数据过大时读入关闭cin同步流或者使用scanf\n\n\n2022.3.2  \n\n大数组赋值别用={}，会使编译产生的文件过大。\n比如：ll f[3000005]={1} 相当于 ll f[3000005]={1,0,0,0,0,0,0...0,0}（有 3000004 个 0），会导致生成的可执行文件过大，CE。\n\n\n\n2022.3.3 用到fill给pari&lt;int,int&gt; 二维数组，比如 pair&lt;int,int&gt;g[N][N] 赋值时第三个参数应该为 pair&lt;int,int&gt;\n即fill(g[0],g[0]+N*N,pair&lt;int,int&gt;(-1,-1));\n\n2022.3.5\n\n\n\n\n\n\n\n\n\n   \n   \n\n   string类型要加上多个字符得分开加，不能一次性 string += char + char +...  \n\n   stoi(string,0,num) 将string字符里num进制的数转位10进制\n\n   判断一个n*m的图中是否有圈，用bfs或者dfs即可，dfs只要多加两个起始坐标，后面遍历的时候每次将新的起始坐标更新成当前dfs的起始坐标看看会不会穿过即可\n   void dfs(int next_x,int next_y,int prev_x,int prev_y)\n{\n    for(int i=0;i&lt;4;i++)\n    {\n        int a=next_x+dx[i],b=next_y+dy[i];\n        if(!check(a,b)||g[a][b]!=g[next_x][next_y]||a==prev_x&amp;&amp;b==prev_y)continue;\n        if(st[a][b]){flag=1;break;}//找到环标记并结束搜索\n        st[a][b]=1;dfs(a,b,next_x,next_y);\n    }\n    return;\n}\n\n\n2020.3.6\n\n\n\n\n\n\n\n\n\n   在dp选择状态表示中，如果需要做选择可以用0、1、2、3... 等等这样子表示。\n   例题：Basketball Exercise\n   每个序号的球员需要交叉选择，要求最大值，f[i][j]表示到第i号的分数所能达到的最大值，j可以表示为0、1、2，即表示不选任何一个队员，选择上面的队员，选择下面的队员\n   \n   \n   \n\n   string 类型用scanf 读取方式：scanf(\"%s\",&amp;a[0])，记得提前分配空间a.resize(n)\n\n2022.3.13\n\n\n\n\n\n\n\n\n\n   在初始中中不要用fill或者memset，直接用for循环\n\n\n","slug":"错误之路","date":"2022-02-16T02:58:30.254Z","categories_index":"","tags_index":"","author_index":"Snailuu"},{"id":"3d2ad0d2112e464d53940572a4997b4d","title":"树上问题","content":"树链剖分\n\n\n\n\n\n\n\n\n   处理问题：\n\n将树从x到y结点最短路径上所有节点的值都加上z\n求树从x到y结点最短路径上所有节点的值之和\n将以x为根节点的子树内所有节点值都加上z\n求以x为根节点的子树内所有节点值之和\n\ndfs1()\n处理每个节点的深度、父亲节点\n标记每个非叶子节点的子树大小、重儿子编号\n\nvoid dfs11(int u,int fa,int depth){\n    dep[u]=depth;//深度\n    fa[u]=fa;//父亲节点\n    siz[u]=1;//子树大小\n    int maxson=-1;\n    for(int i=h[u];i!=-1;i=ne[i]){\n\t\tint v=e[i];\n    \tif(v==fa)continue;\n        dfs(y,x,depth+1);\n        siz[u]+=siz[v];\n        if(siz[v]&gt;maxson) son[u]=y,maxson=siz[v];//重儿子编号\n    }\n}\n\ndfs2()\n处理每条链的每个点所在链的顶端\n标记每个点的dfs序，将初始值赋值到树上每个节点（按照dfs序）\n\nvoid dfs2(int x,int topf){//x表示当前节点,topu表示当前链最顶端的节点\n    id[x]=++cnt;//dfs序\n    wt[cnt]=w[x];//赋值\n    top[x]=topu;//当前链顶端的节点\n    if(!son[x]) return;\n    dfs2(son[x],topf);//先处理重儿子再处理轻儿子\n    for(int i=h[x];i!=-1;i=ne[i]){\n        int y=e[i];\n        if(y==fa||y==son[x])continue;\n        dfs(y,y);//每个轻儿子都有一条从他自己开始的链\n    }\n}\n\n询问任意两点间路径节点和\n加上  到  所在链顶端这一段区间的点权和\n将  跳到  所在链顶端的那个点的上面一个点\n不断执行上面两个操作，直到两个点处于同一条链，最后  再加上这两个点的区间点权和\n\nint qRange(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){//询问两点不在同一个条链\n        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);//将x改成所在链顶端的深度更深的点\n        res=0;\n        query(1,1,n,id[top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和\n        ans+=res;\n        x=fa[top[x]];//把x跳到x所在链顶端的那个点的上面一个点\n    }\n    //直到两个点处于一条链上\n    if(dep[x]&gt;dep[y]) swap(x,y);//把x点深度更深的那个点\n    res=0;\n    query(1,1,n,id[x],id[y]);\n    ans+=res;\n    return ans;\n}\n\n询问一点及其子树的点权和\n直接利用线段树区间查询即可\n\nint qSon(int x){\n    res=0;\n    query(1,1,n,id[x],id[x]+siz[x]-1);//子树区间右端点为id[x]+siz[x]-1 \n    return res;\n}\n\n修改一点以及子树节点的点权void updRange(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);\n        update(1,1,n,id[top[x]],id[x],k);\n        x=fa[top[x]];\n    }\n    if(dep[x]&gt;dep[y]) swap(x,y);\n    update(1,1,n,id[x],id[y],k);\n}\nvoid updSon(int x,int k){\n    update(1,1,n,id[x],id[x]+siz[x]-1,k);\n}\n\n\n\n树的直径两次DFS\n\n\n\n\n\n\n\n\n   不足：无法处理负权边\ncode: \nconst int N=1e5+10;\nint n,c,d[N];\nvector&lt;int&gt;E[N];\nvoid dfs(int u,int fa){\n    for(auto v:E[u]){\n        if(v==fa)continue;\n        d[v]=d[u]+1;\n        if(d[v]&gt;d[c]) c=v;\n        dfs(v,u);\n    }\n}\nint main(){\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;i++){\n        int u,v;\n        cin&gt;&gt;u&gt;&gt;v;\n        E[u].push_back(v),E[v].push_back(u);\n    }\n    dfs(1,0);\n    d[c]=0,dfs(c,0);\n    cout&lt;&lt;d[c]&lt;&lt;endl;\n    return 0;\n}\n\n树形DPcode:\nconst int N=1e5+10;\nint n,d=0;\nint d1[N],d2[N];\nvector&lt;int&gt;E[N];\n\nvoid dfs(int u,int fa){\n\td1[u]=d2[u]=0;\n\tfor(auto v:E[u]){\n\t\tif(v==fa)continue;\n\t\tdfs(v,u);\n\t\tint t=d1[v]+1;\n\t\tif(t&gt;d1[u])d2[u]=d1[u],d1[u]=t;\n\t\telse if(t&gt;d2[u])d2[u]=t;\n\t}\n\td=max(d,d1[u]+d2[u]);\n}\n\nint main(){\n\tcin&gt;&gt;n;\n\tfor(int i=1;i&lt;=n;i++){\n\t\tint u,v;\n\t\tcin&gt;&gt;u&gt;&gt;v;\n\t\tE[u].push_back(v),E[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tcout&lt;&lt;d&lt;&lt;endl;\n\treturn 0;\n}\n\nLCA问题树上倍增法求解复杂度：\nf[i][j]表示第 i 个节点的的祖宗节点\n\n初始化深度数组和距离数组\n\nvoid dfs(int u){\n    for(int i=h[u];~i;i=ne[i]){//求深度、距离还有节点的祖先\n        int j=e[i];\n        if(j==f[u][0])continue;\n        deep[j]=deep[u]+1;\n        dis[j]=dis[u]+w[i];\n        f[j][0]=u;\n        dfs(j);\n    }\n}\n\n\n创建st表\n\nvoid st_create(){\n    for(int j=1;j&lt;=k;j++)\n        for(int i=1;i&lt;=n;i++)\n            f[i][j]=f[f[i][j-1]][j-1];\n\n\n\n\n询问LCA\n\nint query_lca(int x,int y){\n    if(deep[x]&gt;deep[y])swap(x,y);//保证x的深度小于等于y\n    for(int i=k;i&gt;=0;i--){\n        if(deep[f[y][i]]&gt;=deep[x]) y=f[y][i];\n        //深度大的点一直跳到两个点深度一样\n    }\n    if(x==y)return x;\n    for(int i=k;i&gt;=0;i--){\n        if(deep[f[x][i]]!=deep[f[y][i]]){//找不到公共祖先一直跳\n            x=f[x][i];\n            y=f[y][i];\n        }\n    }\n    return f[x][0];//此时x==y,f[x][0]=f[y][0]就是他俩的最近公共祖先\n}\n\n\n\nTarjan+并查集（离线做法）复杂度：\n\n初始化\nvoid init(){\n    memset(h,-1,sizeof h);\n    idx=1;\n    memset(hq,-1,sizeof hq);\n    idxq=1;\n    for(int i=1;i&lt;=n;i++)p[i]=i;//并查集初始化\n    memset(vis,0,sizeof vis);\n}\n\n添加、查找操作\nint find(int x){//并查集找祖先\n    if(p[x]!=x)p[x]=find(p[x]);\n    return p[x];\n}\n\nvoid add(int a,int b){//构图\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\n\nvoid addq(int a,int b,int idd){//x数组\n  eq[idxq]=b,neq[idxq]=hq[a],id[idxq]=idd,hq[a]=idxq++;\n}\n\n\n\n存储每一个节点的祖宗\n\n处理每个节点的距离数组时处理询问数组\n\n\nvoid tarjan(int u){\n    vis[u]=1;\n    for(int i=h[u];~i;i=ne[i]){\n        int j=e[i];\n        if(vis[j])continue;\n        vis[j]=1;\n        tarjan(j);\n        p[find(j)]=find(u);//修改每一个节点的祖宗节点\n    }\n    for(int i=hq[u];~i;i=neq[i]){//离线询问数组\n        int j=eq[i];\n        int idd=id[i];\n        if(vis[j]){//当前子节点是否枚举到\n            ans[idd]=find(j);\n        }\n    }\n}\n\n\n\n","slug":"树上问题","date":"2022-07-20T06:52:22.654Z","categories_index":"图论","tags_index":"树","author_index":"Snailuu"},{"id":"11addbaa11d477ab26222b42c31cac0c","title":"网络流","content":"最大流Dinic算法残量网络： 网络中所有节点以及剩余容量大于0的边构成的子图\n分层图： 将图分层，节点深度  表示    到  最少需要经过的边数，在残量网络中，满足  的边  构成的子图，是一张有向无环图\n求解方式,复杂度\n\n不断重复以下步骤，直到残量网络中  不能到达 \n在残量网络上 BFS 求出节点层次，构造分层图。\n在分层图上 DFS 寻找增广路，在回溯时实时更新剩余容量。另外，每个点可以流向多条出边，同时还加入若干剪枝及优化。\n\n**注意:**使用邻接表时下标从2开始\n例题：P3376 【模板】网络最大流\ncode:\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#define ll long long \nusing namespace std;\n\nconst int N=1e6+10;\nll h[N],ne[N],e[N],idx;\nll w[N];\nint n,m,st,ed,l,r;\nint dep[N],q[N];\n\nvoid add(ll a,ll b,ll c){\n    e[idx]=b,ne[idx]=h[a],w[idx]=c,h[a]=idx++;\n}\nbool bfs(){\n    memset(dep,0,sizeof dep);\n    q[l=r=1]=st;\n    dep[st]=1;\n    while(l&lt;=r){\n        ll u=q[l++];\n        for(int i=h[u];i!=-1;i=ne[i]){\n            ll v=e[i];\n            if(w[i] &amp;&amp; !dep[v]){\n                dep[v]=dep[u]+1;\n                q[++r]=v;\n            }\n        }\n    }\n    return dep[ed];//如果终点没有被赋值-&gt;到达不了终点\n}\nll dfs(int u,ll in){\n    if(u==ed) return in;\n    ll out=0;\n    for(int i=h[u];i!=-1&amp;&amp;in;i=ne[i]){\n        ll v=e[i];\n        if(w[i] &amp;&amp; dep[v]==dep[u]+1){//每次只将流量流向下一层\n            ll res=dfs(v,min(w[i],in));//取一个路径上的最小流量\n            w[i]-=res;//当前边的容量减少\n            w[i^1]+=res;//方向边的容量增加\n            in-=res;//流入减少\n            out+=res;//输出增加\n        }\n    }\n    if(out==0) dep[u]=0;\n    return out;\n}\nint main(){ \n    while(cin&gt;&gt;n&gt;&gt;m)\n    {\n        st=1,ed=m;\n        memset(h,-1,sizeof h);\n        idx=0;\n        for(int i=1;i&lt;=n;i++){\n            ll x,y;\n            ll c;\n            cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;\n            add(x,y,c);\n            add(y,x,0);\n        }\n        ll ans=0;\n        while(bfs()){\n            ans+=(ll)dfs(st,1e18);\n        } \n        cout&lt;&lt;ans&lt;&lt;endl;\n    }\n    return 0;\n}\n\n","slug":"网络流","date":"2022-07-13T03:08:06.940Z","categories_index":"图论","tags_index":"最短路,图论,网络流,最大匹配","author_index":"Snailuu"},{"id":"b906dec7c019d106b02095edae4e608a","title":"三元环","content":"参考链接：三元环\n三元环定义\n\n\n\n\n\n\n\n\n   给定一张无重边、无自环的无向图\n   点数为，边数为，且同阶\n   问有多少个无序三元组，使得存在：\n\n有一条连接的边\n有一条连接的边\n有一条连接的边\n\n\n这张图中有三个三元环：(1,2,3),(1,3,4),(3,4,5)(1,2,3),(1,3,4),(3,4,5)(1,2,3),(1,3,4),(3,4,5)\n三元环计数方法\n\n\n\n\n\n\n\n\n   首先要对所有的无向边进行定向，对于任何一条边，从度数大的点连向度数小的点，如果度数相同，从编号小的点连向编号大的点\n   此时这张图是一个有向无环图\n   之后枚举每一个点，然后将的所有相邻的点都标记上“被访问了”，然后再枚举的相邻的点，然后再枚举的相邻的点，如果存在“被访问了”的标记，那么就是一个三元环了\n   而且每个三元环只会被计算一次\n证明定向后的图是一个有向无环图\n\n\n\n\n\n\n\n\n\n   以上图为例，用 表示在原图中的度数，则\n   即\n   对于度数相同的点，是按照编号从小到达连边的，则\n   即\n   然而点的编号是的全排列，因此不会产生如上的事情，既不存在环\n   由于这张图有向，而且没有环，因此这张图就是有向无环图\n时间复杂度是（在此认为）同阶\n\n\n\n\n\n\n\n\n\n   对于“打标记“这个操作，每个点都会将所有的出边遍历一遍，那么这里的时间复杂度为\n   对于访问，然后访问，然后访问，可以这么考虑：对于每条边，对于时间复杂度的贡献为，其中表示的出边个数\n   这样就转换为了求\n   不妨将分类讨论\n\n ，那么由于连接，因此，这样的的个数是的，因此这里的时间复杂度为\n，那么由于连接，因此，即，这样的的个数是的，因此这里的时间复杂度为\n\n   因此时间复杂度为\n每个三元环只会被统计一次\n\n\n\n\n\n\n\n\n\n   三元环在有向无环图上无非就长这样\n   也只能且只会在处被计算一次\n代码实现#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 10;\nvector&lt;int&gt; g[N];\nint deg[N], vis[N], n, m, ans;\nstruct E { int u, v; } e[N * 3];\nint main() {\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    for(int i = 1 ; i &lt;= m ; ++ i) {\n        scanf(\"%d%d\", &amp;e[i].u, &amp;e[i].v);\n        ++ deg[e[i].u], ++ deg[e[i].v];\n    }\n    for(int i = 1 ; i &lt;= m ; ++ i) {\n        int u = e[i].u, v = e[i].v;\n        if(deg[u] &lt; deg[v] || (deg[u] == deg[v] &amp;&amp; u &gt; v)) swap(u, v);\n        g[u].push_back(v);\n    }\n    for(int x = 1 ; x &lt;= n ; ++ x) {\n        for(auto y: g[x]) vis[y] = x;\n        for(auto y: g[x])\n            for(auto z: g[y])\n                if(vis[z] == x)\n                    ++ ans;\n    }\n    printf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n\n","slug":"三元环","date":"2022-05-11T00:56:59.379Z","categories_index":"图论","tags_index":"图论","author_index":"Snailuu"},{"id":"7a095ced649d33399ff48645a890fd32","title":"数学定理","content":"求两个数的没法组合生成的最小整数\n\n\n\n\n\n\n\n\n   给定两个数a和b，求无法由a和b运算得到的最小整数\n   设c为所求最小整数\n   则\n","slug":"数学定理","date":"2022-03-31T08:29:20.723Z","categories_index":"数学","tags_index":"数学","author_index":"Snailuu"},{"id":"f6af5bf3fb5f66f52237908153c03aea","title":"动态规划","content":"树形DP\n\n\n\n\n\n\n\n\n   一般树形dp都是用于树上问题，父亲与儿子的问题，找出动态转移方程式，用树的遍历对其进行赋值\n\n\n\n\n\n\n\n\n\n\n   一般存图可以用链表，邻接矩阵，链式前向星等等，可以用数组模拟或者vector模拟；\n例题：\n选择节点类生活在树上\n\n\n\n\n\n\n\n\n\n   题目描述：\n   ZHR 住在一有根棵树上（1 号节点为根），树上的每条边都有一个距离。由于他特别懒，所以他一天移动的距离不能超过 2，对于每个节点，问他在一天中可以通过这个节点到达多少个不同的节点。\n思路：\n一个节点距离不超过2的点可以由父节点走过来（边权为1），或者由父亲节点距离为1的其他节点走过来\n定义为以节点u为根的距离为1/2的节点数量\n先标记每个点距离为1/2的点的数量\n\n如果本身与父亲节点距离为1，那么，并且还可以通过父亲节点距离为1的节点走过来，距离为2 ， 即 \n如果本身与父亲节点距离为2，那么就只能通过父亲节点走过来，即\n\n深搜每个节点最大到达点的数量\n\n这里用到三个参数void dfs(int u,int fa1,int fa2)，u为根节点，fa1为从父亲节点走过来距离为1的点的数量，fa2为从父亲节点走过来距离为2的点的数量\n如果下一个节点与父亲节点距离为1 dfs(next,1,fa1+dp[u][1]-1)，这里第三个参数表示距离为2可以由父亲节点距离为1的点和从父亲节点走过来距离为1的点数（这里包含了自己，要 -1）\n如果下一个节点与父亲节点距离为2 dfs(next,0,0)\n\ncode：\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;vector&gt;\n#include&lt;cstdio&gt;\n#define ll long long \n#define PII pair&lt;ll,ll&gt;\n\nusing namespace std;\n\nconst ll N = 1e6 + 10;\nvector&lt;PII&gt;q[N];\nll ans[N];\nll dp[N][3];\nint n;\n\nvoid dfs1(ll u) {\n    for (auto &amp;it:q[u]) {\n        ll next = it.first, w = it.second;\n        dfs1(next);\n        if (w == 1)dp[u][1]++, dp[u][2] += dp[next][1];\n        if (w == 2)dp[u][2]++;\n    }\n}\nvoid dfs2(ll u, ll fa1, ll fa2) {\n    ans[u] = 1 + dp[u][1] + dp[u][2] + fa1 + fa2;\n    for (auto&amp; it : q[u]) {\n        ll next = it.first, w = it.second;\n        if (w == 1)dfs2(next, 1, fa1 + dp[u][1] - 1);\n        else if (w == 2)dfs2(next, 0, 1);\n        else dfs2(next, 0, 0);\n\n    }\n}\nint main() {\n    scanf(\"%lld\",&amp;n);\n    for (ll i = 2; i &lt;= n; i++) {\n        ll f, w; scanf(\"%lld%lld\",&amp;f,&amp;w);\n        q[f].push_back({ i,w });\n    }\n    dfs1(1);\n    dfs2(1, 0, 0);\n    for (ll i = 1; i &lt;= n; i++)printf(\"%lld\\n\",ans[i]);\n    return 0;\n}\n\n最大子树和例题：最大子树和\n\n\n\n\n\n\n\n\n\n   题目大意：\n   寻找树上子树和最大权值和\n思路：\n\n\n\n\n\n\n\n\n\n\n遍历树上每个点，如果子节点的权值&gt;0 的话父节点加上这个子节点的权值\n最后遍历从每个点出发的最大权值\n\n代码：\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\nconst int N=2e5+10;\nint h[N],e[N],ne[N],idx;\nint n;\nint w[N],dp[N];\nvoid add(int a,int b){\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\nvoid dfs(int u,int fa){\n    dp[u]=w[u];\n    for(int i=h[u];~i;i=ne[i]){\n        int j=e[i];\n        if(j!=fa){\n            dfs(j,u);\n            if(dp[j]&gt;0)dp[u]+=dp[j];\n        }\n    }\n}\nint main(){\n    for(int i=1;i&lt;N;i++)h[i]=-1;\n    cin&gt;&gt;n;\n    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];\n    for(int i=1;i&lt;n;i++){\n        int a,b;cin&gt;&gt;a&gt;&gt;b;\n        add(a,b),add(b,a);\n    }\n    dfs(1,0);\n    int ans=-2147483647;\n    for(int i=1;i&lt;=n;i++)ans=max(ans,dp[i]);\n    cout&lt;&lt;ans&lt;&lt;endl;\n    return 0;\n}\n\n树上背包例题：选课\n\n\n\n\n\n\n\n\n\n   题目大意：\n   每门功课有一些由”必修选课”，即完成a才能选修b，这就形成了依赖性，把全部联系起来就像一棵树，要求在有限门功课前提下实现价值最大值，这就像背包问题\n思路：\n\n\n\n\n\n\n\n\n\n\n对于每个根节点，选择有限个子节点遍历并加上其价值\n在深搜过程中可以枚举0~cnt次可以实现的最大价值（根节点+当前枚举到的点的价值）\n然后搜下一个节点并且次数cnt-1\n再次遍历贪心一遍保存当前节点的最大值\n\n代码：\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N=500;\nint h[N],ne[N],e[N],w[N],idx;\nint n,m;\nint dp[N][N];\n\nvoid add(int a,int b){\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\nvoid dfs(int u,int cnt){\n    if(cnt&lt;=0)return;\n    for(int i=h[u];~i;i=ne[i]){\n        int j=e[i];\n        for(int k=0;k&lt;cnt;k++) dp[j][k]=dp[u][k]+w[j];\n        dfs(j,cnt-1);\n        for(int k=1;k&lt;=cnt;k++){\n            dp[u][k]=max(dp[u][k],dp[j][k-1]);\n        }\n    }\n}\nint main(){\n    for(int i=0;i&lt;N;i++) h[i]=-1;\n    cin&gt;&gt;n&gt;&gt;m;\n    for(int i=1;i&lt;=n;i++){\n        int k;cin&gt;&gt;k&gt;&gt;w[i];\n        if(k) add(k,i);\n        else add(0,i);\n    }\n    dfs(0,m);\n    cout&lt;&lt;dp[0][m]&lt;&lt;endl;\n    return 0;\n}\n\n\n\n","slug":"动态规划","date":"2022-03-25T14:21:33.199Z","categories_index":"动态规划","tags_index":"动态规划","author_index":"Snailuu"},{"id":"b6a047059c4e5c0a07c0203b5ded3378","title":"高级数据结构","content":"树状数组解决问题类型：\n\n单点修改\n区间查询\n\n核心函数#define lowbit(x) ((x)&amp;(-x))\nint tr[N];\nvoid add(int x,int v){\n    for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;\n}\nint query(int x){\n    int res = 0;\n    for(int i = x; i; i -= lowbit(i)) res += tr[i];\n    return res;\n}\n\n单点更新 区间查询#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define lowbit(x) ((x)&amp;(-x))\nusing namespace std;\nconst int N = 100010;\nint n, m;\nint  a[N], tr[N];\nvoid add(int x,int v){\n    for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;\n}\nint query(int x){\n    int res = 0;\n    for(int i = x; i; i -= lowbit(i)) res += tr[i];\n    return res;\n}\nint main(){\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    for(int i = 1; i &lt;= n; i++) add(i, a[i]);\n    while(m--){\n        int l, r;\n        scanf(\"%d %d\", &amp;l, &amp;r);\n        cout &lt;&lt; query(r) - query(l - 1) &lt;&lt; endl;\n    }\n    return 0;\n}\n\n区间更新 单点查询#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define lowbit(x) ((x)&amp;(-x))\nusing namespace std;\nconst int N = 100010;\nint n, m;\nint a[N], tr[N];\nvoid add(int x,int v){\n    for(int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;\n}\nint query(int x){\n    int res = 0;\n    for(int i = x; i; i -= lowbit(i)) res += tr[i];\n    return res;\n}\nvoid insert(int l, int r, int v) {\n    add(l,v); \n    add(r+1,-v);     \n}\nint main(){\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; i++) insert(i, i, a[i]);\n    while(m--){\n        int l, r, k;\n        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;\n        insert(l, r, k);\n    }\n    for(int i = 1; i &lt;=n; i++){\n        cout &lt;&lt; query(i) &lt;&lt; \" \";\n    }\n    return 0;\n}\n\n区间更新 区间查询#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n#define lowbit(x) ((x)&amp;(-x))\nusing namespace std;\nconst int N =100010;\nint n, m;\nint a[N, tr1[N], tr2[N];\nvoid add(int x, int v){\n    for(int i = x; i &lt;= n; i+=lowbit(i)){\n        tr1[i] += v;\n        tr2[i] += v * (x - 1);\n    }\n}\nint querySum(int x){\n    int res = 0;\n    for(int i = x; i; i-=lowbit(i))\n        res += x * tr1[i] - tr2[i];\n    return res;\n}\nint queryNum(int x){ \n    int res = 0;\n    for(int i = x; i; i-=lowbit(i))\n        res += tr1[i];\n    return res;\n}\nvoid insert(int l, int r, int v){\n    add(l, v);\n    add(r+1,-v);\n}\nint main(){\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];\n    for (int i = 1; i &lt;= n; i++) insert(i, i, a[i]);\n    while(m--){\n        int l, r;\n        scanf(\"%d %d\", &amp;l, &amp;r);\n        cout &lt;&lt; querySum(r) - querySum(l - 1) &lt;&lt; endl;\n    }\n    return 0;\n}\n\n线段树加法#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#include&lt;cstdio&gt;\n#define ll long long \nusing namespace std;\nconst int N=1e5+10;\nll w[N];\nstruct node{\n    int l,r;\n    ll sum,lazy;\n}tr[N*4];\n//回溯更新\nvoid push_up(int u){\n    tr[u].sum=tr[u&lt;&lt;1].sum+tr[u&lt;&lt;1|1].sum;\n}\n//push_down向下传递式更新、记录\nvoid push_down(int u){\n    if(tr[u].lazy){\n        tr[u&lt;&lt;1].sum+=(tr[u&lt;&lt;1].r-tr[u&lt;&lt;1].l+1)*tr[u].lazy;\n        tr[u&lt;&lt;1|1].sum+=(tr[u&lt;&lt;1|1].r-tr[u&lt;&lt;1|1].l+1)*tr[u].lazy;\n        tr[u&lt;&lt;1].lazy+=tr[u].lazy;\n        tr[u&lt;&lt;1|1].lazy+=tr[u].lazy;\n        tr[u].lazy=0;\n    }\n}\n//建树\nvoid build(int u,int l,int r){\n    tr[u]={l,r};\n    if(l==r)tr[u].sum=w[r];\n    else {\n        int mid=l+r&gt;&gt;1;\n        build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r);\n        push_up(u);\n    }\n}\n//区间修改\nvoid modify(int u,int l,int r,int x){\n    if(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r){\n        tr[u].sum+=(ll)x*(tr[u].r-tr[u].l+1);\n        tr[u].lazy+=x;\n        return;\n    }  \n    push_down(u);\n    int mid=tr[u].l+tr[u].r&gt;&gt;1;\n    if(l&lt;=mid)modify(u&lt;&lt;1,l,r,x);\n    if(r&gt;mid)modify(u&lt;&lt;1|1,l,r,x);\n    push_up(u);\n}\n//区间查询\nll query(int u,int l,int r){\n    if(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r) return tr[u].sum;\n    push_down(u);\n    int mid=tr[u].l+tr[u].r&gt;&gt;1;\n    ll sum=0;\n    if(l&lt;=mid)sum+=query(u&lt;&lt;1,l,r);\n    if(r&gt;mid)sum+=query(u&lt;&lt;1|1,l,r);\n    return sum;\n}\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;i++)scanf(\"%lld\",&amp;w[i]);\n    build(1,1,n);\n    for(int i=1;i&lt;=m;i++){\n        int k,l,r,x;\n        scanf(\"%d\",&amp;k);\n        if(k==1){\n            scanf(\"%d %d %d\",&amp;l,&amp;r,&amp;x);\n            modify(1,l,r,x);\n        }else {\n            scanf(\"%d %d\",&amp;l,&amp;r);\n            printf(\"%lld\\n\",(ll)query(1,l,r));\n        }\n    }\n    return 0;\n}\n\n加乘混合#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#define ll long long \nusing namespace std;\n\nconst int N=1e5+10;\nint w[N];\nint n,m,p;\nstruct node{\n    ll l,r;\n    ll sum,add,mul;\n}tr[N*4];\n//向上更新\nvoid push_up(int u){\n    tr[u].sum=(tr[u&lt;&lt;1].sum+tr[u&lt;&lt;1|1].sum)%p;\n}\n//建树\nvoid build(int u,ll l,ll r){\n    tr[u]={l,r};tr[u].mul=1;\n    if(l==r) {\n        tr[u].sum=w[l]%p;\n        return;\n    }\n    ll mid = (l+r)&gt;&gt;1;\n    build(u&lt;&lt;1,l,mid),build(u&lt;&lt;1|1,mid+1,r);\n    push_up(u);\n}\n//向下传递式记录\nvoid push_down(int u){\n    tr[u&lt;&lt;1].sum=(ll)((tr[u].mul*tr[u&lt;&lt;1].sum)%p+((tr[u&lt;&lt;1].r-tr[u&lt;&lt;1].l+1)*tr[u].add)%p)%p;\n    tr[u&lt;&lt;1|1].sum=(ll)((tr[u].mul*tr[u&lt;&lt;1|1].sum)%p+((tr[u&lt;&lt;1|1].r-tr[u&lt;&lt;1|1].l+1)*tr[u].add)%p)%p;\n    \n    tr[u&lt;&lt;1].mul=(ll)(tr[u&lt;&lt;1].mul*tr[u].mul)%p;\n    tr[u&lt;&lt;1|1].mul=(ll)(tr[u&lt;&lt;1|1].mul*tr[u].mul)%p;\n    \n    tr[u&lt;&lt;1].add=(ll)(tr[u&lt;&lt;1].add*tr[u].mul%p+tr[u].add)%p;\n    tr[u&lt;&lt;1|1].add=(ll)(tr[u&lt;&lt;1|1].add*tr[u].mul%p+tr[u].add)%p;\n    \n    tr[u].mul=1,tr[u].add=0;\n}\n//处理区间加法\nvoid add(int u,ll l,ll r,ll k){\n    if(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r){\n        tr[u].add=(tr[u].add+k)%p;\n        tr[u].sum=(ll)((tr[u].r-tr[u].l+1)*k+tr[u].sum)%p;\n        return ;\n    }\n    push_down(u);\n    push_up(u);\n    ll mid = (tr[u].l+tr[u].r)&gt;&gt;1;\n    if(l&lt;=mid) add(u&lt;&lt;1,l,r,k);\n    if(r&gt;mid) add(u&lt;&lt;1|1,l,r,k);\n    push_up(u);\n}\n//处理区间乘法\nvoid mul(int u,ll l,ll r,ll k){\n    if(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r){\n        tr[u].add=(tr[u].add*k)%p;\n        tr[u].mul=(tr[u].mul*k)%p;\n        tr[u].sum=(tr[u].sum*k)%p;\n        return;\n    }\n    push_down(u);\n    push_up(u);\n    ll mid = (tr[u].l+tr[u].r)&gt;&gt;1;\n    if(l&lt;=mid) mul(u&lt;&lt;1,l,r,k);\n    if(r&gt;mid) mul(u&lt;&lt;1|1,l,r,k);\n    push_up(u);\n}\n//区间询问权值和\nll query(int u,int l,int r){\n    if(l&lt;=tr[u].l&amp;&amp;r&gt;=tr[u].r)return tr[u].sum;\n    push_down(u);\n    ll mid=(tr[u].l+tr[u].r)&gt;&gt;1;\n    ll sum=0;\n    if(l&lt;=mid) sum=(sum+query(u&lt;&lt;1,l,r))%p;\n    if(r&gt;mid) sum=(sum+query(u&lt;&lt;1|1,l,r))%p;\n    return sum;\n}\nint main(){\n    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;\n    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];\n    build(1,1,n);\n    while(m--){\n        int num,x,y,k;\n        cin&gt;&gt;num;\n        if(num==1){\n            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;\n            mul(1,x,y,k);\n        }else if(num==2){\n            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;\n            add(1,x,y,k);\n        }else {\n            cin&gt;&gt;x&gt;&gt;y;\n            cout&lt;&lt;(ll)query(1,x,y)&lt;&lt;endl;\n        }\n    }\n    return 0;\n}\n\n离散化\n\n\n\n\n\n\n\n\n   在每个区间长度超过1的区间加上一个数再进行离散化\n例题\n关键代码:\nfor(int i=1;i&lt;=n;i++){\n        scanf(\"%d %d\",&amp;lis[i].l,&amp;lis[i].r);\n        a[cnt++]=lis[i].l;\n        a[cnt++]=lis[i].r;\n    }\n    sort(a,a+cnt);\n    int s=unique(a,a+cnt)-a;\n    cnt=s;\n    int t=cnt;\n    for(int i=1;i&lt;t;i++){\n        if(a[i]-a[i-1]&gt;1)a[cnt++]=a[i-1]+1;\n    }\n    sort(a,a+cnt);\n    build(1,1,cnt);\n    for(int i=1;i&lt;=n;i++){\n        int le=lower_bound(a,a+cnt,lis[i].l)-a+1;\n        int rt=lower_bound(a,a+cnt,lis[i].r)-a+1;\n        modify(1,le,rt,i);\n    }\n\n\n\nManacher算法#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N=2e7+10;\nchar s[N],s_new[N];\nint p[N];//以i为中心的最长回文字符串长度\nint Init(){\n    int len=strlen(s);\n    s_new[0]='&amp;',s_new[1]='#';\n    int j=2;\n    for(int i=0;i&lt;len;i++){\n        s_new[j++]=s[i];\n        s_new[j++]='#';\n    }\n    s_new[j++]='^';\n    return j;\n}\n\n\nint Manacher(){\n    int len=Init();\n    int max_len=-1;\n    int id;\n    int mx=0;\n    for(int i=1;i&lt;len;i++){\n        if(i&lt;mx) p[i]=min(p[2*id-i],mx-i);\n        else p[i]=1;\n        while(s_new[i-p[i]]==s_new[i+p[i]])p[i]++;\n        if(mx&lt;i+p[i]){\n            id=i;\n            mx=i+p[i];\n        }\n        max_len=max(max_len,p[i]-1);\n    }\n    return max_len;\n}\nint main()\n{\n    scanf(\"%s\",s);\n    cout&lt;&lt;Manacher()&lt;&lt;endl;\n    return 0;\n}\n\n","slug":"高级数据结构","date":"2022-03-15T11:56:14.444Z","categories_index":"数据结构","tags_index":"数据结构","author_index":"Snailuu"},{"id":"4055c80e84a3b6eaa6e959bbd1b51e6a","title":"贪心总结","content":"均分纸牌设总人数有  个，纸牌总数有  张，每个人初始纸牌数量为  ，则每个人最终拥有的纸牌数量均为  记作  \n在方案存在的情况下\n第1个人为了达到平均数，需要向第2个人传递  数量的纸牌，（正表示拿，负表示给）\n第2个人为了达到平均数，需要向第3个人传递 数量的纸牌\n… …\n第n-1个人为了 达到平均数，需要向第n个人传递  数量的纸牌\n总的操作次数为： \n设  为  则  ，即  为第  个的前缀和\n\n延伸到环形纸牌均分问题上，环形区间问题，第一个要想到的就是 破环成链 了，对于一个最优解方案，环上有相邻的两个人之间没有发生交换\n\n\n\n\n\n\n\n\n\n   证明如下：   如果环上相邻两人全部发生交换，则会出现两种情形：（正数传递为有向边的正向方向）\n\n出现一个环这种方案肯定不是最优解，因为给出去的纸牌经过一圈收回来了，显然浪费了操作次数我们在这个环上断开交易数量最小的一条交换边，并使其他边减少该边的交换数量，必然不会使方案变差\n出现一个点到达另一个点有两条路径我们可以断开起点两条出边中 最小的那一套边，并该边权值累加到另一条路径的每一条边上，其结果不会变差（其中  是起点到终点路径上经过的点数， 是这条边的权重）\n\n考虑第  个人之后断开，因而环化成链有：\n\n\n\n\n\n\n\n易知道 ，故求最小步数为：，其中  为  的前缀和，即 \n然后利用绝对值不等式最小值求解 ，类似货仓取址（中间货仓 为排序后 的中位数（奇数记得向上取整））。\n例题：糖果传递\n田忌赛马马匹从小到大排序，结果分三种情况：\n这里定义cnt 为胜利场数，la为我方最小马匹指针，ra我方最大马匹指针，lb对方最小马匹指针，rb对方最大马匹指针\n胜利情况：\n\n我方最大马匹  对方最大马匹，cnt++,ra--,rb--;\n我方最小马匹  对方最小马匹，cnt++,la++,lb++;\n\n非胜利情况：\n\n我方最小马匹  对方最大马匹，la++,rb--;\n我方最小马匹  对方最大马匹，cnt--,la++,rb--\n\n邻项交换法雷达设备（区间覆盖）\n题目大意：\n\n\n\n\n\n\n\n\n\n   有许多的小岛，一个雷达可监测区域是一个半径为d的圆，而且雷达只能设置在x轴上，问至少需要几个雷达才能覆盖\n分析：\n\n\n\n\n\n\n\n\n\n\n如果小岛与x轴直线距离超过d即没法监测\n如果符合条件的话，将每个小岛可被监测的区域记录下来，按照右端点排序\n在选择的时候\n如果当前标记点能被覆盖件就直接跳过\n如果没有覆盖的话雷达数量+1并且将新的标记点更新成改区间的右端点\n\n\n\n乘积最大例题：乘积最大\n\n\n\n\n\n\n\n\n\n   题目大意：\n   找出k个数的乘积最大值\n分析：\n\n\n\n\n\n\n\n\n\n   对于k的取值，可以分为k==n||k&lt;n，对于k&lt;n还能分成k是偶数||k是奇数\n   如果k是偶数的话，结果必然为非负数\n\n   如果负数有偶数个每次取最大的一对即可\n\n\n\n\n\n\n\n\n\n   如果负数有奇数个，拿出某一个负数不去选他，问题就变成了有偶数个负数了\n   如果k是奇数的话\n\n\n\n\n\n\n\n\n\n   如果所有数均为非负数，则结果必为负数\n\n\n\n\n\n\n\n\n\n   如果至少存在一个非负数，可以先拿出这个整数，问题就有变成了负数偶数个的问题\n\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\n#define ll long long\nusing namespace std;\nconst int N=1e5+10,mod = 1000000009;\nint a[N];\nint main(){\n    int n,k;scanf(\"%d%d\",&amp;n,&amp;k);\n    for(int i=0;i&lt;n;i++)scanf(\"%d\",&amp;a[i]);\n    sort(a,a+n);\n    int res = 1;\n    int l = 0, r = n - 1;\n    int sign = 1;//标记结果的正负值\n    if(k%2){\n        res = a[r--];\n        k--;\n        if(res&lt;0)sign = -1;//k为奇数&amp;&amp;所有数均为负数\n    }\n    while(k){\n        ll x= (ll)a[l]*a[l+1],y=(ll)a[r]*a[r-1];//s\n        if(x*sign&gt;y*sign){\n            res = x%mod*res%mod;\n            l+=2;\n        }else {\n            res = y%mod*res%mod;\n            r-=2;\n        }\n        k-=2;\n    }\n    printf(\"%d\\n\",res);\n    return 0;\n}\n\n硬币购买最大/最小数量\n\n\n\n\n\n\n\n\n   题目大意：一个人拥有1、5、10、50、1005种硬币，给定一个商品价格，和各种硬币的数量，问其购买一个商品的最小硬币数和最大硬币数\n分析：\n对于最小数量，每次取出能购买的最大硬币，硬币从大到小枚举即可\n对于最大数量，可以转换成求 总钱数-商品价格的最小硬币数量  ，再用 硬币的总数-(总钱数-商品价格)求解即可\n#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int N=1100;\nint cnt[]={1,5,10,50,100};//硬币数组\nint a[10];\nint query_min(int x){//求出x所需最小硬币数量\n\tint res=0;\n\tfor(int i=4;i&gt;=0;i--){\n\t\tif(x&gt;=cnt[i]){//如果当前枚举到的硬币能使用\n\t\tfor(int j=1;j&lt;=a[i]&amp;&amp;x&gt;=cnt[i];j++){\n\t\t\t\tx-=cnt[i];\n\t\t\t\tres++;//所需硬币数量+1\n\t\t\t}\n\t\t}\n\t}\n\treturn x==0?res:-1;//如果到最后剩余钱数还有的话说明整数买不了\n}\nvoid solve(){\n\tint p;scanf(\"%d\",&amp;p);\n\tint sum=0,tot=0;\n\tfor(int i=0;i&lt;5;i++){\n\t\tscanf(\"%d\",&amp;a[i]); \n\t\tsum+=a[i]*cnt[i];//总的钱数\n\t\ttot+=a[i];//总的硬币数量\n\t}\n\tint c = query_min(p);//求出购买一个商品的最小硬币数量\n\tif(c==-1){printf(\"-1 -1\\n\");return;}\n\telse {\n\t\tint cc = tot - query_min(sum-p);\n\t\tprintf(\"%d %d\\n\",c,cc);\n\t}\n}\nint main(){\n\tint t;scanf(\"%d\",&amp;t);\n\twhile(t--)solve();\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"贪心总结","date":"2022-03-06T06:40:28.608Z","categories_index":"贪心","tags_index":"贪心","author_index":"Snailuu"},{"id":"e7c582089fc58c53917014ad61ddc86d","title":"逆元","content":"乘法逆元拓展欧几里得时间复杂度：\n\n\n\n\n\n\n\n\n\n   假设n为模数，如果  不是质数时可以用拓展欧几里得算法求逆元：\n    有逆元的充要条件是  与  互质，所以 \n   假设  的逆元为  ，那么 \n   等价于 \n   求  ，用拓展欧几里得递归到最后x为 \nint exgcd(int a, int b, int &amp;x, int &amp;y)\n{\n    if (!b)//b==0\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= a / b * x;//b!=0\n    return d;\n}\nint inv(int a,int b){\n\tint x,y;\n    exgcd(a,b,x,y);\n    return x;\n}\n\n   最后如果要输出最小整数解的话，可以用(x % p + p) % p 输出\n快速幂+费马小定理时间复杂度：\n\n\n\n\n\n\n\n\n\n   当模数p为质数时，根据费马小定理可知：\n   即：\n   LL ksm(int a, int b, int p)\n{\n    LL res = 1;\n    while (b)\n    {\n        if (b &amp; 1)\n            res = res * a % p;\n        a = a * (LL)a % p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint inv(int x,int p)\n{\n\treturn ksm(x,p-2,p);\n}\n\n求～ 之间的逆元且模数  为质数时间复杂度：\n\n\n\n\n\n\n\n\n\n   方法：\n   \n   inv[0]=0,inv[1]=1;\nprintf(\"1\\n\");\nfor(ll i=2;i&lt;=n;i++)\n{\n    inv[i]=(ll)(p-p/i)*inv[p%i]%p;\n    printf(\"%lld\\n\",inv[i]);\n}\n\n","slug":"逆元","date":"2022-03-02T13:40:44.841Z","categories_index":"数学","tags_index":"数论,逆元","author_index":"Snailuu"},{"id":"92e9e21f40cabb2aa99ef90279e6b57e","title":"某些可能有用的链接","content":"2022/2/21 upd:\n不知道链接能活多久\n本文不定期更新\n支持推荐，如果有什么你觉得很有意义的文章/工具，欢迎把链接发送给我。\nTools (about Competitive Programming) :Csacademy Graph Editor（画“图”） Data Structure Visualization（算法/数据结构可视化） BZOJ 离线题库 模板题 OJ OIerDB（OIer数据库） 各大 OJ 做题量统计 OI Archive  \nAtcoder: AtCoder Rating Perdictor AtCoder Problems（题目列表、显示题目难度、显示做题情况）  \nTools (not about Competitive Programming) :Geogebra 图形计算器 Desmos 图形计算器 图床 sm.ms 图床 imgtu.com 图片压缩 GIF maker Ubuntu Pastebin 剪贴板 乱码修复 Stackedit（在线 Markdown 编辑器） Compiler Explorer（查看汇编码） OEIS（数列查询）  \nBlogs/Articles (about Competitive Programming) :OI Wiki 洛谷日报 OI-Public-Library（包含 IOI 中国国家候选队论文） list of useful blogs on codeforces The Ultimate Topic List (with Resources, Problems and Templates) 综合题单  \nUOJ 精神之源流（这个不算是实用性的，偏题了，只是我觉得大家都应该看一看）  \nBlogs/Articles (not about Competitive Programming) :C++ Reference Another C++ Reference LaTeX 数学公式大全 TheFreeDictionary（内含 wikipedia 镜像）\nGames我不确定要不要加这一栏？\n","slug":"不知名文章","date":"2022-02-21T13:33:14.265Z","categories_index":"","tags_index":"","author_index":"Snailuu"},{"id":"aa03b2f0abb625816c3d81ed8f81147b","title":"图论最短路问题","content":"朴素版Dijkstra算法(适用于稠密图)思路\n初始化距离数组和邻接矩阵（无穷大）\n处理重边问题在输入取最小值\n每次找到一个最小的未更新的答案点\n将其连边答案全部更新\n\n例题：Dijkstra算法朴素版\n代码实现如下：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 520, INF = 0x3f3f3f3f;\nint n, m;\nint g[N][N], dis[N];\nbool st[N];\n\nint dijkstra()\n{\n    dis[1] = 0; //每个点到一号点的最短距离\n    //如需求到s点的一开始将dis[s]定义为0即可\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (!st[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))\n                t = j; //找到当前未更新的最小点\n        }\n        for (int j = 1; j &lt;= n; j++)\n            dis[j] = min(dis[j], dis[t] + g[t][j]); //将t连接的点都更新最短距离\n        st[t] = true;\n    }\n    if (dis[n] == 0x3f3f3f3f)\n        return -1; // 1~n之间不连通，无法构成路径，也就没有最短距离\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(g[0], g[0] + N * N, INF);\n    fill(dis, dis + N, INF);\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        g[x][y] = min(g[x][y], c); //处理重边\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n\n堆优化版Dijkstra算法(适用于稀疏图)优点： \n\n堆可以动态维护一个集合中的最小值\n堆动态支持插入，删除，修改一个数\n\n优化部分：\nfor(int j=1;j&lt;=n;j++)\n{\n    if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n}\n//每次寻找一个最小值可以用堆来维护一个最小值\n//复杂度从O(n)-&gt;O(1)\n////////////////////////////////////////////\nfor(int j=1;j&lt;=n;j++)\n    dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n//每次将点更新在堆中修改复杂度为mlogm\n//复杂度从O(n)-&gt;O(mlogm)\n//////////////////////////////////////////////\n//总体复杂度从O(n^2)-&gt;O(mlogm)\n\n例题：Dijkstra算法堆优化版\n代码实现：\n#include &lt;bits/stdc++.h&gt;\n#define PII pair&lt;int, int&gt;\nusing namespace std;\n\nconst int N = 1e6 + 10, INF = 0x3f3f3f3f;\nint n, m;\nint h[N], e[N], ne[N], idx;\nint dis[N], w[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint dijkstra()\n{\n    fill(dis, dis + N, INF);\n    dis[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; //优先队列默认大根堆，这样子写可以维护小根堆,pair&lt;int,int&gt;第一个值存数值，第二个值存下标\n    heap.push({0, 1});\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver]) continue; //每次处理均为最小值且未处理过的\n        st[ver] = true;\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dis[j] &gt; dis[ver] + w[i]) //有更短路就替换\n            {\n                dis[j] = dis[ver] + w[i];\n                heap.push({dis[j], j}); //将新的方案加入到队列中\n            }\n        }\n    }\n    //队列为空即走完整个图\n    if (dis[n] == INF)\n        return -1;\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(h, h + N, -1); //将头结点数组全部初始化成-1\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        add(x, y, c);\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n\n\nSPFA算法（适用于稀疏图）Bellman-Ford太呆\n优点：\n\n每次只更新与结点有关点的最小距离\n\n例题：SPFA求最短路\n代码实现：\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[N], ne[N], w[N], idx; //稀疏图用邻接表来存图\nint n, m;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint spfa()\n{\n    fill(dist, dist + N, INF); //先将每个到源点的距离初始化成正无穷\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        int t = q.front();\n        q.pop();\n        st[t] = false; //出队了\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) //更新t结点的所有距离\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])\n                {\n                    q.push(j); //更新的点第一次访问就进度，后面可能还能再利用其更新其他点\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    while (m--)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if (t == INF) //如果到n点还无法更新距离说明无法连通\n        puts(\"impossible\");\n    else\n        cout &lt;&lt; t &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\nKM算法-dfs（#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 300 + 10;\nconst int INF = 0x3f3f3f3f;\n\nint wx[maxn], wy[maxn];//每个点的顶标值（需要根据二分图处理出来）\nint cx[maxn], cy[maxn];//每个点所匹配的点\nint visx[maxn], visy[maxn];//每个点是否加入增广路\nint cntx, cnty;//分别是X和Y的点数\nint Map[maxn][maxn];//二分图边的权值\nint slack[maxn];//边权和顶标最小的差值\n\nbool dfs(int u)//进入DFS的都是X部的点\n{\n    visx[u] = 1;//标记进入增广路\n    for(int v = 1; v &lt;= cnty; v++)\n    {\n        if(!visy[v] &amp;&amp; Map[u][v] != INF)//如果Y部的点还没进入增广路,并且存在路径\n        {\n            int t = wx[u] + wy[v] - Map[u][v];\n            if(t == 0)//t为0说明是相等子图\n            {\n                visy[v] = 1;//加入增广路\n\n                //如果Y部的点还未进行匹配\n                //或者已经进行了匹配，可以从原来的匹配反向找到增广路\n                //那就可以进行匹配\n                if(cy[v] == -1 || dfs(cy[v]))\n                {\n                    cx[u] = v;\n                    cy[v] = u;//进行匹配\n                    return 1;\n                }\n            }\n            else if(t &gt; 0)//此处t一定是大于0，因为顶标之和一定&gt;=边权\n            {\n                slack[v] = min(slack[v], t);\n                //slack[v]存的是Y部的点需要变成相等子图顶标值最小增加多少\n            }\n        }\n    }\n    return false;\n}\n\nint KM()\n{\n    memset(cx, -1, sizeof(cx));\n    memset(cy, -1, sizeof(cy));\n    memset(wx, 0, sizeof(wx));//wx的顶标为该点连接的边的最大权值\n    memset(wy, 0, sizeof(wy));//wy的顶标为0\n    for(int i = 1; i &lt;= cntx; i++)//预处理出顶标值\n    {\n        for(int j = 1; j &lt;= cnty; j++)\n        {\n            if(Map[i][j] == INF)continue;\n            wx[i] = max(wx[i], Map[i][j]);\n        }\n    }\n    for(int i = 1; i &lt;= cntx; i++)//枚举X部的点\n    {\n        memset(slack, INF, sizeof(slack));\n        while(1)\n        {\n\n            memset(visx, 0, sizeof(visx));\n            memset(visy, 0, sizeof(visy));\n            if(dfs(i))break;//已经匹配正确\n\n\n            int minz = INF;\n            for(int j = 1; j &lt;= cnty; j++)\n                if(!visy[j] &amp;&amp; minz &gt; slack[j])\n                    //找出还没经过的点中，需要变成相等子图的最小额外增加的顶标值\n                    minz = slack[j];\n            //和全局变量不同的是，全局变量在每次while循环中都需要赋值成INF，每次求出的是所有点的最小值\n            //而slack数组在每个while外面就初始化好，每次while循环slack数组的每个值都在用到\n            //在一次增广路中求出的slack值会更准确，循环次数比全局变量更少\n\n\n            //还未匹配，将X部的顶标减去minz，Y部的顶标加上minz\n            for(int j = 1; j &lt;= cntx; j++)\n                if(visx[j])wx[j] -= minz;\n            for(int j = 1; j &lt;= cnty; j++)\n                //修改顶标后，要把所有不在交错树中的Y顶点的slack值都减去minz\n                if(visy[j])wy[j] += minz;\n                else slack[j] -= minz;\n        }\n    }\n\n    int ans = 0;//二分图最优匹配权值\n    for(int i = 1; i &lt;= cntx; i++)\n        if(cx[i] != -1)ans += Map[i][cx[i]];\n    return ans;\n}\nint n, k;\nint main()\n{\n    while(scanf(\"%d\", &amp;n) != EOF)\n    {\n        for(int i = 1; i &lt;= n; i++)\n        {\n            for(int j = 1; j &lt;= n; j++)\n                scanf(\"%d\", &amp;Map[i][j]);\n        }\n        cntx = cnty = n;\n        printf(\"%d\\n\", KM());\n    }\n    return 0;\n}\n\n\nKM算法-BFS()#include&lt;iostream&gt;\n#include&lt;cstring&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;map&gt;\n#include&lt;queue&gt;\n\n#define ll long long \nusing namespace std;\n\nconst int MAXN=510;\n\nint n,m;\nint e[MAXN][MAXN];\n\nint lx[MAXN],ly[MAXN],slack[MAXN];\nint px[MAXN],py[MAXN],pre[MAXN];\nbool vx[MAXN],vy[MAXN];\n\nqueue&lt;int&gt; q;\nvoid aug(int v)\n{\n\tint t;\n\twhile(v)\n\t{\n\t\tt=px[pre[v]];\n\t\tpx[pre[v]]=v;\n\t\tpy[v]=pre[v];\n\t\tv=t;\n\t}\n}\nvoid bfs(int s)\n{\n\tmemset(vx,0,sizeof(vx));\n\tmemset(vy,0,sizeof(vy));\n\tfill(slack+1,slack+n+1,inf);\n\t\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\t\n\twhile(1)\n\t{\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u=q.front();q.pop();\n\t\t\tvx[u]=1;\n\t\t\tfor(int i=1;i&lt;=n;++i)if(!vy[i])\n\t\t\t{\n\t\t\t\tif(lx[u]+ly[i]-e[u][i]&lt;slack[i])\n\t\t\t\t{\n\t\t\t\t\tslack[i]=lx[u]+ly[i]-e[u][i];\n\t\t\t\t\tpre[i]=u;\n\t\t\t\t\tif(slack[i]==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvy[i]=1;\n\t\t\t\t\t\tif(!py[i]){aug(i);return;}\n\t\t\t\t\t\telse q.push(py[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint d=inf;\n\t\tfor(int i=1;i&lt;=n;++i)if(!vy[i])d=min(d,slack[i]);\n\t\tfor(int i=1;i&lt;=n;++i)\n\t\t{\n\t\t\tif(vx[i])lx[i]-=d;\n\t\t\tif(vy[i])ly[i]+=d;else slack[i]-=d;\n\t\t}\n\t\tfor(int i=1;i&lt;=n;++i)if(!vy[i])\n\t\t{\n\t\t\tif(slack[i]==0)\n\t\t\t{\n\t\t\t\tvy[i]=1;\n\t\t\t\tif(!py[i]){aug(i);return;}\n\t\t\t\telse q.push(py[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(int i=1;i&lt;=n;++i)bfs(i);\n}\n\n","slug":"图论最短路","date":"2022-02-20T13:19:08.472Z","categories_index":"图论","tags_index":"最短路,稠密图,稀疏图","author_index":"Snailuu"},{"id":"3066e00b6cf820c21780a6c4e3135165","title":"矩阵的数量V3","content":"题目链接：矩形的数量 V3\n\n 矩形的数量 V3\n\n\nTime limit : 1000ms        Memory limit: 131072 kb\n    \n\n\n一个m乘n的方格图，有多少个大小不同的正方形。\n例如：4*3的方格中共有20个，其中：\n 12个  6个  2个\nInput\n\n\n\n\n\n\n\n\n\n共一行：2个数m,n，对应方格图的长宽（1 &lt;= m, n &lt;= 1e9） \nOutput\n\n\n\n\n\n\n\n\n\n   输出对应的矩形种类 。\nSample\nInput\n\n\n\n\n\n\n\n\n\n   4        3\nOutput\n\n\n\n\n\n\n\n\n\n   20\n\n题意\n一个  的矩形，问里面有多少个大小不同的正方形\n\n思路暴力解法可以看出，设  \n边长为  的正方形个数：\n边长为  的正方形个数：\n边长为  的正方形个数：\n\n边长为  的正方形个数：\n所以最终答案为：\n但是用循环累加就会超时，就需要对上面的式子进行等价变换：\n\n\n\n\n其中   为定值\n可以分为以下两部分进行分解：\n\n\n故最终答案为：\n代码：\n#include &lt;iostream&gt;\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1e9 + 7;\nint main()\n{\n    ll m, n;\n    cin &gt;&gt; m &gt;&gt; n;\n    if (m &lt; n)\n        swap(m, n);\n    ll ans = n * (n + 1) / 2;\n    if (ans % 3 == 0)\n        ans = ans / 3 % mod * (3 * m - n + 1) % mod;\n    else\n        ans = ans % mod * (3 * m - n + 1) / 3 % mod;\n    cout &lt;&lt; ans % mod &lt;&lt; endl;\n    return 0;\n}\n\n","slug":"矩阵的数量V3","date":"2022-02-19T09:53:53.021Z","categories_index":"杂题","tags_index":"数学知识","author_index":"Snailuu"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"质数试除法判定质数\n时间复杂度：\n\nbool is_prime(int x)\n{\n    if (x &lt; 2) return false;\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n            return false;\n    return true;\n}\n\n试除法分解质因数\n时间复杂度： ~ \n\nvoid divide(int x)\n{\n    for (int i = 2; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        {\n            int s = 0;\n            while (x % i == 0) x /= i, s ++ ;\n            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;\n        }\n    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;\n    cout &lt;&lt; endl;\n}\n\n线性筛法求素数\nprimes[]存储所有素数，cnt记录素数个数，st[]存储x是否被筛掉\n\nint primes[N], cnt;\nbool st[N];\nvoid get_primes(int n)\n{\n    for (int i = 2; i &lt;= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n\n\n试除法求所有约数vector&lt;int&gt; get_divisors(int x)\n{\n    vector&lt;int&gt; res;\n    for (int i = 1; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        {\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);\n        }\n    sort(res.begin(), res.end());\n    return res;\n}\n\n约数个数和约数之和\n\n\n\n\n\n\n\n\n   假设一个数  可以表示为\n   \n    为素数\n   则  的约数个数为：\n   约数之和为：\nconst int mod = 1e9 + 7;\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    unordered_map&lt;int, int&gt; primes;\n    while (n--)\n    {\n        int x;\n        cin &gt;&gt; x;\n        for (int i = 2; i &lt;= x / i; i++)\n        {\n            while (x % i == 0)\n            {\n                x /= i;\n                primes[i]++;\n            }\n        }\n        if (x &gt; 1)\n            primes[x]++;\n    }\n    ll res = 1;\n    ////////////////求约数个数////////////////\n    for (auto p : primes)\n        res = res * (p.second + 1) % mod;\n    ////////////////求约数个数////////////////\n    ////////////////求约数之和////////////////\n    for (auto p : primes)\n    {\n        ll a = p.first, b = p.second;\n        ll t = 1;\n        while (b--)\n            t = (t * a + 1) % mod;\n        res = res * t % mod;\n    }\n    ////////////////求约数之和////////////////\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n   如果使用递归二分求等比数列\n   简写为：\n   若  为奇数时，就会有偶数项，则：\n   \n   然后分别从两边提取一个数  ，  ，……. ，\n   然后提取公因式可以得到：\n   \n   如果  是偶数的话，同理可得：\n   \nll ksm(ll a, ll b, ll p)\n{\n    ll ans = 1;\n    while (b)\n    {\n        if (b &amp; 1)\n            ans = (ans * a) % p;\n        b &gt;&gt;= 1;\n        a = (a * a) % p;\n    }\n    return ans;\n}\nll sum(ll p, ll n, ll mod)\n{\n    if (!n) return 1;\n    if (n == 1) return (1 + p) % mod;\n    if (n &amp; 1)\n        return ((1 + ksm(p, (n - 1) / 2, mod) % mod) * sum(p, (n - 1) / 2, mod) % mod) % mod;\n    else\n        return ((1 + ksm(p, n / 2, mod) % mod) * sum(p, n / 2 - 1, mod) % mod + ksm(p, n, mod)) % mod;\n}\n\n最大公约数/最小公倍数int gcd(int a,int b)\n{\n    return b==0?a:gcd(b,a%b);\n}\nint lcm(int a,int b)\n{\n    return a/gcd(a,b)*b;\n}\n\n\n\n欧拉函数\n欧拉函数，即  ，表示的是小于等于  和  互质的数的个数。\n比如  ,\n当  是质数的时候，显然有 \n\n求n的欧拉值\n\n\n\n\n\n\n\n\n   欧拉函数是一个积性函数，当  互质时，，特别地，当  是奇数时 \n   由唯一分解定理知： \n   因此 \n   由容斥定理可得：\n   、、、 只与质因子有关，跟质因子的次数无关。\n朴素版求欧拉函数int phi(int x)\n{\n    int res = x;\n    for (int i = 2; i &lt;= x / i; i++)\n    {\n        if (x % i == 0)\n        {\n            res = res / i * (i - 1);\n            while (x % i == 0)\n                x /= i;\n        }\n    }\n    if (x &gt; 1)\n        res = res / x * (x - 1);\n    return res;\n}\n\n筛法求欧拉函数\n\n\n\n\n\n\n\n\n\n质数  的欧拉函数即为eular[i-1]：～ 均与  互质，共有  个\n\neular[primes[j]*i] 分为两种情况：\ni%primes[j]==0：primes[j] 是id的最小质因子，也是primes[j]*i的最小质因子，因此i-1/primes[j]这一项在eular[i]中计算过了即\ni%primes[j]!=0：primes[j]不是i的质因子，只是primes[j]*i的最小质因子，所以只需要多加一项1-1/primes[j]，即\n进一步化简可得：\n\n\nint primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\nvoid get_eulers(int n)\n{\n    euler[1] = 1;\n    for (int i = 2; i &lt;= n; i ++ )\n    {\n        if (!st[i])\n        {\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        }\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        {\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            {\n                euler[t] = euler[i] * primes[j];\n                break;\n            }\n            euler[t] = euler[i] * (primes[j] - 1);\n        }\n    }\n}\n\n欧拉定理\n\n\n\n\n\n\n\n\n   若 ，则\n拓展欧拉定理\n\n\n\n\n\n\n\n\n   \n快速幂\n\n\n\n\n\n\n\n\n   设  为一个数的幂，将  用二进制表示，以此来分割成更小的任务\n   比如：\n   于是我们只需要知道  的  次幂的序列就可以求出  的  次幂，举个例子：\n   \n   \n   \n   \n   因此计算  就只需要将其二进制位为  的整系数幂乘起来即可：\n   \n快速幂\n时间复杂度：\n\nint qmi(int m, int k, int p)\n{\n    int res = 1 % p, t = m;\n    while (k)\n    {\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p;\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n\n\n\n快速幂求逆元\n\n\n\n\n\n\n\n\n   当  为质数时，可以用快速幂求逆元\n   \n   \n   \n   同： \n   由费马小定理可知，当  为质数时\n   所以当  为质数时，  的逆元 \n\n   如果  不是质数时可以用拓展欧几里得算法求逆元：\n    有逆元的充要条件是  与  互质，所以 \n   假设  的逆元为  ，那么 \n   等价于 \n乘法逆元定义：\n\n\n\n\n\n\n\n\n\n   若整数 b，m 互质，并且对于任意的整数 a，如果满足 ，则存在一个整数 x，使得 ，则称 x 为 b 的模 m 乘法逆元，记为 。   b 存在乘法逆元的充要条件是 b 与模数 m 互质。当模数 m 为质数时，即为 b 的乘法逆元。\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\ntypedef long long LL;\nLL ksm(int a, int b, int p)\n{\n    LL res = 1;\n    while (b)\n    {\n        if (b &amp; 1)\n            res = res * a % p;\n        a = a * (LL)a % p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &amp;n);\n    while (n--)\n    {\n        int a, p;\n        scanf(\"%d%d\", &amp;a, &amp;p);\n        if (a % p == 0) puts(\"impossible\");\n        else printf(\"%lld\\n\", ksm(a, p - 2, p));\n    }\n\n    return 0;\n}\n\n矩阵快速幂\n利用结构体构造矩阵，并将其初始化成单位矩阵\nstruct mat{\n    int m[N][N];\n    mat() { // 用构造函数初始化成 单位矩阵E\n        memset(m, 0, sizeof m);\n        for (int i = 0; i &lt; N; i ++) m[i][i] = 1;\n    }\n}\n\n\n\n矩阵乘法： 比如两个矩阵  和  ，每一次相乘总是   的行与  的列，所以可以用两层循环表示  的行的数量的变化和  的列的数量进行变化，因为  的列和  的行数量是相同的，可以用第三层循环解决。\nmat multi(mat a, mat b) { \n    mat c;\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            c.m[i][j] = 0;\n            for (int k = 0; k &lt; n; k++) {\n                c.m[i][j] += a.m[i][k] * b.m[k][j]; // 累加\n            }\n            c.m[i][j] %= mod;\n        }\n    }\n    return c;\n}\n\n矩阵快速幂（核心）：将数变成结构体矩阵即可\n// 矩阵快速幂（核心）\nmat fastpow(mat a, int k) { \n    mat res;\n    while (k) {\n        if (k &amp; 1) res = multi(res, a);\n        a = multi(a, a);\n        k &gt;&gt;= 1;\n    }\n    return res;\n}\n\n拓展欧几里得算法\n\n\n\n\n\n\n\n\n   由裴蜀定理可知：设 、 是不全为零的整数，则存在整数 、 使得 \n   下面用  表示 、 的最大公约数\n拓展欧几里得算法\n\n\n\n\n\n\n\n\n   \n   如果  ，则有 ，即存在一组解为： 使得 \n   如果  ，则有 \n   用  来表示  , \n   代入可得：\n   即：\n   \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n{\n    if (!b)//b==0\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= a / b * x;//b!=0\n    return d;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &amp;n);\n    while (n -- )\n    {\n        int a, b;\n        scanf(\"%d%d\", &amp;a, &amp;b);\n        int x, y;\n        exgcd(a, b, x, y);\n        printf(\"%d %d\\n\", x, y);\n    }\n    return 0;\n}\n\n\n\n线性同余方程\n\n\n\n\n\n\n\n\n   给定一个、、 ，是否存在一个数 使得  \n   即是否存在一个整数  使得：\n   进一步化简并令  ， 可得：\n   此时如果  即存在，如果要求最小正整数解就将   两边再乘以  即可\n   反之不存在\n   最小正整数可以：  \n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\ntypedef long long LL;\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n{\n    if (!b)\n    {\n        x = 1, y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &amp;n);\n    while (n -- )\n    {\n        int a, b, m;\n        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;m);\n        int x, y;\n        int d = exgcd(a, m, x, y);\n        if (b % d) puts(\"impossible\");\n        else printf(\"%d\\n\", (LL)b / d * x % m);\n    }\n    return 0;\n}\n\n\n\n中国剩余定理高斯消元解线性方程组解异或线性方程组求组合数\n时间复杂度询问次数10w，数据范围：1&lt;=b&lt;=a&lt;=2000\n\n\n\n\n\n\n\n\n\n    表示从  个苹果中选出  个的方案数，第  个苹果可以分为选和不选，选：  ，不选： 总的根据加法计数原理可得：\nvoid init()\n{\n    for (int i = 0; i &lt; N; i++)\n        for (int j = 0; j &lt;= i; j++)\n            if (!j) f[i][j] = 1;\n            else f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mod;\n}\n\n时间复杂度：询问次数10w，数据范围：1&lt;=b&lt;=a&lt;=100000\n\n如果模数是质数用费马小定理求解逆元，逆元通过快速幂求解，反之用拓展欧几里得求解。\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#define ll long long \n\nusing namespace std;\n\nconst int N = 1e5+10,mod=1e9+7;\nint infact[N],fact[N];\n\nint ksm(int a,int b,int p)\n{\n    int res=1;\n    while(b)\n    {\n        if(b&amp;1)res=(ll)res*a%p;\n        a=(ll)a*a%p;\n        b&gt;&gt;=1;\n    }\n    return res;\n}\nint main()\n{\n    fact[0]=infact[0]=1;\n    for(int i=1;i&lt;=N;i++)\n    {\n        fact[i]=(ll)fact[i-1]*i%mod;\n        infact[i]=(ll)infact[i-1]*ksm(i,mod-2,mod)%mod;\n    }\n    int n;\n    cin&gt;&gt;n;\n    while (n -- )\n    {\n        int a,b;\n        cin&gt;&gt;a&gt;&gt;b;\n        cout&lt;&lt;(ll)fact[a]*infact[b]%mod*infact[a-b]%mod&lt;&lt;endl;\n    }\n    return 0;\n}\n\nLucas定理，时间复杂度询问次数20，数据范围：1&lt;=b&lt;=a&lt;=1e18\n\n#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\nint ksm(int a, int b, int p)\n{\n    int res = 1;\n    while (b)\n    {\n        if (b &amp; 1)\n            res = (ll)res * a % p;\n        a = (ll)a * a % p;\n        b &gt;&gt;= 1;\n    }\n    return res;\n}\nint C(int a, int b, int p)\n{\n    if (b &gt; a)\n        return 0;\n    int res = 1;\n    for (int i = 1, j = a; i &lt;= b; i++, j--)\n    {\n        res = (ll)res * j % p;\n        res = (ll)res * ksm(i, p - 2, p) % p;\n    }\n    return res;\n}\nint lucas(ll a, ll b, int p)\n{\n    if (a &lt; p &amp;&amp; b &lt; p)\n        return C(a, b, p);\n    return (ll)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;\n}\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    while (n--)\n    {\n        ll a, b;\n        int p;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;\n        cout &lt;&lt; lucas(a, b, p) &lt;&lt; endl;\n    }\n    return 0;\n}\n\n高精度由唯一分解定理可知：一个数可以分解成：\n 中的质因子  的个数等于 ～ 每个数包含质因子  的个数之和\n阶乘分解质因子\n求解 n! 中 p 因子的个数\nint get(int n,int p)\n{\n    int res=0;\n    while(n)\n    {\n        res+=n/p;\n        n/=p;\n    }\n    return res;\n}\n\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N=5010;\nint primes[N],cnt;\nbool st[N];\nint sum[N];\n\nvoid get_primes(int n)\n{\n    for(int i=2;i&lt;=n;i++)\n    {\n        if(!st[i])primes[cnt++]=i;\n        for(int j=0;primes[j]&lt;=n/i;j++)\n        {\n            st[primes[j]*i]=true;\n            if(primes[j]%i==0)break;\n        }\n    }\n}\nint get(int n,int p)\n{\n    int res=0;\n    while(n)\n    {\n        res+=n/p;\n        n/=p;\n    }\n    return res;\n}\nvector&lt;int&gt; mul(vector&lt;int&gt;a,int b)\n{\n    vector&lt;int&gt;c;\n    int t=0;\n    for(int i=0;i&lt;a.size();i++)\n    {\n        t+=a[i]*b;\n        c.push_back(t%10);\n        t/=10;\n    }\n    while(t)\n    {\n        c.push_back(t%10);\n        t/=10;\n    }\n    return c;\n}\nint main()\n{\n    int a,b;\n    cin&gt;&gt;a&gt;&gt;b;\n    get_primes(a);\n    for(int i=0;i&lt;cnt;i++)\n    {\n        int p=primes[i];\n        sum[i]+=get(a,p)-get(b,p)-get(a-b,p);\n    }\n    vector&lt;int&gt;res;\n    res.push_back(1);\n    for(int i=0;i&lt;cnt;i++)\n    {\n        for(int j=0;j&lt;sum[i];j++)\n        {\n            res=mul(res,primes[i]);\n        }\n    }\n    for(int i=res.size()-1;i&gt;=0;i--) cout&lt;&lt;res[i];\n    cout&lt;&lt;endl;\n    return 0;\n}\n\n卡特兰数容斥定理奇加偶减 ：多个集合的并集可以表示成：单独一个集合相加 - 两两成型的集合+三个一起的集合 - 四个团聚的集合+….-….直到所有集合合成一个。\n\n例题：能被整除的数\n\n\n\n\n\n\n\n\n\n   以这道题为例： ，故 \n   每个集合不需要知道具体元素，只需要数量，即 ，并集的话就只需要除以相乘的数，即\n   对于每个集合的状态，这里可以用二进制表示，比如  表示选中第一，二，四个集合，根据公式，前面的系数为 \n代码\n#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\n\nconst int N = 20;\nint p[N], n, m;\n\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i];\n    int res = 0;\n    for (int i = 1; i &lt; 1 &lt;&lt; m; i++)//用二进制表示每个种集合选中方式\n    {\n        int t = 1, s = 0;//t表示对应质数的乘积,s表示选中集合数量\n        for (int j = 0; j &lt; m; j++)//枚举当前状态的每一位\n        {\n            if (i &gt;&gt; j &amp; 1)//如果为1则表示选中\n            {\n                if ((ll)t * p[j] &gt; n)//如果当前乘积大于n则n/t=0,跳出循环\n                {\n                    t = -1;\n                    break;\n                }\n                s++;//集合数量+1\n                t *= p[j];//当前集合质数乘积\n            }\n        }\n        if (t == -1)continue;\n        if (s &amp; 1) res += n / t;//如果有奇数个集合，系数是1\n        else res -= n / t;//反之是-1\n    }\n    cout &lt;&lt; res &lt;&lt; endl;\n    return 0;\n}\n\n\n\n博弈论Nim游戏","slug":"数学模板","date":"2022-02-17T13:59:00.749Z","categories_index":"数学,模板","tags_index":"模板,数学","author_index":"Snailuu"},{"id":"d11324b19b05ce1c671aea0ac57ea0cf","title":"搜索与图论模板","content":"树与图的存储\n树是一种特殊的图（无向无环图），与图的存储方式相同\n\n无向图就是特殊的有向图，存储两条边  和 \n\n邻接矩阵：g[a][b]存储边 \n\n邻接表：\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n// 添加一条边a-&gt;b\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);\n\n树与图的遍历\n时间复杂度：， 表示点数， 表示边数\n\n深度优先遍历int dfs(int u)\n{\n    st[u] = true; // st[u] 表示点u已经被遍历过\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    }\n}\n\n宽度优先遍历queue&lt;int&gt; q;\nst[1] = true; // 表示1号点已经被遍历过\nq.push(1);\nwhile (q.size())\n{\n    int t = q.front();\n    q.pop();\n\n    for (int i = h[t]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j])\n        {\n            st[j] = true; // 表示点j已经被遍历过\n            q.push(j);\n        }\n    }\n}\n\n例：\n拓扑排序\n时间复杂度：， 表示点数， 表示边数\n\nbool topsort()\n{\n    int hh = 0, tt = -1;\n    // d[i] 存储点i的入度\n    for (int i = 1; i &lt;= n; i ++ )\n        if (!d[i])\n            q[ ++ tt] = i;\n    while (hh &lt;= tt)\n    {\n        int t = q[hh ++ ];\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (-- d[j] == 0)\n                q[ ++ tt] = j;\n        }\n    }\n    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。\n    return tt == n - 1;\n}\n\n朴素版Dijkstra算法\n时间复杂度：， 表示点数， 表示边数\ng[][]存储每条边，dist[] 存储1号点到每个点的最短距离，st[] 存储每个点的最短路是否已经确定\n如果要求某个点到其他点的最短路，在一开始只需要将dist[a]初始化成0即可\n\n\n\n\n\n\n\n\n\n\n\n初始化距离数组，dist[1] = 0， dist[i] = inf;\nfor n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离\n将不在 S 中dist_min的点t\nt  S加入最短路集合\n用 t 更新到其他点的距离\n\nint g[N][N],dist[N];\nbool st[N];\n// 求1号点到n号点的最短路，如果不存在则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    for (int i = 0; i &lt; n - 1; i ++ )\n    {\n        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点\n        for (int j = 1; j &lt;= n; j ++ )\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))\n                t = j;\n        // 用t更新其他点的距离\n        for (int j = 1; j &lt;= n; j ++ )\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n        st[t] = true;\n    }\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\n堆优化版Dijkstra算法\n时间复杂度： ， 表示点数， 表示边数\nn表示点的数量，dist[] 存储1号点到其他点的距离，st[]存储每个点的最短距离是否已确定\n\n\n\n\n\n\n\n\n\n\n\n利用邻接表，优先队列\n在priority_queue[HTML_REMOVED],greater[HTML_REMOVED] &gt; heap；中将返回堆顶\n利用堆顶来更新其他点，并加入堆中类似宽搜\n\ntypedef pair&lt;int, int&gt; PII;\nint n;\nint h[N], w[N], e[N], ne[N], idx;// 邻接表存储所有边\nint dist[N];\nbool st[N];\n// 求1号点到n号点的最短距离，如果不存在，则返回-1\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;\n    heap.push({0, 1});// first存储距离，second存储节点编号\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver]) continue;//已经确定最短距离的就不用处理\n        st[ver] = true;\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; distance + w[i])\n            {\n                dist[j] = distance + w[i];\n                heap.push({dist[j], j});\n            }\n        }\n    }\n    if (dist[n] == 0x3f3f3f3f) return -1;//找不到\n    return dist[n];\n}\n\n\n\nBellman-Ford算法\n时间复杂度：， 表示点数， 表示边数\nn表示点数，m表示边数，dist[]存储1到x的最短路距离\n\n\n\n\n\n\n\n\n\n\n\n注意连锁想象需要备份, struct Edge{int a,b,c} Edge[M];\n初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w);\n松弛k次，每次访问m条边\n\nint n, m;\nint dist[N];\nstruct Edge// 边，a表示出点，b表示入点，w表示边的权重\n{\n    int a, b, w;\n}edges[M];\n// 求1到n的最短路距离，如果无法从1走到n，则返回-1。\nint bellman_ford()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    //如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径\n    //由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。\n    for (int i = 0; i &lt; n; i ++ )\n    {\n        for (int j = 0; j &lt; m; j ++ )\n        {\n            int a = edges[j].a, b = edges[j].b, w = edges[j].w;\n            if (dist[b] &gt; dist[a] + w)\n                dist[b] = dist[a] + w;\n        }\n    }\n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    return dist[n];\n}\n\n\n\nSpfa 算法（队列优化的Bellman-Ford算法）\n时间复杂度：平均情况下 ，最坏情况下 ， 表示点数， 表示边数\nn总点数，dist[]存储每个点到1号点的最短距离，st[]存储每个点是否在队列中\n\n\n\n\n\n\n\n\n\n\n\n利用队列优化仅加入修改过的地方\nfor k次\nfor 所有边利用宽搜模型去优化bellman_ford算法\n更新队列中当前点的所有出边\n\nint n;\nint h[N], w[N], e[N], ne[N], idx;// 邻接表存储所有边\nint dist[N];\nbool st[N];\n// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\nint spfa()\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n\n判断图中是否存在负环\n方法：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环\ncnt[]存储1到x的最短路中经过的点数\n\nint n;\nint h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边\nint dist[N], cnt[N];\nbool st[N];\n// 如果存在负环，则返回true，否则返回false。\nbool spfa()\n{\n    // 不需要初始化dist数组\n    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。\n    queue&lt;int&gt; q;\n    for (int i = 1; i &lt;= n; i ++ )\n    {\n        q.push(i);\n        st[i] = true;\n    }\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        st[t] = false;\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环\n                if (!st[j])\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\nFloyd算法\n时间复杂度： ， 表示点数\nd[a][b] 表示  到  的最短距离\n\n\n\n\n\n\n\n\n\n\n\n初始化d\nk, i, j 去更新d\n\n//初始化：\n    for (int i = 1; i &lt;= n; i ++ )\n        for (int j = 1; j &lt;= n; j ++ )\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\nvoid floyd()\n{\n    for (int k = 1; k &lt;= n; k ++ )\n        for (int i = 1; i &lt;= n; i ++ )\n            for (int j = 1; j &lt;= n; j ++ )\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\n最小生成树朴素版prim算法\n时间复杂度：， 表示点数， 表示边数\nn表示点数，g[][]邻接矩阵，存储所有边，dist[]存储其他点到当前最小生成树的距离st[]存储每个点是否已经在生成树中\n\nint n;\nint g[N][N];\nint dist[N];\nbool st[N];\n// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和\nint prim()\n{\n    memset(dist, 0x3f, sizeof dist);\n    int res = 0;\n    for (int i = 0; i &lt; n; i ++ )\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j ++ )\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))\n                t = j;\n        if (i &amp;&amp; dist[t] == INF) return INF;\n        if (i) res += dist[t];\n        st[t] = true;\n        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);\n    }\n    return res;\n}\n\n\n\nKruskal算法\n时间复杂度：， 表示点数， 表示边数\nn表示点数，m表示边数，p[]并查集的父节点数组\n\nint n, m;\nint p[N];\nstruct Edge     // 存储边\n{\n    int a, b, w;\n    bool operator&lt; (const Edge &amp;W)const\n    {\n        return w &lt; W.w;\n    }\n}edges[M];\nint find(int x)     // 并查集核心操作\n{\n    if (p[x] != x) p[x] = find(p[x]);\n    return p[x];\n}\nint kruskal()\n{\n    sort(edges, edges + m);\n    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i ++ )\n    {\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n        a = find(a), b = find(b);\n        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并\n        {\n            p[a] = b;\n            res += w;\n            cnt ++ ;\n        }\n    }\n    if (cnt &lt; n - 1) return INF;\n    return res;\n}\n\n\n\n染色法判别二分图\n时间复杂度：， 表示点数， 表示边数\nn表示点数，color[]表示每个点的颜色\n\nint n;\nint h[N], e[M], ne[M], idx;// 邻接表存储图\nint color[N];// -1表示未染色，0表示白色，1表示黑色\n// 参数：u表示当前节点，c表示当前点的颜色\nbool dfs(int u, int c)\n{\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (color[j] == -1)\n        {\n            if (!dfs(j, !c)) return false;\n        }\n        else if (color[j] == c) return false;\n    }\n    return true;\n}\nbool check()\n{\n    memset(color, -1, sizeof color);\n    bool flag = true;\n    for (int i = 1; i &lt;= n; i ++ )\n        if (color[i] == -1)\n            if (!dfs(i, 0))\n            {\n                flag = false;\n                break;\n            }\n    return flag;\n}\n\n\n\n匈牙利算法\n时间复杂度：， 表示点数， 表示边数\nn1表示第一个集合中的点数，n2表示第二个集合中的点数\nmatch[]存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个，st[]表示第二个集合中的每个点是否已经被遍历过\n\nint n1, n2;\nint h[N], e[M], ne[M], idx;\nint match[N];\nbool st[N];\nbool find(int x)\n{\n    for (int i = h[x]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j])\n        {\n            st[j] = true;\n            if (match[j] == 0 || find(match[j]))\n            { \n                \n                match[j] = x;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点\n// 在加边的时候只需要加第一个集合到第二个集合的边\nint res = 0;\nfor (int i = 1; i &lt;= n1; i ++ )\n{\n    memset(st, false, sizeof st);\n    if (find(i)) res ++ ;\n}\n\n\n\n连通分量/缩点无向图\n\n\n\n\n\n\n\n\n\n   对于两个点 u 和 v有路径，就说明这两个点连通，如果对于图 G 中任意两个点都是连通的，说明图 G 是一个连通图 \n   极大强连通图：是图G的一个连通子图如果再向其中加入一个节点，则该子图不连通\n有向图\n\n\n\n\n\n\n\n\n\n   对于图 G 的任意两个点 u和v如果有路径并且v和u也有路径，说明图G是强连通图\n   极大连通图：有向图的极大连通图称为图 G 的强连通分量，如果再向其中加入一个节点，则该子图不再是强连通的\n割点和割桥\n\n\n\n\n\n\n\n\n\n   割点：删除该节点以及边，会将图分成多个连通图\n   割桥：删除某一边会将图分成多个连通图\n   割点与桥的关系：\n\n有割点不一定有桥，有桥一定有割点\n桥一定是割点依附的边\n\n双连通分量\n\n\n\n\n\n\n\n\n\n   边双连通图：不存在桥的无向图\n   点双连通图：不存在割点的图\n   边双连通分量：无向图的极大边连通子图\n   点双连通分量：无向图的极大点连通子图\n缩点\n\n\n\n\n\n\n\n\n\n   把每一个边双连通分量都看成一个点，把桥看成连接两个缩点的无向边，就可以得到一棵树\nTarjan算法求双连通分量、缩点注意：时间戳从开始计时防止后面遍历卡数据\n例题： POJ - 2553\nvoid tarjan(int u){\n    dfn[u]=low[u]=++tim;\n    ins[u]=1;//标记已经访问过\n    s.push(u);\n    for(int i=h[u];~i;i=ne[i]){\n        int j=e[i];\n        // if(j==fa)continue;\n        if(!dfn[j]){\n            tarjan(j);\n            low[u]=min(low[u],low[j]);\n        }else if(ins[j]){\n            low[u]=min(low[u],dfn[j]);\n        }\n    }\n    if(low[u]==dfn[u]){\n        int v;\n        do{\n            v=s.top();s.pop();\n            belong[v]=id;//标记强连通分量编号\n            ins[v]=0;\n        }while(v!=u);\n        id++;\n    }\n}\nfor(int i=1;i&lt;=n;i++)\n     if(!dfn[i])tarjan(i);//求连通分量\n        for(int u=1;u&lt;=n;u++){\n            for(int i=h[u];~i;i=ne[i]){\n                int v=e[i];\n              \tif(belong[u]!=belong[v])out[belong[u]]++;//如果两个缩点就标记出度\n            }\n        }\n        int flag=1;\n        for(int i=1;i&lt;=n;i++){\n            if(!out[belong[i]]){//出度为0的点就是强连通分量\n                if(flag)flag=0;\n                else printf(\" \");\n                printf(\"%d\",i);\n            }\n        }\n        puts(\"\");\n\n\n\n\n\n\n\n\n\n\n   如果要求强连通分量最大点权和，只要在处理缩点（入栈）的时候将每个点父节点加上子节点的数值即可\n缩点建图int qeury(int u){\n    if(dp[u])return dp[u];\n    dp[u]=sum[u];\n    for(int i=h[u];~i;i=ne[i]){\n        int j=e[i];\n        dp[u]=max(dp[u],dp[j]+sum[u]);\n        //当前点路径的最大点权和就是max(自己的最大值,子节点+自己联通块的)\n    }\n    return dp[u];\n}\n\nfor(int i=1;i&lt;=m;i++){\n        if(belong[x[i]]!=belong[y[i]])\n            add(belong[x[i]],belong[y[i]]);\n    //如果当前点所在缩点与另一个点所在的缩点没有连通，建边\n    }\nint ans=0;\n    for(int i=1;i&lt;=id;i++) ans=max(ans,qeury(i));\n\n\n\n例题：缩点\n","slug":"搜索与图论模板","date":"2022-02-17T03:41:35.497Z","categories_index":"图论,模板","tags_index":"模板,图论,搜索","author_index":"Snailuu"},{"id":"c28259cd908768634e0a4505c18b8177","title":"Misha and Forest","content":"原题链接：Codeforces Round #285 (Div. 2)C. Misha and Forest\nC. Misha and Forest\n\n\n    Time limit:1000ms      Memory limit:262144kb\n\n\nLet’s define a forest as a non-directed acyclic graph (also without loops and parallel edges). One day Misha played with the forest consisting of  vertices. For each vertex  from  to he wrote down two integers,  and , were the first integer is the number of vertices adjacent to vertex , and the second integer is the XOR sum of the numbers of vertices adjacent to  (if there were no adjacent vertices, he wrote down ).\nNext day Misha couldn’t remember what graph he initially had. Misha has values  and  left, though. Help him find the number of edges and the edges of the initial graph. It is guaranteed that there exists a forest that corresponds to the numbers written by Misha.\nInput\n\n\n\n\n\n\n\n\n\n   The first line contains integer  (1 ≤  ≤ ), the number of vertices in the graph.\n   The -th of the next lines contains numbers degreei and si (0 ≤ ≤ , 0 ≤ &lt;), separated by a space.\nOutput\n\n\n\n\n\n\n\n\n\n   In the first line print number , the number of edges of the graph.\n   Next print lines, each containing two distinct numbers,  and  (0 ≤ ≤ , 0 ≤  ≤ ), corresponding to edge (,).\n   Edges can be printed in any order; vertices of the edge can also be printed in any order.\nExamples\n\ninput\n\n3\n2 3\n1 0\n1 0\n\n\noutput\n\n2\n1 0\n2 0\n\n\ninput\n\n2\n1 1\n1 0\n\n\noutput\n\n1\n0 1\n\nNote\nThe XOR sum of numbers is the result of bitwise adding numbers modulo . This operation exists in many modern programming languages. For  example, in languages C++, Java and Python it is represented as ^, and in Pascal — as “xor”.\n\n题目大意定义一个森林为无向无环图（没有重边和环），给出个点，编号为～，接下来有  行数据，每行数据表示第  个点的度数和与邻接点的异或和的值，要求输出原来图的每条边。\n思路\n由于是无向无环图，所以就是一棵树，那么一定有叶子节点（度数为1）。\n可以找出所有的叶子节点，利用异或和性质a^b^c^a=b^c求出另外一个点的异或和值。\n利用拓扑排序的方式求出边\n\n题解\n找所有度数为  的节点入队，遍历他的连接叶子节点。\n连接叶子节点度数  ，如果为  就入队，直至队列为空。\n\nCode#include &lt;bits/stdc++.h&gt;\n#define ll long long\nusing namespace std;\nconst ll N = (1 &lt;&lt; 16) + 10;\nll degree[N], s[N];\nqueue&lt;int&gt; q;\npair&lt;int, int&gt; res[N];\nint main()\n{\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; degree[i] &gt;&gt; s[i];//度数，异或和值\n        if (degree[i] == 1)\n            q.push(i); //相连点只有一个，叶子\n    }\n    int cnt = 0;//用来记录边数\n    while (q.size())\n    {\n        int now = q.front();//取出队头，将它和连接叶子节点进行操作\n        q.pop();\n        if (degree[now] == 1)//在后面可能有一个点连接两个不同点，这里要加个判断\n        {\n            int next = s[now];        //叶子节点的异或和是父节点\n            res[cnt].first = now;     //子节点\n            res[cnt++].second = next; //父节点\n            degree[next]--;           //父节点连接点--\n            s[next] ^= now;           //a^b^c^a==b^c\n            if (degree[next] == 1)    //如果度数为1就入队\n                q.push(next);\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; endl;\n    for (int i = 0; i &lt; cnt; i++)//题目不要求顺序\n        cout &lt;&lt; res[i].first &lt;&lt; \" \" &lt;&lt; res[i].second &lt;&lt; endl;\n    return 0;\n}\n\n\n\n","slug":"Misha and Forest","date":"2022-02-16T12:26:41.888Z","categories_index":"codeforecs","tags_index":"位运算,拓扑排序,树","author_index":"Snailuu"},{"id":"2c4ac29383b35bd575e7e033cc42c68d","title":"STL算法","content":"数组相关nth_element//重新排序[first,last)中的元素，使得新的nth元素前的所有元素小于或等于新的nth元素后的所有元素\nstd::nth_element(first, nth, last, cmp);\n//默认排序规则从小到大\n\n\n应用：求第  大/小的数\n\nmax_element和min_element\n时间复杂度均为\n\nmax_element(a,a+n)返回数组中最大值的迭代器\n\nmin_element(a,a+n)返回数组中最小值的迭代器\n\n\nnext_permutation和prev_permutation\nnext_permutation按照全排列输出下一次排列\n\nprev_permutation按照全排列输出上一次排列\nint a[5]={1,3,2,4,5};\nnext_permutation(a,a+5);// 1 3 2 5 4\nprev_permutation(a,a+5);// 1 2 5 4 3\n\n","slug":"STL算法","date":"2022-02-16T10:51:19.371Z","categories_index":"STL","tags_index":"STL算法","author_index":"Snailuu"},{"id":"dd310f63c22e1adb321e0e6222b0b1f9","title":"STL容器","content":"vector\n可变数组，倍增的思想\n设vector&lt;int&gt;a,b\n\na.size()返回a元素个数\n\na.empty()返回a是否为空\n\na.clear()清空数组a\n\na.resize()调整a空间大小\n\na.swap(b) 将a中的元素和b中的元素整体交换\n\na.front()/back() 返回a的第一个元素/最后一个元素\n\na.push_back()/pop_back() 从尾部插入一个数/删除a的第一个元素\n\na.begin()/end() 返回容器中起始元素的迭代器/末尾的迭代器\n\na[i]访问第 i个元素\n\n注：如果还没开辟空间，不能直接用a[i]下标访问方法存储，要用push_back()存储\n\n\n\n\n\n\n\n\n\n\n   几个常用算法：\n   sort(a.begin(),a.end());对a中的从a.begin( )（包括它）到a.end( )（不包括它）的元素进行从小到大排列\n   reverse(a.begin(),a.end());对a中的从a.begin()（包括它）到a.end( )（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1\n   copy(a.begin(),a.end(),b.begin()+1);把a中的从a.begin( )（包括它）到a.end( )（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素\n    find(a.begin(),a.end(),10);在a中的从a.begin( )（包括它）到a.end( )（不包括它）的元素中查找10，若存在返回其在向量中的位置\n\n\n\">pari&lt;int,int&gt;\nfirst第一个元素\n\nsecond第二个元素\n\n\n\n\n\n\n\n\n\n   支持比较运算，运算规则以first为第一关键字，以second为第二关键字（字典序）\n\n\nstring\nsize()/length() 返回字符串长度\nempty() 返回是否为空\nclear()清空\nsubstr(pos,num)返回从pos开始num个长度的子串\nc_str() 返回字符串所在字符数组的起始地址\nstring.insert(pos,string)从下标pos和pos+1之间插入字符串\nstring.earse(pos,num)从下标pos开始删除num个字符，如果num为空则删除pos后面的所有字符。\n\nqueue\nsize()返回长度\nempty()返回是否为空\npush()向队尾插入一个元素\nfront() 返回对头元素\nback()返回队尾元素\npop()弹出队头元素\n\npriority_queue\n优先队列，默认是大根堆\n\nsize() 返回大小\n\nempty()返回是否为空\n\npush()插入一个元素\n\ntop()返回堆顶元素\n\npop()弹出堆顶元素\n\n\n\n\n\n\n\n\n\n   小根堆定义：\n   priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\n\n\nstack\nsize()返回大小\nempty()返回是否为空\npush() 向栈顶插入一个元素\ntop() 返回栈顶元素\npop() 弹出栈顶元素\n\ndeque\nsize()返回大小\n\nempty()返回是否为空\n\nclear()清空\n\nfront()/back()返回队头元素/队尾元素\n\npush_back()/pop_back()向队尾插入/删除一个元素\n\npush_front()/pop_front()向对头插入/删除一个元素\n\nbegin()/end()/返回队头/队尾的迭代器\n\n\n\n\n\n\n\n\n\n和vector一样支持下标访问\n\n\nset，map\n\n\n\n\n\n\n\n\n   基于平衡二叉树（红黑树），动态维护有序序列\n\nsize() 返回大小\nempty() 返回是否为空\nclear() 清空\nbegin()/end() 返回起始/末尾迭代器\n++,-- 返回前驱和后继，时间复杂度\n\nset/multiset\ninsert()插入一个元素\nfind()查找一个元素，返回该元素的迭代器，找不到则返回end()\ncount()返回某一个元素的个数\nerase() \nerase(x)删除所有值为x的元素，时间复杂度\nearse(pos)删除迭代器为pos的元素\n\n\nower_bound()/upper_bound()\nlower_bound(x)  返回大于等于x的最小的数的迭代器\n`upper_bound(x)`  返回大于x的最小的数的迭代器\n\n\n\n\n\nmap/multimap\ninsert() 插入一个pair元素\n\nearse()输入的参数是pair或者迭代器\n\nfind() 返回key相等的第一个元素，找不到返回end()\n\nlower_bound()/upper_bound()\n\n\n\n\n\n\n\n\n\nmultimap不支持[ ]访问\n\n\nunordered_set，unordered_map，unordered_multiset，unordered_multimap\n\n\n\n\n\n\n\n\n   哈希表，增删改查的时间复杂度是\n   不支持lower_bound()/upper_bound()，迭代器的++,--\nbitset\n\n\n\n\n\n\n\n\n   以二进制保存，不支持++,--\n   支持各种位运算，如：~， &amp;， |， ^，&gt;&gt;， &lt;&lt;，==，!=，[]\n   正数存储的是原码，负数存储的是补码（反码+1）\n\ncount() 返回有多少个 \nany() 判断是否至少有一个 \nnone()判断是否全为 \nset() 把所有位置成 \nset(k,v)将第k为变成v\nreset() 把所有为变成 \nflip()等价于~\nflip(k)把第k位取反\n\n","slug":"STL容器","date":"2022-02-16T09:21:30.340Z","categories_index":"STL","tags_index":"STL容器","author_index":"Snailuu"},{"id":"1df484034a65ae4d42f3134f61bf20af","title":"数据结构模板","content":"单链表\nhead存储表头，e[]存储节点的值,ne[]存储节点的next指针，idx表示当前用到了哪个节点\nint head, e[N], ne[N], idx;\n// 初始化\nvoid init()\n{\n    head = -1;\n    idx = 0;\n}\n// 在链表头插入一个数a\nvoid insert(int a)\n{\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n}\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n{\n    head = ne[head];\n}\n\n\n双链表\ne[]表示节点的值 l[]表示节点的左指针 r[]表示节点的右指针 idx表示当前用到了哪个节点\n\n先将插入点的左右指针修改，再修改左节点指向的节点的左指针，再修改原本左节点的右指针\nint e[N], l[N], r[N], idx;\n// 初始化\nvoid init()\n{\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n{\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n}\n// 删除节点a\nvoid remove(int a)\n{\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n\n\n栈\ntt表示栈顶，初始化为0，如果  表示栈为空\nint stk[N], tt = 0;\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n// 从栈顶弹出一个数\ntt -- ;\n// 栈顶的值\nstk[tt];\n// 判断栈是否为空\nif (tt &gt; 0)\n{\n\n}\n\n普通队列\nhh 表示对头，tt表示队尾，如果  表示队列为空\nint q[N], hh = 0, tt = -1;\n// 向队尾插入一个数\nq[ ++ tt] = x;\n// 从队头弹出一个数\nhh ++ ;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh &lt;= tt)\n{\n\n}\n\n循环队列\nhh 表示对头，tt 表示队尾的后一个位置，如果  表示队列为空\nint q[N], hh = 0, tt = 0;\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh != tt)\n{\n\n}\n\n单调栈\n从栈顶到栈底的元素是严格递增（or递减）\n\n常见模型：找出每个数左边离它最近的比它大/小的数，也可以说是求数组每个数的往左第一个比他小的数，或往右第一个比他小的数\nint tt = 0;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n}\n\n例题：单调栈\n\n\n单调队列\n从队列头到队列尾的元素是严格递增\n\n常见模型：找出滑动窗口中的最大值/最小值\nint hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++ )\n{\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] = i;\n}\n例题：滑动窗口\n\n\nKMP\ns[] 是母串 p[]是子串 n是 s的长度， m是p的长度，next[]是前缀后缀相同数组\n\n下标从1开始\n//求子串的Next数组\nfor (int i = 2, j = 0; i &lt;= m; i ++)\n{\n    //如果两个字符不一样就跳转到它前一位下标所指向的位置\n    while (j &amp;&amp; p[i] != p[j]) j = Next[j];\n    if (s[i] == s[j+1]) j++;\n    Next[i] = j;\n}\n//匹配过程\nfor (int i = 1, j = 0; i &lt;= n; i ++)\n{\n\twhile (j &amp;&amp; s[i] != p[j+1]) j = ne[j];\n    if (s[i] == p[j+1]) j++;\n    if (j == m) j=ne[j-];//匹配成功了继续往后寻找是否还存在\n}\n\n例题：KMP\n\n\n求解循环节//下标从1开始的话,len-1\nlen--;\nint l=len-ne[len];\nif(len%l==0) printf(\"%d\\n\",len/l);\nelse printf(\"1\\n\");\n\n\n\nTrie树/字典树\n应用场景：字符串检索、词频统计、字符串排序、前缀匹配\n\nson[][]存储树种每个节点的子节点cnt[]存储以每个节点结尾的单词数量，0号点既是根节点，又是空节点\nint son[N][26], cnt[N], idx;\n//插入一个字符串\nvoid insert(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            son[p][u] = ++idx; //如果没有出现过就创建一个新节点\n        p = son[p][u];\n    }\n    cnt[p]++; //以当前字符结尾的单词数量\n}\nvoid insert(char *str) //利用取址符\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int &amp;s = son[p][str[i] - 'a'];\n        if (!s)\n            s = ++idx;\n        p = s;\n    }\n    cnt[p]++;\n}\n//查询字符串出现的次数\nint query_num(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}\n\n例题：字符串统计、最大异或对\n\n\n并查集朴素并查集\np[]存储每个节点的祖宗节点\nint p[N];\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]); //路径压缩，每个点直接存最祖先\n    return p[x];\n}\nfor (int i = 1; i &lt;= n; i++) p[i] = i;\n//合并a和b所在的两个集合\np[find(a)] = find(b);\n\n例题：合并集合\n\n\n维护集合数量\np[]储存每个点的祖宗节点，num[] 只有祖宗节点才有意义，表示祖宗节点所在集合中的点的数量\nint p[N], num[N];\nfor (int i = 1; i &lt;= n; i++) p[i] = i, num[i] = 1;\nwhile (k--) //操作次数\n{\n      int a, b;\n      cin &gt;&gt; a &gt;&gt; b;\n      int k1 = find(a), k2 = find(b);\n      if (k1 != k2)\n      {\n            num[k2] += num[k1]; //把k1所在集合的点数全部加到k2集合中\n            p[k1] = k2;         //将k1的祖宗节点更改为k2\n      }\n}\n\n例题：联通块中点的数量\n\n\n维护到祖宗节点距离\np[]存储每个点的祖宗节点，d[]存储x到p[x](该点的祖宗节点)的距离\n// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x)\n    {\n       int u = find(p[x]);\n       d[x] += d[p[x]];\n       p[x] = u;\n    }\n   return p[x];\n}\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i &lt;= n; i++)\n{\n    p[i] = i;\n    d[i] = 0;\n}\n// 合并a和b所在的两个集合：\np[find(a)] = find(b);\nd[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n\n询问每次删点后联通块\n\n\n\n\n\n\n\n\n   大意：一开始有  个点，给定  条边，询问  次炸毁、每次一个点被炸毁后剩余联通块\n\n一开始先将每个点都读入建双向边\nfor (int i = 1; i &lt;= m; i++) {\n        int x, y; cin &gt;&gt; x &gt;&gt; y;\n        add(x, y), add(y, x);\n    }\n\n将每次炸毁的点标记起来\nfor(int i=0;i&lt;k;i++){\n        cin&gt;&gt;a[i];vis[a[i]]=1;\n    }\n\n先寻找一开始还没被炸毁的点所能构成的最大联通块数量\nfor(int i=0;i&lt;n;i++){\n        if(!vis[i]){\n            cnt++;\n            dfs(i);//遍历所有与i相关的边,如果没被炸毁的就合并集合\n        }\n    }\n    ans[k]=cnt;\n\n最后从后往前依次将摧毁的点标记取消，不断进行集合合并\nmemset(vis,0,sizeof vis);\n    for(int i=0;i&lt;k;i++) vis[a[i]]=1;\n    for(int i=k-1;i&gt;=0;i--){\n        vis[a[i]]=0;\n        cnt++;\n        for(int j=h[a[i]];j!=-1;j=ne[j]){\n            int jj=e[j];\n            if(!vis[jj]){\n                int f1=find(a[i]),f2=find(jj);\n                if(f1!=f2){\n                    p[f2]=f1;\n                    cnt--;\n                }\n            }\n        }\n        ans[i]=cnt;\n    }\n\n例题:星球大战\ncode:\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N = 4e5 + 10;\nint h[N &lt;&lt; 1], ne[N &lt;&lt; 1], e[N &lt;&lt; 1], idx;\nvoid add(int a, int b) {\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nint p[N], ans[N], st[N], vis[N], bk[N],a[N];\nint n, m, k;\n\nint find(int x) {\n    if (p[x] != x)p[x] = find(p[x]);\n    return p[x];\n}\n\nvoid dfs(int x){\n    vis[x]=1;\n    for(int i=h[x];i!=-1;i=ne[i]){\n        int j=e[i];\n        if(!vis[j]){\n            int f1=find(x),f2=find(j);\n            if(f1!=f2) p[f1]=f2;\n            dfs(j);\n        }\n    }\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    memset(st, 0, sizeof st);\n    memset(vis, 0, sizeof vis);\n    for (int i = 0; i &lt; n; i++) p[i] = i;\n    for (int i = 1; i &lt;= m; i++) {\n        int x, y; cin &gt;&gt; x &gt;&gt; y;\n        add(x, y), add(y, x);\n    }\n    cin &gt;&gt; k;\n    for(int i=0;i&lt;k;i++){\n        cin&gt;&gt;a[i];vis[a[i]]=1;\n    }\n    int cnt=0;\n    for(int i=0;i&lt;n;i++){\n        if(!vis[i]){\n            cnt++;\n            dfs(i);\n        }\n    }\n    ans[k]=cnt;\n    memset(vis,0,sizeof vis);\n    for(int i=0;i&lt;k;i++) vis[a[i]]=1;\n    for(int i=k-1;i&gt;=0;i--){\n        vis[a[i]]=0;\n        cnt++;\n        for(int j=h[a[i]];j!=-1;j=ne[j]){\n            int jj=e[j];\n            if(!vis[jj]){\n                int f1=find(a[i]),f2=find(jj);\n                if(f1!=f2){\n                    p[f2]=f1;\n                    cnt--;\n                }\n            }\n        }\n        ans[i]=cnt;\n    }\n    for (int i = 0; i &lt;= k ; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;\n    return 0;\n}\n\n\n\n堆\nh[N]存储堆中的值，h[1]是堆顶，[x]的左儿子是2x，右儿子是2x+1\n\nph[k] 存储第k个插入的点在堆中的位置，hp[k]存储堆中下标是k的点是第几个插入的\n\n大根堆符合父亲  儿子，小根堆符合父亲  儿子\nint h[N], ph[N], hp[N], size;\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n//向下调整\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)\n    {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n//向上调整\nvoid up(int u)\n{\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])\n    {\n        heap_swap(u, u / 2);\n        u &gt;&gt;= 1;\n    }\n}\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);\n\n一般哈希拉链法\n核心：如果有两个哈希值一样的值则将他们用链表方式链接在这个哈希值位置\nint h[N], e[N], ne[N], idx;\n// 向哈希表中插入一个数\nvoid insert(int x)\n{\n    int k = (x % N + N) % N;\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx ++ ;\n}\n// 在哈希表中查询某个数是否存在\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i])\n        if (e[i] == x)\n            return true;\n    return false;\n}\n\n开放寻址法\n核心：如果当前哈希值位置被占领，则挪向下一个没有被占用的位置（上厕所）\nint h[N];\n// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\nint find(int x)\n{\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x)\n    {\n        t ++ ;\n        if (t == N) t = 0;\n    }\n    return t;\n}\n\n字符串哈希\n核心：将字符串看成是P进制数，P的取值通常为131或者13331\n\n技巧：取模的数用，这样子直接用unsigned long long 存储，溢出的结果就是取模的结果\n\n应用：判别字符串是否相同\ntypedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n}\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}\n\n例题：字符串哈希\n\n\n","slug":"数据结构模板","date":"2022-02-16T06:09:33.395Z","categories_index":"数据结构,模板","tags_index":"模板,数据结构","author_index":"Snailuu"},{"id":"768c5d200987ad0ffa01337632098c22","title":"回文字符串","content":"最长回文子序列\n最长回文子序列 LPS（Longest Palindromic Subsequence）\n\n状态表示：表示从  到  序列的最长回文子序列\n\n      \n\n      \n\n代码\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\n//动态规划求解最长回文子序列，时间复杂度为O(n^2)\nint lis_hw(char *str, int n)\n{\n    int dp[10][10], tmp;\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i &lt; n; ++i)\n        dp[i][i] = 1;\n\n    for (int i = 1; i &lt; n; ++i)\n    {\n        tmp = 0;\n        //考虑所有连续的长度为i+1的子串，str[j....j+i]\n        for (int j = 0; j + i &lt; n; j++)\n        {\n            //如果首尾相同\n            if (str[j] == str[j + i])\n                tmp = dp[j + 1][j + i - 1] + 2;\n            //如果首尾不同\n            else\n                tmp = max(dp[j + 1][j + i], dp[j][j + i - 1]);\n            dp[j][j + i] = tmp;\n        }\n    }\n    return dp[0][n - 1]; //返回字符串str[0...n-1]的最长回文子序列长度\n}\n\nint main()\n{\n    char str[10] = \"cabbeaf\";\n    int res = lpsDp(str, strlen(str));\n    cout &lt;&lt; res &lt;&lt; endl;\n    getchar();\n    return 0;\n}\n\n\n最长回文子序列长度\n\n状态表示：表示从  到  之间最长的回文字符串长度\n\n\n\n由于需要如果首尾字符相同，需要用到    和  所以 要递减枚举，  要递增枚举\n\n代码：\n   int lis_hw_len(string a)\n{\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n)); //开辟一个n*n的空间\n    for (int i = n - 1; i &gt;= 0; i--)\n    {\n        dp[i][i] = 1;\n        for (int j = 0; j &lt; n; j++)\n        {\n            if (a[i] == a[j])\n                dp[i][j] = dp[i + 1][j - 1] + 2;//如果首尾相同+2\n            else\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);//首尾不同取最大\n        }\n    }\n    return \n        dp[0][n - 1]\n}\n\n\n回文子序列的个数\n\n状态表示：表示第  到第  个字符之间的回文字符串个数。\n\n如果头尾字符不同，由于要用到  和   这两个区间的数量，因此  被计算了两次，所以结果需要再减去  。\n\n如果头尾字符相同，就只需要用到两端点的右侧和左侧的数量相加，最后再+1即可。\nint lis_hw_num(string str)\n{\n    int len = str.length();\n    vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len));\n    for (int j = 0; j &lt; len; j++)\n    {\n        dp[j][j] = 1;\n        for (int i = j - 1; i &gt;= 0; i--)\n        {\n            dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];\n            if (str[i] == str[j])\n                dp[i][j] += 1 + dp[i + 1][j - 1];\n        }\n    }\n    return dp[0][len - 1];\n}\n\n\n\n最长回文子串\n动态规划\n 表示子串 不是回文串，反之则是。\n状态转移：当且仅当   并且   ，反之则.\n\n\n\nManacher算法\n\n\n\n\n\n\n\n\n   在字符串首尾以及每个字符之间插入一个字符#，这样子可以保证字符串长度为奇数\n#include &lt;iostream&gt;  \n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;  \nusing namespace std;\nchar s[20000000+10];\nchar s_new[20000000+10];\nint p[20000000+10];//p[i] 表示以 i 为中心的最长回文的半径\n//使用马拉车之前需要对字符串进行改造 \nint Init()\n{\n    int len = strlen(s);\n    s_new[0] = '$';\n    s_new[1] = '#';\n    int j = 2;\n    for (int i = 0; i &lt; len; i++)\n    {\n        s_new[j++] = s[i];\n        s_new[j++] = '#';\n    }\n    s_new[j++] = '^';  // 别忘了哦\n    return j;  // 返回 s_new 的长度\n}\nint Manacher()\n{\n    int len = Init();  // 取得新字符串长度并完成向 s_new 的转换\n    int max_len = -1;  // 最长回文长度\n    int id;//id为i和j的中心点 i以 id 为对称点翻折到j的位置\n    int mx = 0;// mx 代表以 id 为中心的最长回文的右边界\n    for (int i = 1; i &lt; len; i++)\n    {\n        if (i &lt; mx)//mx 代表以 id 为中心的最长回文的右边界\n            p[i] = min(p[2 * id - i], mx - i); // 2 * id - i 为 i 关于 id 的对称点\n        else \n            p[i] = 1;//超过边界总共就不是回文了\n\n        while (s_new[i - p[i]] == s_new[i + p[i]])  // 不需边界判断，因为左有 $，右有 ^ 二者必不可能相等\n            p[i]++;\n        // 我们每走一步 i，都要和 mx 比较，我们希望 mx 尽可能的远，\n        // 这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率\n        if (mx &lt; i + p[i])//i的位置再加上i对应的回文半径即为最远的边界\n        {\n            id = i;\n            mx = i + p[i];\n        }\n        max_len = max(max_len, p[i] - 1);// p[i]-1 即为原字符串中最长回文串的长度\n    }\n    return max_len;\n}\nint main()\n{\n    scanf(\"%s\", s);\n    cout&lt;&lt;Manacher()&lt;&lt;endl;\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"回文字符串","date":"2022-02-15T03:47:30.314Z","categories_index":"杂题","tags_index":"回文字符串,回文序列","author_index":"Snailuu"},{"id":"321148201d6e624da674378719102cb9","title":"二进制问题","content":"异或OR（半加法）：\n异或符合加法性质（奇偶性）\n\n奇+奇==偶 \n\n奇+偶==奇\n\n偶+偶==偶\n\n偶+奇==奇\n｀｀\n注：奇数-1，偶数+1\n\n\n\n\n\nbitset\nbitset&lt;32&gt;q(n)定义为一个空间大小为，名为，内容为（可以为整数，）\n\nbitset就像普通的整数一样，可以进行与（&amp;）、或（|），异或（^），左移（&lt;&lt;），右移（&gt;&gt;）等操作\n\n对于一个叫做的，可以有以下操作\nq.size() //返回大小（位数）\nq.count() //返回1的个数\nq.any() //返回是否有1\nq.none() //返回是否没有1\nq.set() //全都变成1\nq.set(p) //将第p + 1位变成1\nq.set(p, x) //将第p + 1位变成x\nq.reset() //全都变成0\nq.reset(p) //将第p + 1位变成0\nq.flip() //全都取反\nq.flip(p) //将第p + 1位取反\nq.to_ulong() //返回它转换为unsigned long的结果，如果超出范围则报错\nq.to_ullong() //返回它转换为unsigned long long的结果，如果超出范围则报错\nq.to_string() //返回它转换为string的结果\n\n特别：如果要求一个负数的补码，直接q.flip() 即可。\n\n\n","slug":"二进制","date":"2022-02-14T07:37:34.676Z","categories_index":"二进制","tags_index":"位运算","author_index":"Snailuu"},{"id":"cad29d88a5e84162d8735ff1cbc7e6a8","title":"基础算法模板","content":"归并排序\n确定分界点，\n\n递归排序\n\n归并——合二为一\n\n\nvoid merge_sort(int q[], int l, int r)//q数组从l到r排序\n{\n    if (l &gt;= r) return;//出口\n\n    int mid = l + r &gt;&gt; 1;//分界点\n\n    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//递归排序\n\n    int k = 0, i = l, j = mid + 1;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)//用两个指针分别指向两个有序数组\n        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];//两个数组中较小的数放入新数组中\n        else tmp[k ++ ] = q[j ++ ];\n    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];//当指针还没遍历第一个数组末尾将剩下全部加入新数组\n    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];//当指针还没遍历第二个数组末尾将剩下全部加入新数组\n\n    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];//将新数组的答案覆盖到原数组中\n}\n\n应用：求逆序对数量\n二分算法整数二分bool check(int x) {/* ... */} // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\nint bsearch_1(int l, int r)\n{\n    while (l &lt; r)\n    {\n        int mid = l + r &gt;&gt; 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\nint bsearch_2(int l, int r)\n{\n    while (l &lt; r)\n    {\n        int mid = l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n\n浮点二分bool check(double x) {/* ... */} // 检查x是否满足某种性质\n\ndouble bsearch_3(double l, double r)\n{\n    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求\n    while (r - l &gt; eps)\n    {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n\n\n\n高精度算法高精度加法// C = A + B, A &gt;= 0, B &gt;= 0\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n{\n    if (A.size() &lt; B.size()) return add(B, A);\n\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size(); i ++ )\n    {\n        t += A[i];\n        if (i &lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    }\n\n    if (t) C.push_back(t);\n    return C;\n}\n\n高精度减法// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n{\n    vector&lt;int&gt; C;\n    for (int i = 0, t = 0; i &lt; A.size(); i ++ )\n    {\n        t = A[i] - t;\n        if (i &lt; B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        if (t &lt; 0) t = 1;\n        else t = 0;\n    }\n\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n高精度乘低精度// C = A * b, A &gt;= 0, b &gt;= 0\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n{\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size() || t; i ++ )\n    {\n        if (i &lt; A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    }\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n高精度除以低精度// A / b = C ... r, A &gt;= 0, b &gt; 0\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n{\n    vector&lt;int&gt; C;\n    r = 0;\n    for (int i = A.size() - 1; i &gt;= 0; i -- )\n    {\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    }\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n\n前缀和与差分一维前缀和for (int i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + a[i];\n\nsum[i]表示～之间之和\nsum[r]-sum[l-1]表示～ｒ之间之和\n一维差分b[l] += c, b[r + 1] -= c;\n\n表示从到区间每个数加上，后面做一遍前缀和即可。\n二维前缀和在一维前缀和前提下，将和相加后多了这一部分。\n\nfor (int i = 1; i &lt;= n; i++)\n    sum[i][1] = a[i][1];\nfor (int i = 1; i &lt;= n; i++)\n    sum[1][i] = a[1][i];\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = 1; j &lt;= n; j++)\n        sum[i][j] = sum[i - 1][j] + sum[i][j - 1] + a[i][j] - sum[i - 1][j - 1];\n\n求某一个区域～的总和\n\nint check(int x1, int y1, int x2, int y2)\n{\n    return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];\n}\n\n二维差分\nint change(int x1, int y1, int x2, int y2)\n{\n    s[x1][y1] += c, s[x2 + 1][y2] += c;\n    s[x1][y2 + 1] -= c, s[x2][y1 + 1] -= c;\n}\n\n\n\n\n\n\n\n10010111110111100121011000001111131001000\n","slug":"基础算法模板","date":"2022-02-14T04:49:54.725Z","categories_index":"模板","tags_index":"模板,基础算法","author_index":"Snailuu"},{"id":"32c803d1fefb525b38a8f636ccbac12b","title":"背包问题","content":"\n01背包例题：01背包问题\n\n描述：有  件物品和一个容量为  的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。\n\n\n\n\n\n\n\n\n\n\n   动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 i 个物品的做出决策，「0-1」正好代表不选与选两种决定。\n\n代码实现\n\n二维状态转移方程\n状态f[i][j]定义：前个物品，在容量下的最大价值\n\n\n\n\n\n\n\n\n\n   \n\n一维状态转移方程\n对于二维状态，可以看出第  种状态只由第种状态转移而成，因而可以压成一维(体积记得倒序遍历)\n\n\n\n\n\n\n\n\n\n   \n注：对于体积倒序遍历，因为要用到上次的状态，如果从小到大，用到的将会是本次状态\n\n\n\n\n\n\n\n\n\n   比如:   = 4 ,   =  9,  , \n   二维：  = \n   ​            这里的  和  都来自上一次的状态\n   一维：  \n   ​            这里的  和  也得保证是上一次的状态\n   如果按照顺序更新， \n   往后遍历到的就是本轮的状态而不是上一次的状态了。\n\n核心代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; v[i] &gt;&gt; w[i]; //每个物品占用空间及价值\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= v[i]; j--)\n            f[j] = max(f[j], f[j - v[i]] + w[i]);\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n输入优化版本：不用开两个数组记录体积和价值\nint main()\n{\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int v, w;\n        cin &gt;&gt; v &gt;&gt; w; // 边输入边处理\n        for (int j = m; j &gt;= v; j--)\n            f[j] = max(f[j], f[j - v] + w);\n    }\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n    return 0;\n}\n\n\n\n\n\n\n\n题目推荐：\n\n完全背包例题：完全背包问题\n\n描述：有  种物品和一个容量是  的背包，每种物品都有无限件可用。\n\n代码实现：\n\n朴素版本（时间复杂度)\nfor(int i = 1; i &lt;= n; i ++ )\n        for(int j = 0; j &lt;= m; j ++ )\n            for(int k = 0; k * v[i] &lt;= j; k ++ )\n                f[i][j] = max(f[i][j], [i - 1][j - k * v[i]] + k * w[i]);\n\n优化思路：\n\n\n\n\n\n\n\n\n\n      由上两式，可得出如下递推关系：                       \n因此可以将代码写成：\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = v[i]; j &lt;= m; j++) //注意了，这里的j是从小到大枚举，和01背包不一样\n    {\n        f[j] = max(f[j], f[j - v[i]] + w[i]);\n    }\n\n\n\n题目推荐：\n\n多重背包例题：多重背包\n\n描述：与完全背包的区别就是每种物品有限制\n\n代码实现：\n\n朴素版本：\nfor (int i = 1; i &lt;= n; i++)\n    for (int j = 0; j &lt;= m; j++)\n        for (int k = 0; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)//s[i]表示每种物品最大数量\n            f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);\n\n优化思路：\n\n\n\n\n\n\n\n\n\n   可以分为二进制优化和单调队列优化，这里只做二进制优化解释\n   一个数字可以分成多个数字相加，而这个数字也可以表示为\n   举几个例子：\n\n\n\n\n\n\n   因此在输入的时候就可以将每个物品的数量用二进制的方式储存起来\n代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    int cnt = 0;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        int a, b, s;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;//分别为体积、价值、数量\n        int k = 1;\n        while (k &lt;= s)\n        {\n            cnt++;\n            v[cnt] = a * k;//将每个二进制数量及其体积储存起来\n            w[cnt] = b * k;//将每个二进制数量及其价值储存起来\n            s -= k;\n            k *= 2;\n        }\n        if (s &gt; 0)//s分成2的cnt次幂后所剩下的数\n        {\n            cnt++;\n            v[cnt] = a * s;\n            w[cnt] = b * s;\n        }\n    }\n\n    n = cnt;\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= v[i]; j--)\n            f[j] = max(f[j], f[j - v[i]] + w[i]);//01背包做法\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n\n\n题目推荐：\n\n\n\n\n\n\n\n\n\n   Candies\n   每一个数的状态都可以由前面一种状态得到， 表示第  个数然后总糖果数有  个糖果的分法。\n   本题如果普通三层for枚举会超时。\n   for(int i=1;i&lt;=n;i++)\n    for(int j=1;j&lt;=k;j++)\n        for(int kk=0;kk&lt;=min(a[i],j);kk++)\n            dp[i][j]+=dp[i-1][j-k];\n\n   观察可以知道第三层循环  的状态只能由  转移得来，x&gt;=j-a[i]&amp;&amp;x&lt;=j ，所以可以用前缀和+滑动窗口对其进行优化。\ndp[0][0] = 1;\n    for (int i = 1; i &lt;= n; ++i) {\n        ll sum = 0;\n        for (int j = 0; j &lt;= m; ++j) {\n            sum += dp[i - 1][j];\n            dp[i][j] = (sum + mod) % mod;\n            if (j &gt;= a[i]) sum -= dp[i - 1][j - a[i]];\n        }\n    }\n\n\n分组背包例题：分组背包\n\n描述： 每个组别只能取一种物品，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。\n\n思路：从「在所有物品中选择一件」变成了「从当前组中选择一件」，于是就对每一组进行一次 0-1 背包就可以了。\n\n代码：\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; s[i];//第i组数量\n        for (int j = 0; j &lt; s[i]; j++)\n            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];//第i组第j个物品的体积和价值\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n        for (int j = m; j &gt;= 0; j--)\n            for (int k = 0; k &lt; s[i]; k++)//第i组的每一个进行遍历\n                if (j &gt;= v[i][k])\n                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);//与01背包一样\n\n    cout &lt;&lt; f[m] &lt;&lt; endl;\n\n    return 0;\n}\n\n题目推荐：\n\n二维费用背包例题：P1855 榨取kkksc03\n\n描述：跟01背包问题相似，不同的是选一个物品会消耗两种东西\n\n思路：状态转移方程式基本不变，只需要再开一维数组存储\n\n代码实现：\nint main()\n{\n    int n, M, T;\n    cin &gt;&gt; n &gt;&gt; M &gt;&gt; T;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cin &gt;&gt; m[i] &gt;&gt; t[i];\n        for (int j = M; j &gt;= m[i]; j--)\n            for (int k = T; k &gt;= t[i]; k--)\n                f[j][k] = max(f[j][k], f[j - m[i]][k - t[i]] + 1);//同时减少金钱和时间\n    }\n    cout &lt;&lt; f[M][T];\n    return 0;\n}\n\n题目推荐：\n\n四方定理\n\n\n有依赖的背包例题：P1064 [NOIP2006 提高组] 金明的预算方案\n\n描述：这种背包问题其实就是如果选第   件物品，就必须选第   件物品，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就称不依赖于别的物品的物品称为「主件」，依赖于某主件的物品称为「附件」。\n\n\n\n\n\n\n\n\n\n   对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。\n\n例题解析：\n\n像是01背包的升级版本，就是情况多了几种：\n不买主件\n买主件\n买主件和附件1\n买主件和附件2\n买主件和附件1+附件2\n\n\n状态转移方程式可以写成：\n买主件：\n买主件和附件1：\n买主件和附件2：\n买主件和附件1+附件2：\n\n\n\n\n代码：\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int N = 2e5 + 10;\nint n, m, main_w[N], main_v[N], fu_v[N][3], fu_w[N][3], f[N];\n// n是总金钱,m是总物品,main_w主件物品的重量,main_v主件物品的价值,fu_w附件物品的重量，fu_v附件物品的价值\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1; i &lt;= m; i++)\n    {\n        int q, v, p;\n        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;\n        if (!q)\n        {\n            main_w[i] = v;\n            main_v[i] = v * p; //价值==价格*重要度\n        }\n        else\n        {\n            fu_w[q][0]++;\n            int k = fu_w[q][0];\n            fu_w[q][k] = v;\n            fu_v[q][k] = v * p;\n        }\n    }\n    for (int i = 1; i &lt;= m; i++)\n        for (int j = n; j &gt;= main_w[i]; j--)\n        {\n            f[j] = max(f[j], f[j - main_w[i]] + main_v[i]); //主件\n            if (j &gt;= fu_w[i][1] + main_w[i])//主件+附件1\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][1]] + main_v[i] + fu_v[i][1]);\n            if (j &gt;= fu_w[i][2] + main_w[i]) //主件+附件2\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][2]] + main_v[i] + fu_v[i][2]);\n            if (j &gt;= fu_w[i][1] + fu_w[i][2] + main_w[i]) //主件+附件1+附件2\n                f[j] = max(f[j], f[j - main_w[i] - fu_w[i][1] - fu_w[i][2]] + main_v[i] + fu_v[i][1] + fu_v[i][2]);\n        }\n    cout &lt;&lt; f[n] &lt;&lt; endl;\n    return 0;\n}\n\n背包杂项小优化\n\n\n\n\n\n\n\n\n   根据贪心原理，当费用相同时，只需保留价值最高的；\n   当价值一定时，只需保留费用最低的；\n   当有两件物品  且   的价值大于    的价值并且  的费用小于   的费用是，只需保留 。\n输出方案\n\n\n\n\n\n\n\n\n   用二维数组来记录，path[m][n]， 表示物品（ 物品数 ）， 表示背包状态（ 背包容量 ）\n   比如path[i][j]表示物品  放在了状态为  的背包中。前提条件：path 数组全部为  。\n//记录路径\nfor (int i = 0; i &lt; n; i++)\n    for (int j = V; j &gt;= v[i]; j--)\n        if (f[j] &lt; f[j - v[i]] + w[i])\n        {\n            f[j] = f[j - v[i]] + w[i];\n            path[i][j] = 1; //把装进去的物品标记一下\n        }\n//读取路径\nint i = n - 1, j = V; // V：背包容量。n个物品\nwhile (i &gt;= 0 &amp;&amp; j &gt;= 0)\n{\n    if (path[i][j]) //物品i在j里\n    {\n        printf(\"%d \", i); //把物品i的编号输出\n        j -= v[i];        //读完了物品i，找下一个背包状态\n    }\n    i--;\n}\n\n\n\n求方案数量\n\n\n\n\n\n\n\n\n   对于给定的一个背包容量、物品费用、其他关系等等的问题，求装到一定容量的方案总数。\n   这种问题就是把求最大值换成求和即可。\n   初始条件：dp[0]=1（容量为  也算一种方案，即什么都不装）\n求最优方案总数将01背包里面的数组定义修改，状态为只能放前  个物品的情况下，容量为  的背包“正好装满”所能达到的最大总价值。\n这样修改后每种状态都可以用一个来表示方案总数\n 表示只考虑前个物品时背包体积正好是时的最大价值。\n 表示只考虑前个物品时背包体积正好是时的方案数。\n\n\n\n\n\n\n\n\n\n   转移方程：\n\n如果且说明我们此时不选择把物品放入背包更优，方案数由 转移过来。\n如果且说明我们此时不选择把物品放入背包更优，方案数由 转移过来。\n如果且说明放入或者不放入都能取得最优解，方案数由 转移过来。\n\n//初始条件\nmemset(f, 0x3f3f, sizeof(f));  // 避免没有装满而进行了转移\nf[0] = 0;\ng[0] = 1;  // 什么都不装是一种方案\n//////////////////////////////////////\nfor (int i = 0; i &lt; N; i++)\n{\n    for (int j = V; j &gt;= v[i]; j--)\n    {\n        int tmp = max(dp[j], dp[j - v[i]] + w[i]);\n        int c = 0;\n        if (tmp == dp[j])\n            c += cnt[j]; // 如果从dp[j]转移\n        if (tmp == dp[j - v[i]] + w[i])\n            c += cnt[j - v[i]]; // 如果从dp[j-v[i]]转移\n        dp[j] = tmp;\n        cnt[j] = c;\n    }\n}\nint max = 0; // 寻找最优解\nfor (int i = 0; i &lt;= V; i++)\n{\n    max = max(max, dp[i]);\n}\nint res = 0;\nfor (int i = 0; i &lt;= V; i++)\n{\n    if (dp[i] == max)\n    {\n        res += cnt[i]; // 求和最优解方案数\n    }\n}\n\n\n\n","slug":"背包问题","date":"2022-02-13T12:09:32.829Z","categories_index":"动态规划","tags_index":"动态规划","author_index":"Snailuu"},{"id":"f83333b56248d745b141d3885b656c81","title":"最小生成树","content":"假设表示图中点数，表示图中边数\n朴素版Prim算法（适用于稠密图，复杂度O())思路：将条边到另一条边的距离初始化成从遍历到找到集合外距离最小的点标记为，用来更新它到集合的距离，标记一下\n例题：Prim算法求最小生成树\n核心代码：\n// st[i] 表示点i是否在当前生成树集合中\n// dist[i] 表示点i到当前集合的最短边的长度\n// g[i][j] 表示点i和点j之间边的长度\n// 返回值：最小生成树中所有边的总长度\nint prim()\n{\n    memset(dist, 0x3f, sizeof(dist));\n    int res = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) //第一次找到或者找到更小的\n                t = j;\n        if (i &amp;&amp; dist[t] == INF)\n            return INF; //无法生成最小树\n        if (i)\n            res += dist[t];\n        st[t] = 1;\n        for (int j = 1; j &lt;= n; j++) //更新t所有连接点\n            dist[j] = min(dist[j], g[t][j]);\n    }\n    return res;\n}\n\n\n\nKruskal算法（适用于稀疏图，复杂度O())思路：将所有边权按小到大排序，从小到大挑不多余的边\n代码实现：\nstruct Edge\n{ //用结构体储存点a到b的边权w\n    int a, b, w;\n    bool operator&lt;(const Edge &amp;W) const\n    {\n        return w &lt; W.w;\n    }\n} edge[M];\nint find(int x)\n{\n    if (p[x] != x)\n        p[x] = find(p[x]);\n    return p[x];\n}\nint kruskal()\n{\n    sort(edge, edge + m);\n    for (int i = 1; i &lt;= n; i++)\n        p[i] = i; //初始化并查集\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i++)\n    {\n        int a = edge[i].a, b = edge[i].b, w = edge[i].w;\n        a = find(a), b = find(b);\n        if (a != b) //如果两个联通块不连通，将这两个联通块合并\n        {\n            p[a] = b;\n            res += w; //最小生成树的边权和\n            cnt++;    //加入点的数量\n        }\n    }\n    if (cnt &lt; n - 1)\n        return INF;\n    return res;\n}\n\n","slug":"最小生成树","date":"2022-02-13T07:22:11.269Z","categories_index":"图论","tags_index":"图论,生成树","author_index":"Snailuu"},{"id":"01d132f13ac67dff21350f57c338a855","title":"拓扑排序","content":"拓扑排序应用场景在做某些事的时候他们之间有前后关系（顺序关系或者依赖关系），比如安排座位，穿衣服先后，课程学习等等。\n拓扑排序只对于有向无环图而言(Directed Acyclic Graph简称DAG)\n\n\n\n\n\n\n\n\n\n   如果有a,b,c,d等件事情，a的优先级最高，d的优先级最低，那么abcd或者acbd都是可行的排序。\n基于BFS的拓扑排序\n无前驱的顶点优先\n\n将入度为零的点入队\n\n访问对头所有的邻接点，并将其入度减，如果此时的入度为就将其入队\n\n当队列为空时，如果还有点从未进入队列中，说明这个图不是DAG，不存在拓扑排序。\n反之如果全部进过队列了，队列依次输出的就是拓扑排序。\n\n\n\n\n部分代码：\nvoid topsort()\n{\n    for (int i = 1; i &lt;= n; i++)\n        if (!in[i])\n            num[i] = 1, q.push(i);\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i]; //枚举当前队头的所有邻接点\n            in[j]--;      //减少入度\n            if (!in[j])\n                q.push(j); //如果入度为0就入队\n        }\n    }\n}\n\n\n\n无后继的顶点优先\n就是无前去顶点优先的逆过程，将入度为改成出度为的点入队，后面情况跟前面的一样，最后队列输出的是拓扑排序的逆序。\n\n\n\n注意：如果有要求要字典序输出，将队列弄成一个优先队列，依据题意建大根堆或者小根堆。\n例题Codeforces Round #285 (Div. 2)C. Misha and Forest","slug":"拓扑排序","date":"2022-02-13T07:19:11.215Z","categories_index":"图论","tags_index":"图论,排序","author_index":"Snailuu"},{"id":"60a84708f3c49aa5488e16601f40a652","title":"算法选择","content":"数据范围推断算法选择\n\n\n数据范围\n时间复杂度\n算法\n\n\n\n\n指数级别\ndfs+剪枝，状态压缩dp\n\n\n\n\nfloyd，dp，高斯消元\n\n\n\n，\ndp，二分，朴素版Dijkstra，朴素版Prim，Bellman-Ford\n\n\n\n\n块状链表，分块，莫队\n\n\n\n\n各种sort，线段树，树状数组，set/map，heap，拓扑排序，dijkstra+heap，prim+heap，kruskal，spfa，求凸包，求平面交，二分，CDQ分治，整体二分，后缀数组，树链部分，动态树\n\n\n\n及常数较小的的算法\n单调队列，hash，双指针扫描，并查集，kmp，AC自动机，sort，树状数组，heap，dijkstra，spfa\n\n\n\n\n双指针扫描，kmp，AC自动机，线性筛素数\n\n\n\n\n判断质数\n\n\n\n\n最大公约数，快速幂，数位DP\n\n\n\n\n高精度加减乘除\n\n\n\n，k表示位数\n高精度加减，FFT/NTT\n\n\n\n图论中算法选择\n\n\n\n\n\n\n\n\n   一个图中，顶点数记为n，边数记为m\n   当m时，称之为稀疏图\n   当m相对比较大时，称之为稠密图\n\n\n\n","slug":"算法选择","date":"2022-02-13T07:09:10.466Z","categories_index":"数据范围","tags_index":"算法选择","author_index":"Snailuu"}]