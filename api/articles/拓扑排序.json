{"title":"拓扑排序","uid":"01d132f13ac67dff21350f57c338a855","slug":"拓扑排序","date":"2022-02-13T07:19:11.215Z","updated":"2022-02-16T13:20:10.835Z","comments":true,"path":"api/articles/拓扑排序.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62091b702ab3f51d91da51dd.jpg","content":"<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>在做某些事的时候他们之间有前后关系（顺序关系或者依赖关系），比如安排座位，穿衣服先后，课程学习等等。</p>\n<p>拓扑排序只对于<strong>有向无环图</strong>而言(Directed Acyclic Graph简称<strong>DAG</strong>)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>   如果有a,b,c,d等件事情，a的优先级最高，d的优先级最低，那么abcd或者acbd都是可行的排序。</p></blockquote>\n<h4 id=\"基于BFS的拓扑排序\"><a href=\"#基于BFS的拓扑排序\" class=\"headerlink\" title=\"基于BFS的拓扑排序\"></a>基于BFS的拓扑排序</h4><ol>\n<li><p>无前驱的顶点优先</p>\n<ol>\n<li><p>将入度为零的点入队</p>\n</li>\n<li><p>访问对头<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"0.817ex\" height=\"1.441ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -626 361 637\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g></g></svg></mjx-container>所有的邻接点<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.462ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"0.932ex\" height=\"1.957ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -661 412 865\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g></g></svg></mjx-container>，并将其入度减<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.131ex\" height=\"1.507ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 500 666\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g></g></g></svg></mjx-container>，如果此时<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.462ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"0.932ex\" height=\"1.957ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -661 412 865\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g></g></svg></mjx-container>的入度为<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.05ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.131ex\" height=\"1.557ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 500 688\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></svg></mjx-container>就将其入队</p>\n</li>\n<li><p>当队列为空时，如果还有点<strong>从未进入队列中</strong>，说明这个图不是DAG，<strong>不存在拓扑排序</strong>。</p>\n<p>反之如果全部进过队列了，队列依次输出的就是拓扑排序。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><strong>部分代码：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void topsort()\n{\n    for (int i = 1; i &lt;= n; i++)\n        if (!in[i])\n            num[i] = 1, q.push(i);\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i]; //枚举当前队头的所有邻接点\n            in[j]--;      //减少入度\n            if (!in[j])\n                q.push(j); //如果入度为0就入队\n        }\n    }\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://pic.imgdb.cn/item/61ff3f382ab3f51d915d9ddf.jpg\" alt=\"无前驱顶点优先\"></p>\n<ol start=\"2\">\n<li><p>无后继的顶点优先</p>\n<p>就是无前去顶点优先的逆过程，将入度为<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.05ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.131ex\" height=\"1.557ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 500 688\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></svg></mjx-container>改成出度为<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.05ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.131ex\" height=\"1.557ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 500 688\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></svg></mjx-container>的点入队，后面情况跟前面的一样，最后队列输出的是拓扑排序的逆序。</p>\n</li>\n</ol>\n<p><img src=\"https://pic.imgdb.cn/item/61ff3f8b2ab3f51d915df0d3.jpg\" alt=\"无后继顶点优先\"></p>\n<p><strong>注意：</strong>如果有要求要字典序输出，将队列弄成一个优先队列，依据题意建大根堆或者小根堆。</p>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><h4 id=\"Codeforces-Round-285-Div-2-C-Misha-and-Forest\"><a href=\"#Codeforces-Round-285-Div-2-C-Misha-and-Forest\" class=\"headerlink\" title=\"Codeforces Round #285 (Div. 2)C. Misha and Forest\"></a><a href=\"https://snailuu.github.io/post/Misha%20and%20Forest\">Codeforces Round #285 (Div. 2)C. Misha and Forest</a></h4>","feature":false,"text":"拓扑排序应用场景在做某些事的时候他们之间有前后关系（顺序关系或者依赖关系），比如安排座位，穿衣服先后，课程学习等等。 拓扑排序只对于有向无环图而言(Directed Acyclic Graph简称DAG) 如果有a,b,c,d等件事情，a的优先级最高，d的优先级最低，那么abcd...","link":"","photos":[],"count_time":{"symbolsCount":865,"symbolsTime":"1 mins."},"categories":[{"name":"图论","slug":"图论","count":3,"path":"api/categories/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"排序","slug":"排序","count":1,"path":"api/tags/排序.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">拓扑排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">应用场景</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8EBFS%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">基于BFS的拓扑排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Codeforces-Round-285-Div-2-C-Misha-and-Forest\"><span class=\"toc-text\">Codeforces Round #285 (Div. 2)C. Misha and Forest</span></a></li></ol></li></ol></li></ol>","author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"最小生成树","uid":"f83333b56248d745b141d3885b656c81","slug":"最小生成树","date":"2022-02-13T07:22:11.269Z","updated":"2022-02-16T03:02:44.803Z","comments":true,"path":"api/articles/最小生成树.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62091b402ab3f51d91da1db3.jpg","text":"假设表示图中点数，表示图中边数 朴素版Prim算法（适用于稠密图，复杂度O())思路：将条边到另一条边的距离初始化成从遍历到找到集合外距离最小的点标记为，用来更新它到集合的距离，标记一下 例题：Prim算法求最小生成树 核心代码： // st[i] 表示点i是否在当前生成树集合中...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"图论","slug":"图论","count":3,"path":"api/categories/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":3,"path":"api/tags/图论.json"},{"name":"生成树","slug":"生成树","count":1,"path":"api/tags/生成树.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{}}