{"title":"数据结构模板","uid":"1df484034a65ae4d42f3134f61bf20af","slug":"数据结构模板","date":"2022-02-16T06:09:33.395Z","updated":"2022-02-16T08:34:10.633Z","comments":true,"path":"api/articles/数据结构模板.json","keywords":null,"cover":"https://pic.imgdb.cn/item/620c96192ab3f51d91d60f3a.jpg","content":"<h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2><ul>\n<li><p><code>head</code>存储表头，<code>e[]</code>存储节点的值,<code>ne[]</code>存储节点的next指针，<code>idx</code>表示当前用到了哪个节点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int head, e[N], ne[N], idx;\n// 初始化\nvoid init()\n{\n    head = -1;\n    idx = 0;\n}\n// 在链表头插入一个数a\nvoid insert(int a)\n{\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n}\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n{\n    head = ne[head];\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><ul>\n<li><p><code>e[]</code>表示节点的值 <code>l[]</code>表示节点的左指针 <code>r[]</code>表示节点的右指针 <code>idx</code>表示当前用到了哪个节点</p>\n</li>\n<li><p>先将插入点的左右指针修改，再修改左节点指向的节点的左指针，再修改原本左节点的右指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int e[N], l[N], r[N], idx;\n// 初始化\nvoid init()\n{\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n{\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n}\n// 删除节点a\nvoid remove(int a)\n{\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><p><code>tt</code>表示栈顶，初始化为0，如果 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.782ex\" height=\"1.819ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 2555.6 804\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(361,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(999.8,0)\"><path data-c=\"2264\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(2055.6,0)\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container> 表示栈为空</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int stk[N], tt = 0;\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n// 从栈顶弹出一个数\ntt -- ;\n// 栈顶的值\nstk[tt];\n// 判断栈是否为空\nif (tt &gt; 0)\n{\n\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"普通队列\"><a href=\"#普通队列\" class=\"headerlink\" title=\"普通队列\"></a>普通队列</h2><ul>\n<li><p><code>hh</code> 表示对头，<code>tt</code>表示队尾，如果 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"7.257ex\" height=\"1.882ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 3207.6 832\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(576,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1429.8,0)\"><path data-c=\"2264\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2485.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2846.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g></g></svg></mjx-container> 表示队列为空</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int q[N], hh = 0, tt = -1;\n// 向队尾插入一个数\nq[ ++ tt] = x;\n// 从队头弹出一个数\nhh ++ ;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh &lt;= tt)\n{\n\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><ul>\n<li><p><code>hh</code> 表示对头，<code>tt</code> 表示队尾的后一个位置，如果 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"7.886ex\" height=\"1.805ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -716 3485.6 798\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(576,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1152,0)\"><path data-c=\"21\" d=\"M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1707.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2763.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3124.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g></g></svg></mjx-container> 表示队列为空</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int q[N], hh = 0, tt = 0;\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh != tt)\n{\n\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><ul>\n<li><p><strong>从栈顶到栈底的元素是严格递增（or递减）</strong></p>\n</li>\n<li><p><strong>常见模型：</strong>找出每个数左边离它<strong>最近的比它大/小的数</strong>，也可以说是求数组每个数的<strong>往左第一个比他小的数</strong>，或<strong>往右第一个比他小的数</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int tt = 0;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/description/832/\">单调栈</a></p>\n</li>\n</ul>\n<h2 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h2><ul>\n<li><p><strong>从队列头到队列尾的元素是严格递增</strong></p>\n</li>\n<li><p><strong>常见模型：</strong>找出滑动窗口中的<em>最大值</em>/<em>最小值</em></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++ )\n{\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] = i;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/156/\">滑动窗口</a></p>\n</li>\n</ul>\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><ul>\n<li><p><code>s[]</code> 是母串 <code>p[]</code>是子串 <code>n</code>是 <code>s</code>的长度， <code>m</code>是<code>p</code>的长度，<code>next[]</code>是前缀后缀相同数组</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">//求子串的Next数组\nfor (int i = 1, j = 0; i &lt; m; i ++)\n{\n    //如果两个字符不一样就跳转到它前一位下标所指向的位置\n    while (j &amp;&amp; p[i] != p[j]) j = Next[j-1];\n    if (s[i] == s[j]) j++;\n    Next[i] = j;\n}\n//匹配过程\nfor (int i = 0, j = 0; i &lt;= n; i ++)\n{\n\twhile (j &amp;&amp; s[i] != p[j]) j = ne[j-1];\n    if (s[i] == p[j+1]) j++;\n    if (j == m) j=ne[j-1];//匹配成功了继续往后寻找是否还存在\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/833/\">KMP</a></p>\n</li>\n</ul>\n<h2 id=\"Trie树-x2F-字典树\"><a href=\"#Trie树-x2F-字典树\" class=\"headerlink\" title=\"Trie树/字典树\"></a>Trie树/字典树</h2><ul>\n<li><p><strong>应用场景：</strong>字符串检索、词频统计、字符串排序、前缀匹配</p>\n</li>\n<li><p><code>son[][]</code>存储树种每个节点的子节点<code>cnt[]</code>存储以每个节点结尾的单词数量，<code>0号</code>点既是根节点，又是空节点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int son[N][26], cnt[N], idx;\n//插入一个字符串\nvoid insert(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            son[p][u] = ++idx; //如果没有出现过就创建一个新节点\n        p = son[p][u];\n    }\n    cnt[p]++; //以当前字符结尾的单词数量\n}\nvoid insert(char *str) //利用取址符\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int &amp;s = son[p][str[i] - 'a'];\n        if (!s)\n            s = ++idx;\n        p = s;\n    }\n    cnt[p]++;\n}\n//查询字符串出现的次数\nint query_num(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/837/\">字符串统计</a>、<a href=\"https://www.acwing.com/problem/content/145/\">最大异或对</a></p>\n</li>\n</ul>\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><h3 id=\"朴素并查集\"><a href=\"#朴素并查集\" class=\"headerlink\" title=\"朴素并查集\"></a>朴素并查集</h3><ul>\n<li><p><code>p[]</code>存储每个节点的祖宗节点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int p[N];\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]); //路径压缩，每个点直接存最祖先\n    return p[x];\n}\nfor (int i = 1; i &lt;= n; i++) p[i] = i;\n//合并a和b所在的两个集合\np[find(a)] = find(b);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"维护集合数量\"><a href=\"#维护集合数量\" class=\"headerlink\" title=\"维护集合数量\"></a>维护集合数量</h3><ul>\n<li><p><code>p[]</code>储存每个点的祖宗节点，<code>num[]</code> 只有<strong>祖宗节点</strong>才有意义，表示祖宗节点所在集合中的点的数量</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int p[N], num[N];\nfor (int i = 1; i &lt;= n; i++) p[i] = i, num[i] = 1;\nwhile (k--) //操作次数\n{\n      int a, b;\n      cin &gt;&gt; a &gt;&gt; b;\n      int k1 = find(a), k2 = find(b);\n      if (k1 != k2)\n      {\n            num[k2] += num[k1]; //把k1所在集合的点数全部加到k2集合中\n            p[k1] = k2;         //将k1的祖宗节点更改为k2\n      }\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"维护到祖宗节点距离\"><a href=\"#维护到祖宗节点距离\" class=\"headerlink\" title=\"维护到祖宗节点距离\"></a>维护到祖宗节点距离</h3><ul>\n<li><p><code>p[]</code>存储每个点的祖宗节点，<code>d[]</code>存储<code>x</code>到<code>p[x](该点的祖宗节点)</code>的距离</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x)\n    {\n       int u = find(p[x]);\n       d[x] += d[p[x]];\n       p[x] = u;\n    }\n   return p[x];\n}\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i &lt;= n; i++)\n{\n    p[i] = i;\n    d[i] = 0;\n}\n// 合并a和b所在的两个集合：\np[find(a)] = find(b);\nd[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/838/\">合并集合</a>、<a href=\"https://www.acwing.com/problem/content/839/\">联通块中点的数量</a></p>\n</li>\n</ul>\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li><p><code>h[N]</code>存储堆中的值，<code>h[1]</code>是堆顶，<code>[x]</code>的左儿子是<code>2x</code>，右儿子是<code>2x+1</code></p>\n</li>\n<li><p><code>ph[k]</code> 存储第<code>k</code>个插入的点在堆中的位置，<code>hp[k]</code>存储堆中下标是<code>k</code>的点是第几个插入的</p>\n</li>\n<li><p><code>大根堆</code>符合父亲 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.76ex\" height=\"1.751ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -636 778 774\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"2265\" d=\"M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g></g></g></svg></mjx-container> 儿子，<code>小根堆</code>符合父亲 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.76ex\" height=\"1.751ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -636 778 774\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"2264\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g></g></g></svg></mjx-container> 儿子</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int h[N], ph[N], hp[N], size;\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n//向下调整\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)\n    {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n//向上调整\nvoid up(int u)\n{\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])\n    {\n        heap_swap(u, u / 2);\n        u &gt;&gt;= 1;\n    }\n}\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"一般哈希\"><a href=\"#一般哈希\" class=\"headerlink\" title=\"一般哈希\"></a>一般哈希</h2><h3 id=\"拉链法\"><a href=\"#拉链法\" class=\"headerlink\" title=\"拉链法\"></a>拉链法</h3><ul>\n<li><p><strong>核心：</strong>如果有两个哈希值一样的值则将他们用链表方式链接在这个哈希值位置</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int h[N], e[N], ne[N], idx;\n// 向哈希表中插入一个数\nvoid insert(int x)\n{\n    int k = (x % N + N) % N;\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx ++ ;\n}\n// 在哈希表中查询某个数是否存在\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i])\n        if (e[i] == x)\n            return true;\n    return false;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"开放寻址法\"><a href=\"#开放寻址法\" class=\"headerlink\" title=\"开放寻址法\"></a>开放寻址法</h3><ul>\n<li><p><strong>核心：</strong>如果当前哈希值位置被占领，则挪向下一个没有被占用的位置（上厕所）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int h[N];\n// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\nint find(int x)\n{\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x)\n    {\n        t ++ ;\n        if (t == N) t = 0;\n    }\n    return t;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"字符串哈希\"><a href=\"#字符串哈希\" class=\"headerlink\" title=\"字符串哈希\"></a>字符串哈希</h2><ul>\n<li><p><strong>核心：</strong>将字符串看成是<code>P</code>进制数，<code>P</code>的取值通常为<code>131</code>或者<code>13331</code></p>\n</li>\n<li><p><strong>技巧：</strong>取模的数用<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.919ex\" height=\"1.904ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -841.7 1290.1 841.7\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(533,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mn\"><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\"></path><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\" transform=\"translate(500,0)\"></path></g></g></g></g></g></svg></mjx-container>，这样子直接用<code>unsigned long long </code>存储，溢出的结果就是取模的结果</p>\n</li>\n<li><p><strong>应用：</strong>判别字符串是否相同</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n}\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/843/\">字符串哈希</a></p>\n</li>\n</ul>\n","feature":false,"text":"单链表 head存储表头，e[]存储节点的值,ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a v...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"模板","slug":"模板","count":3,"path":"api/categories/模板.json"}],"tags":[{"name":"模板","slug":"模板","count":2,"path":"api/tags/模板.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97\"><span class=\"toc-text\">普通队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">循环队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88\"><span class=\"toc-text\">单调栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\"><span class=\"toc-text\">单调队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP\"><span class=\"toc-text\">KMP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91-x2F-%E5%AD%97%E5%85%B8%E6%A0%91\"><span class=\"toc-text\">Trie树&#x2F;字典树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">并查集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">朴素并查集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E6%95%B0%E9%87%8F\"><span class=\"toc-text\">维护集合数量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%B4%E6%8A%A4%E5%88%B0%E7%A5%96%E5%AE%97%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB\"><span class=\"toc-text\">维护到祖宗节点距离</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C\"><span class=\"toc-text\">一般哈希</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%89%E9%93%BE%E6%B3%95\"><span class=\"toc-text\">拉链法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95\"><span class=\"toc-text\">开放寻址法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C\"><span class=\"toc-text\">字符串哈希</span></a></li></ol>","author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"错误之路","uid":"ef2958a60eebffed61302cfeed7e9fed","slug":"错误之路","date":"2022-02-16T02:58:30.254Z","updated":"2022-02-16T04:19:52.201Z","comments":true,"path":"api/articles/错误之路.json","keywords":null,"cover":"https://pic.imgdb.cn/item/620a098b2ab3f51d9196f63a.jpg","text":"本篇文章用于记录学习之路/比赛上看似不起眼的小错误却又不得不重视的，一直都在更新…… 2022.02.15 res=pow(a,b) 当res为int类型时，b应该为常量。当res为double类型时，b应该为常量、int、double。 ","link":"","photos":[],"count_time":{"symbolsCount":121,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"回文字符串","uid":"768c5d200987ad0ffa01337632098c22","slug":"回文字符串","date":"2022-02-15T03:47:30.314Z","updated":"2022-02-16T08:56:46.660Z","comments":true,"path":"api/articles/回文字符串.json","keywords":null,"cover":"https://pic.imgdb.cn/item/620cbc3d2ab3f51d91253ecd.jpg","text":"最长回文子序列 最长回文子序列 LPS（Longest Palindromic Subsequence） 状态表示：表示从 到 序列的最长回文子序列 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"杂题","slug":"杂题","count":1,"path":"api/categories/杂题.json"}],"tags":[{"name":"回文字符串","slug":"回文字符串","count":1,"path":"api/tags/回文字符串.json"},{"name":"回文序列","slug":"回文序列","count":1,"path":"api/tags/回文序列.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}