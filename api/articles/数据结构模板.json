{"title":"数据结构模板","uid":"1df484034a65ae4d42f3134f61bf20af","slug":"数据结构模板","date":"2022-02-16T06:09:33.395Z","updated":"2022-07-21T11:30:45.677Z","comments":true,"path":"api/articles/数据结构模板.json","keywords":null,"cover":"https://pic.imgdb.cn/item/620c96192ab3f51d91d60f3a.jpg","content":"<h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2><ul>\n<li><p><code>head</code>存储表头，<code>e[]</code>存储节点的值,<code>ne[]</code>存储节点的next指针，<code>idx</code>表示当前用到了哪个节点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int head, e[N], ne[N], idx;\n// 初始化\nvoid init()\n{\n    head = -1;\n    idx = 0;\n}\n// 在链表头插入一个数a\nvoid insert(int a)\n{\n    e[idx] = a, ne[idx] = head, head = idx ++ ;\n}\n// 将头结点删除，需要保证头结点存在\nvoid remove()\n{\n    head = ne[head];\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><ul>\n<li><p><code>e[]</code>表示节点的值 <code>l[]</code>表示节点的左指针 <code>r[]</code>表示节点的右指针 <code>idx</code>表示当前用到了哪个节点</p>\n</li>\n<li><p>先将插入点的左右指针修改，再修改左节点指向的节点的左指针，再修改原本左节点的右指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int e[N], l[N], r[N], idx;\n// 初始化\nvoid init()\n{\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n{\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n}\n// 删除节点a\nvoid remove(int a)\n{\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><p><code>tt</code>表示栈顶，初始化为0，如果 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.782ex\" height=\"1.819ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 2555.6 804\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(361,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(999.8,0)\"><path data-c=\"2264\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(2055.6,0)\"><g data-mml-node=\"mn\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container> 表示栈为空</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int stk[N], tt = 0;\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n// 从栈顶弹出一个数\ntt -- ;\n// 栈顶的值\nstk[tt];\n// 判断栈是否为空\nif (tt &gt; 0)\n{\n\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"普通队列\"><a href=\"#普通队列\" class=\"headerlink\" title=\"普通队列\"></a>普通队列</h2><ul>\n<li><p><code>hh</code> 表示对头，<code>tt</code>表示队尾，如果 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"7.257ex\" height=\"1.882ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 3207.6 832\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(576,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1429.8,0)\"><path data-c=\"2264\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2485.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2846.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g></g></svg></mjx-container> 表示队列为空</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int q[N], hh = 0, tt = -1;\n// 向队尾插入一个数\nq[ ++ tt] = x;\n// 从队头弹出一个数\nhh ++ ;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh &lt;= tt)\n{\n\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><ul>\n<li><p><code>hh</code> 表示对头，<code>tt</code> 表示队尾的后一个位置，如果 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"7.886ex\" height=\"1.805ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -716 3485.6 798\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(576,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1152,0)\"><path data-c=\"21\" d=\"M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1707.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2763.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3124.6,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g></g></svg></mjx-container> 表示队列为空</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int q[N], hh = 0, tt = 0;\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n// 队头的值\nq[hh];\n// 判断队列是否为空\nif (hh != tt)\n{\n\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><ul>\n<li><p><strong>从栈顶到栈底的元素是严格递增（or递减）</strong></p>\n</li>\n<li><p><strong>常见模型：</strong>找出每个数左边离它<strong>最近的比它大/小的数</strong>，也可以说是求数组每个数的<strong>往左第一个比他小的数</strong>，或<strong>往右第一个比他小的数</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int tt = 0;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/description/832/\">单调栈</a></p>\n</li>\n</ul>\n<h2 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h2><ul>\n<li><p><strong>从队列头到队列尾的元素是严格递增</strong></p>\n</li>\n<li><p><strong>常见模型：</strong>找出滑动窗口中的<em>最大值</em>/<em>最小值</em></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int hh = 0, tt = -1;\nfor (int i = 0; i &lt; n; i ++ )\n{\n    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口\n    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;\n    q[ ++ tt] = i;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/156/\">滑动窗口</a></p>\n</li>\n</ul>\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><ul>\n<li><p><code>s[]</code> 是母串 <code>p[]</code>是子串 <code>n</code>是 <code>s</code>的长度， <code>m</code>是<code>p</code>的长度，<code>next[]</code>是前缀后缀相同数组</p>\n</li>\n<li><p>下标从1开始</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">//求子串的Next数组\nfor (int i = 2, j = 0; i &lt;= m; i ++)\n{\n    //如果两个字符不一样就跳转到它前一位下标所指向的位置\n    while (j &amp;&amp; p[i] != p[j]) j = Next[j];\n    if (s[i] == s[j+1]) j++;\n    Next[i] = j;\n}\n//匹配过程\nfor (int i = 1, j = 0; i &lt;= n; i ++)\n{\n\twhile (j &amp;&amp; s[i] != p[j+1]) j = ne[j];\n    if (s[i] == p[j+1]) j++;\n    if (j == m) j=ne[j-];//匹配成功了继续往后寻找是否还存在\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/833/\">KMP</a></p>\n</li>\n</ul>\n<h3 id=\"求解循环节\"><a href=\"#求解循环节\" class=\"headerlink\" title=\"求解循环节\"></a>求解循环节</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">//下标从1开始的话,len-1\nlen--;\nint l=len-ne[len];\nif(len%l==0) printf(\"%d\\n\",len/l);\nelse printf(\"1\\n\");<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"Trie树-x2F-字典树\"><a href=\"#Trie树-x2F-字典树\" class=\"headerlink\" title=\"Trie树/字典树\"></a>Trie树/字典树</h2><ul>\n<li><p><strong>应用场景：</strong>字符串检索、词频统计、字符串排序、前缀匹配</p>\n</li>\n<li><p><code>son[][]</code>存储树种每个节点的子节点<code>cnt[]</code>存储以每个节点结尾的单词数量，<code>0号</code>点既是根节点，又是空节点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int son[N][26], cnt[N], idx;\n//插入一个字符串\nvoid insert(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            son[p][u] = ++idx; //如果没有出现过就创建一个新节点\n        p = son[p][u];\n    }\n    cnt[p]++; //以当前字符结尾的单词数量\n}\nvoid insert(char *str) //利用取址符\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int &amp;s = son[p][str[i] - 'a'];\n        if (!s)\n            s = ++idx;\n        p = s;\n    }\n    cnt[p]++;\n}\n//查询字符串出现的次数\nint query_num(char *str)\n{\n    int p = 0;\n    for (int i = 0; str[i]; i++)\n    {\n        int u = str[i] - 'a';\n        if (!son[p][u])\n            return 0;\n        p = son[p][u];\n    }\n    return cnt[p];\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/837/\">字符串统计</a>、<a href=\"https://www.acwing.com/problem/content/145/\">最大异或对</a></p>\n</li>\n</ul>\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><h3 id=\"朴素并查集\"><a href=\"#朴素并查集\" class=\"headerlink\" title=\"朴素并查集\"></a>朴素并查集</h3><ul>\n<li><p><code>p[]</code>存储每个节点的祖宗节点</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int p[N];\nint find(int x)\n{\n    if (p[x] != x) p[x] = find(p[x]); //路径压缩，每个点直接存最祖先\n    return p[x];\n}\nfor (int i = 1; i &lt;= n; i++) p[i] = i;\n//合并a和b所在的两个集合\np[find(a)] = find(b);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/838/\">合并集合</a></p>\n</li>\n</ul>\n<h3 id=\"维护集合数量\"><a href=\"#维护集合数量\" class=\"headerlink\" title=\"维护集合数量\"></a>维护集合数量</h3><ul>\n<li><p><code>p[]</code>储存每个点的祖宗节点，<code>num[]</code> 只有<strong>祖宗节点</strong>才有意义，表示祖宗节点所在集合中的点的数量</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int p[N], num[N];\nfor (int i = 1; i &lt;= n; i++) p[i] = i, num[i] = 1;\nwhile (k--) //操作次数\n{\n      int a, b;\n      cin &gt;&gt; a &gt;&gt; b;\n      int k1 = find(a), k2 = find(b);\n      if (k1 != k2)\n      {\n            num[k2] += num[k1]; //把k1所在集合的点数全部加到k2集合中\n            p[k1] = k2;         //将k1的祖宗节点更改为k2\n      }\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/839/\">联通块中点的数量</a></p>\n</li>\n</ul>\n<h3 id=\"维护到祖宗节点距离\"><a href=\"#维护到祖宗节点距离\" class=\"headerlink\" title=\"维护到祖宗节点距离\"></a>维护到祖宗节点距离</h3><ul>\n<li><p><code>p[]</code>存储每个点的祖宗节点，<code>d[]</code>存储<code>x</code>到<code>p[x](该点的祖宗节点)</code>的距离</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">// 返回x的祖宗节点\nint find(int x)\n{\n    if (p[x] != x)\n    {\n       int u = find(p[x]);\n       d[x] += d[p[x]];\n       p[x] = u;\n    }\n   return p[x];\n}\n// 初始化，假定节点编号是1~n\nfor (int i = 1; i &lt;= n; i++)\n{\n    p[i] = i;\n    d[i] = 0;\n}\n// 合并a和b所在的两个集合：\np[find(a)] = find(b);\nd[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"询问每次删点后联通块\"><a href=\"#询问每次删点后联通块\" class=\"headerlink\" title=\"询问每次删点后联通块\"></a>询问每次删点后联通块</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>   大意：一开始有 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container> 个点，给定 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.986ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 878 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45A\" d=\"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container> 条边，询问 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.179ex\" height=\"1.595ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 521 705\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D458\" d=\"M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z\"></path></g></g></g></svg></mjx-container> 次炸毁、每次一个点被炸毁后剩余联通块</p></blockquote>\n<ul>\n<li><p>一开始先将每个点都读入建双向边</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for (int i = 1; i &lt;= m; i++) {\n        int x, y; cin &gt;&gt; x &gt;&gt; y;\n        add(x, y), add(y, x);\n    }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>将每次炸毁的点标记起来</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(int i=0;i&lt;k;i++){\n        cin&gt;&gt;a[i];vis[a[i]]=1;\n    }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>先寻找一开始还没被炸毁的点所能构成的最大联通块数量</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(int i=0;i&lt;n;i++){\n        if(!vis[i]){\n            cnt++;\n            dfs(i);//遍历所有与i相关的边,如果没被炸毁的就合并集合\n        }\n    }\n    ans[k]=cnt;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>最后从后往前依次将摧毁的点标记取消，不断进行集合合并</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">memset(vis,0,sizeof vis);\n    for(int i=0;i&lt;k;i++) vis[a[i]]=1;\n    for(int i=k-1;i&gt;=0;i--){\n        vis[a[i]]=0;\n        cnt++;\n        for(int j=h[a[i]];j!=-1;j=ne[j]){\n            int jj=e[j];\n            if(!vis[jj]){\n                int f1=find(a[i]),f2=find(jj);\n                if(f1!=f2){\n                    p[f2]=f1;\n                    cnt--;\n                }\n            }\n        }\n        ans[i]=cnt;\n    }<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p><em>例题:</em><a href=\"https://www.luogu.com.cn/problem/P1197\">星球大战</a></p>\n<p><strong>code:</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int N = 4e5 + 10;\nint h[N &lt;&lt; 1], ne[N &lt;&lt; 1], e[N &lt;&lt; 1], idx;\nvoid add(int a, int b) {\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\nint p[N], ans[N], st[N], vis[N], bk[N],a[N];\nint n, m, k;\n\nint find(int x) {\n    if (p[x] != x)p[x] = find(p[x]);\n    return p[x];\n}\n\nvoid dfs(int x){\n    vis[x]=1;\n    for(int i=h[x];i!=-1;i=ne[i]){\n        int j=e[i];\n        if(!vis[j]){\n            int f1=find(x),f2=find(j);\n            if(f1!=f2) p[f1]=f2;\n            dfs(j);\n        }\n    }\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    memset(st, 0, sizeof st);\n    memset(vis, 0, sizeof vis);\n    for (int i = 0; i &lt; n; i++) p[i] = i;\n    for (int i = 1; i &lt;= m; i++) {\n        int x, y; cin &gt;&gt; x &gt;&gt; y;\n        add(x, y), add(y, x);\n    }\n    cin &gt;&gt; k;\n    for(int i=0;i&lt;k;i++){\n        cin&gt;&gt;a[i];vis[a[i]]=1;\n    }\n    int cnt=0;\n    for(int i=0;i&lt;n;i++){\n        if(!vis[i]){\n            cnt++;\n            dfs(i);\n        }\n    }\n    ans[k]=cnt;\n    memset(vis,0,sizeof vis);\n    for(int i=0;i&lt;k;i++) vis[a[i]]=1;\n    for(int i=k-1;i&gt;=0;i--){\n        vis[a[i]]=0;\n        cnt++;\n        for(int j=h[a[i]];j!=-1;j=ne[j]){\n            int jj=e[j];\n            if(!vis[jj]){\n                int f1=find(a[i]),f2=find(jj);\n                if(f1!=f2){\n                    p[f2]=f1;\n                    cnt--;\n                }\n            }\n        }\n        ans[i]=cnt;\n    }\n    for (int i = 0; i &lt;= k ; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><ul>\n<li><p><code>h[N]</code>存储堆中的值，<code>h[1]</code>是堆顶，<code>[x]</code>的左儿子是<code>2x</code>，右儿子是<code>2x+1</code></p>\n</li>\n<li><p><code>ph[k]</code> 存储第<code>k</code>个插入的点在堆中的位置，<code>hp[k]</code>存储堆中下标是<code>k</code>的点是第几个插入的</p>\n</li>\n<li><p><code>大根堆</code>符合父亲 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.76ex\" height=\"1.751ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -636 778 774\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"2265\" d=\"M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g></g></g></svg></mjx-container> 儿子，<code>小根堆</code>符合父亲 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.312ex\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.76ex\" height=\"1.751ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -636 778 774\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"2264\" d=\"M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z\"></path></g></g></g></svg></mjx-container> 儿子</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int h[N], ph[N], hp[N], size;\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n//向下调整\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    if (u != t)\n    {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n//向上调整\nvoid up(int u)\n{\n    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])\n    {\n        heap_swap(u, u / 2);\n        u &gt;&gt;= 1;\n    }\n}\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"一般哈希\"><a href=\"#一般哈希\" class=\"headerlink\" title=\"一般哈希\"></a>一般哈希</h2><h3 id=\"拉链法\"><a href=\"#拉链法\" class=\"headerlink\" title=\"拉链法\"></a>拉链法</h3><ul>\n<li><p><strong>核心：</strong>如果有两个哈希值一样的值则将他们用链表方式链接在这个哈希值位置</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int h[N], e[N], ne[N], idx;\n// 向哈希表中插入一个数\nvoid insert(int x)\n{\n    int k = (x % N + N) % N;\n    e[idx] = x;\n    ne[idx] = h[k];\n    h[k] = idx ++ ;\n}\n// 在哈希表中查询某个数是否存在\nbool find(int x)\n{\n    int k = (x % N + N) % N;\n    for (int i = h[k]; i != -1; i = ne[i])\n        if (e[i] == x)\n            return true;\n    return false;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h3 id=\"开放寻址法\"><a href=\"#开放寻址法\" class=\"headerlink\" title=\"开放寻址法\"></a>开放寻址法</h3><ul>\n<li><p><strong>核心：</strong>如果当前哈希值位置被占领，则挪向下一个没有被占用的位置（上厕所）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int h[N];\n// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置\nint find(int x)\n{\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x)\n    {\n        t ++ ;\n        if (t == N) t = 0;\n    }\n    return t;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<h2 id=\"字符串哈希\"><a href=\"#字符串哈希\" class=\"headerlink\" title=\"字符串哈希\"></a>字符串哈希</h2><ul>\n<li><p><strong>核心：</strong>将字符串看成是<code>P</code>进制数，<code>P</code>的取值通常为<code>131</code>或者<code>13331</code></p>\n</li>\n<li><p><strong>技巧：</strong>取模的数用<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.919ex\" height=\"1.904ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -841.7 1290.1 841.7\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mn\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(533,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mn\"><path data-c=\"36\" d=\"M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z\"></path><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\" transform=\"translate(500,0)\"></path></g></g></g></g></g></svg></mjx-container>，这样子直接用<code>unsigned long long </code>存储，溢出的结果就是取模的结果</p>\n</li>\n<li><p><strong>应用：</strong>判别字符串是否相同</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef unsigned long long ULL;\nULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64\n// 初始化\np[0] = 1;\nfor (int i = 1; i &lt;= n; i ++ )\n{\n    h[i] = h[i - 1] * P + str[i];\n    p[i] = p[i - 1] * P;\n}\n// 计算子串 str[l ~ r] 的哈希值\nULL get(int l, int r)\n{\n    return h[r] - h[l - 1] * p[r - l + 1];\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/843/\">字符串哈希</a></p>\n</li>\n</ul>\n","feature":false,"text":"单链表 head存储表头，e[]存储节点的值,ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a v...","link":"","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":2,"path":"api/categories/数据结构.json"},{"name":"模板","slug":"数据结构/模板","count":1,"path":"api/categories/数据结构/模板.json"}],"tags":[{"name":"模板","slug":"模板","count":4,"path":"api/tags/模板.json"},{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97\"><span class=\"toc-text\">普通队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">循环队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88\"><span class=\"toc-text\">单调栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\"><span class=\"toc-text\">单调队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#KMP\"><span class=\"toc-text\">KMP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B1%82%E8%A7%A3%E5%BE%AA%E7%8E%AF%E8%8A%82\"><span class=\"toc-text\">求解循环节</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91-x2F-%E5%AD%97%E5%85%B8%E6%A0%91\"><span class=\"toc-text\">Trie树&#x2F;字典树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">并查集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">朴素并查集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%B4%E6%8A%A4%E9%9B%86%E5%90%88%E6%95%B0%E9%87%8F\"><span class=\"toc-text\">维护集合数量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%B4%E6%8A%A4%E5%88%B0%E7%A5%96%E5%AE%97%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB\"><span class=\"toc-text\">维护到祖宗节点距离</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%A2%E9%97%AE%E6%AF%8F%E6%AC%A1%E5%88%A0%E7%82%B9%E5%90%8E%E8%81%94%E9%80%9A%E5%9D%97\"><span class=\"toc-text\">询问每次删点后联通块</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86\"><span class=\"toc-text\">堆</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C\"><span class=\"toc-text\">一般哈希</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8B%89%E9%93%BE%E6%B3%95\"><span class=\"toc-text\">拉链法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95\"><span class=\"toc-text\">开放寻址法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C\"><span class=\"toc-text\">字符串哈希</span></a></li></ol>","author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"STL容器","uid":"dd310f63c22e1adb321e0e6222b0b1f9","slug":"STL容器","date":"2022-02-16T09:21:30.340Z","updated":"2022-02-16T10:50:55.872Z","comments":true,"path":"api/articles/STL容器.json","keywords":null,"cover":"https://pic.imgdb.cn/item/620cc8d82ab3f51d9139bfcb.jpg","text":"vector 可变数组，倍增的思想 设vector&lt;int&gt;a,b a.size()返回a元素个数 a.empty()返回a是否为空 a.clear()清空数组a a.resize()调整a空间大小 a.swap(b) 将a中的元素和b中的元素整体交换 a.front...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"STL","slug":"STL","count":2,"path":"api/categories/STL.json"}],"tags":[{"name":"STL容器","slug":"STL容器","count":1,"path":"api/tags/STL容器.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"回文字符串","uid":"768c5d200987ad0ffa01337632098c22","slug":"回文字符串","date":"2022-02-15T03:47:30.314Z","updated":"2022-03-11T12:44:23.126Z","comments":true,"path":"api/articles/回文字符串.json","keywords":null,"cover":"https://pic.imgdb.cn/item/620cbc3d2ab3f51d91253ecd.jpg","text":"最长回文子序列 最长回文子序列 LPS（Longest Palindromic Subsequence） 状态表示：表示从 到 序列的最长回文子序列 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include ...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"杂题","slug":"杂题","count":2,"path":"api/categories/杂题.json"}],"tags":[{"name":"回文字符串","slug":"回文字符串","count":1,"path":"api/tags/回文字符串.json"},{"name":"回文序列","slug":"回文序列","count":1,"path":"api/tags/回文序列.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}