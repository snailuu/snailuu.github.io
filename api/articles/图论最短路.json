{"title":"图论最短路问题","uid":"aa03b2f0abb625816c3d81ed8f81147b","slug":"图论最短路","date":"2022-02-20T13:19:08.472Z","updated":"2022-02-20T13:19:08.472Z","comments":true,"path":"api/articles/图论最短路.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62091b5f2ab3f51d91da3fbb.jpg","content":"<h2 id=\"朴素版Dijkstra算法-适用于稠密图\"><a href=\"#朴素版Dijkstra算法-适用于稠密图\" class=\"headerlink\" title=\"朴素版Dijkstra算法(适用于稠密图)\"></a>朴素版Dijkstra算法(适用于稠密图)</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>初始化距离数组和邻接矩阵（无穷大）</li>\n<li>处理重边问题在输入取最小值</li>\n<li>每次找到一个最小的未更新的答案点</li>\n<li>将其连边答案全部更新</li>\n</ol>\n<p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/851/\">Dijkstra算法朴素版</a></p>\n<p>代码实现如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 520, INF = 0x3f3f3f3f;\nint n, m;\nint g[N][N], dis[N];\nbool st[N];\n\nint dijkstra()\n{\n    dis[1] = 0; //每个点到一号点的最短距离\n    //如需求到s点的一开始将dis[s]定义为0即可\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (!st[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))\n                t = j; //找到当前未更新的最小点\n        }\n        for (int j = 1; j &lt;= n; j++)\n            dis[j] = min(dis[j], dis[t] + g[t][j]); //将t连接的点都更新最短距离\n        st[t] = true;\n    }\n    if (dis[n] == 0x3f3f3f3f)\n        return -1; // 1~n之间不连通，无法构成路径，也就没有最短距离\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(g[0], g[0] + N * N, INF);\n    fill(dis, dis + N, INF);\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        g[x][y] = min(g[x][y], c); //处理重边\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"堆优化版Dijkstra算法-适用于稀疏图\"><a href=\"#堆优化版Dijkstra算法-适用于稀疏图\" class=\"headerlink\" title=\"堆优化版Dijkstra算法(适用于稀疏图)\"></a>堆优化版Dijkstra算法(适用于稀疏图)</h2><p><strong>优点：</strong> </p>\n<ol>\n<li>堆可以动态维护一个集合中的最小值</li>\n<li>堆动态支持插入，删除，修改一个数</li>\n</ol>\n<p><strong>优化部分：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(int j=1;j&lt;=n;j++)\n{\n    if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n}\n//每次寻找一个最小值可以用堆来维护一个最小值\n//复杂度从O(n)-&gt;O(1)\n////////////////////////////////////////////\nfor(int j=1;j&lt;=n;j++)\n    dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n//每次将点更新在堆中修改复杂度为mlogm\n//复杂度从O(n)-&gt;O(mlogm)\n//////////////////////////////////////////////\n//总体复杂度从O(n^2)-&gt;O(mlogm)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/852/\">Dijkstra算法堆优化版</a></p>\n<p><strong>代码实现：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\n#define PII pair&lt;int, int&gt;\nusing namespace std;\n\nconst int N = 1e6 + 10, INF = 0x3f3f3f3f;\nint n, m;\nint h[N], e[N], ne[N], idx;\nint dis[N], w[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint dijkstra()\n{\n    fill(dis, dis + N, INF);\n    dis[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; //优先队列默认大根堆，这样子写可以维护小根堆,pair&lt;int,int&gt;第一个值存数值，第二个值存下标\n    heap.push({0, 1});\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver]) continue; //每次处理均为最小值且未处理过的\n        st[ver] = true;\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dis[j] &gt; dis[ver] + w[i]) //有更短路就替换\n            {\n                dis[j] = dis[ver] + w[i];\n                heap.push({dis[j], j}); //将新的方案加入到队列中\n            }\n        }\n    }\n    //队列为空即走完整个图\n    if (dis[n] == INF)\n        return -1;\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(h, h + N, -1); //将头结点数组全部初始化成-1\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        add(x, y, c);\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"SPFA算法（适用于稀疏图）\"><a href=\"#SPFA算法（适用于稀疏图）\" class=\"headerlink\" title=\"SPFA算法（适用于稀疏图）\"></a>SPFA算法（适用于稀疏图）</h2><p><del>Bellman-Ford太呆</del></p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>每次只更新与结点有关点的最小距离</li>\n</ol>\n<p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/853/\">SPFA求最短路</a></p>\n<p><strong>代码实现：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[N], ne[N], w[N], idx; //稀疏图用邻接表来存图\nint n, m;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint spfa()\n{\n    fill(dist, dist + N, INF); //先将每个到源点的距离初始化成正无穷\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        int t = q.front();\n        q.pop();\n        st[t] = false; //出队了\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) //更新t结点的所有距离\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])\n                {\n                    q.push(j); //更新的点第一次访问就进度，后面可能还能再利用其更新其他点\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    while (m--)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if (t == INF) //如果到n点还无法更新距离说明无法连通\n        puts(\"impossible\");\n    else\n        cout &lt;&lt; t &lt;&lt; endl;\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","feature":false,"text":"朴素版Dijkstra算法(适用于稠密图)思路 初始化距离数组和邻接矩阵（无穷大） 处理重边问题在输入取最小值 每次找到一个最小的未更新的答案点 将其连边答案全部更新 例题：Dijkstra算法朴素版 代码实现如下： #include &lt;bits/stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"图论","slug":"图论","count":5,"path":"api/categories/图论.json"}],"tags":[{"name":"最短路","slug":"最短路","count":1,"path":"api/tags/最短路.json"},{"name":"稠密图","slug":"稠密图","count":1,"path":"api/tags/稠密图.json"},{"name":"稀疏图","slug":"稀疏图","count":1,"path":"api/tags/稀疏图.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E7%89%88Dijkstra%E7%AE%97%E6%B3%95-%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%A0%E5%AF%86%E5%9B%BE\"><span class=\"toc-text\">朴素版Dijkstra算法(适用于稠密图)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88Dijkstra%E7%AE%97%E6%B3%95-%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%80%E7%96%8F%E5%9B%BE\"><span class=\"toc-text\">堆优化版Dijkstra算法(适用于稀疏图)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SPFA%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%89\"><span class=\"toc-text\">SPFA算法（适用于稀疏图）</span></a></li></ol>","author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"某些可能有用的链接","uid":"92e9e21f40cabb2aa99ef90279e6b57e","slug":"不知名文章","date":"2022-02-21T13:33:14.265Z","updated":"2022-02-21T14:19:36.117Z","comments":true,"path":"api/articles/不知名文章.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62139f712ab3f51d91ff3728.jpg","text":"2022/2/21 upd: 不知道链接能活多久 本文不定期更新 支持推荐，如果有什么你觉得很有意义的文章/工具，欢迎把链接发送给我。 Tools (about Competitive Programming) :Csacademy Graph Editor（画“图”） Data...","link":"","photos":[],"count_time":{"symbolsCount":905,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"矩阵的数量V3","uid":"3066e00b6cf820c21780a6c4e3135165","slug":"矩阵的数量V3","date":"2022-02-19T09:53:53.021Z","updated":"2022-02-19T13:56:22.804Z","comments":true,"path":"api/articles/矩阵的数量V3.json","keywords":null,"cover":"https://pic.imgdb.cn/item/6210f6fe2ab3f51d91bac1ff.jpg","text":"题目链接：矩形的数量 V3 矩形的数量 V3 Time limit : 1000ms Memory limit: 131072 kb 一个m乘n的方格图，有多少个大小不同的正方形。 例如：4*3的方格中共有20个，其中： 12个 6个 2个 Input 共一行：2个数m,n，对应...","link":"","photos":[],"count_time":{"symbolsCount":884,"symbolsTime":"1 mins."},"categories":[{"name":"杂题","slug":"杂题","count":2,"path":"api/categories/杂题.json"}],"tags":[{"name":"数学知识","slug":"数学知识","count":1,"path":"api/tags/数学知识.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}