{"title":"图论最短路问题","uid":"aa03b2f0abb625816c3d81ed8f81147b","slug":"图论最短路","date":"2022-02-13T07:19:11.220Z","updated":"2022-02-16T06:08:37.796Z","comments":true,"path":"api/articles/图论最短路.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62091b5f2ab3f51d91da3fbb.jpg","content":"<h2 id=\"朴素版Dijkstra算法-适用于稠密图\"><a href=\"#朴素版Dijkstra算法-适用于稠密图\" class=\"headerlink\" title=\"朴素版Dijkstra算法(适用于稠密图)\"></a>朴素版Dijkstra算法(适用于稠密图)</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li>初始化距离数组和邻接矩阵（无穷大）</li>\n<li>处理重边问题在输入取最小值</li>\n<li>每次找到一个最小的未更新的答案点</li>\n<li>将其连边答案全部更新</li>\n</ol>\n<p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/851/\">Dijkstra算法朴素版</a></p>\n<p>代码实现如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 520, INF = 0x3f3f3f3f;\nint n, m;\nint g[N][N], dis[N];\nbool st[N];\n\nint dijkstra()\n{\n    dis[1] = 0; //每个点到一号点的最短距离\n    //如需求到s点的一开始将dis[s]定义为0即可\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        int t = -1;\n        for (int j = 1; j &lt;= n; j++)\n        {\n            if (!st[j] &amp;&amp; (t == -1 || dis[t] &gt; dis[j]))\n                t = j; //找到当前未更新的最小点\n        }\n        for (int j = 1; j &lt;= n; j++)\n            dis[j] = min(dis[j], dis[t] + g[t][j]); //将t连接的点都更新最短距离\n        st[t] = true;\n    }\n    if (dis[n] == 0x3f3f3f3f)\n        return -1; // 1~n之间不连通，无法构成路径，也就没有最短距离\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(g[0], g[0] + N * N, INF);\n    fill(dis, dis + N, INF);\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        g[x][y] = min(g[x][y], c); //处理重边\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"堆优化版Dijkstra算法-适用于稀疏图\"><a href=\"#堆优化版Dijkstra算法-适用于稀疏图\" class=\"headerlink\" title=\"堆优化版Dijkstra算法(适用于稀疏图)\"></a>堆优化版Dijkstra算法(适用于稀疏图)</h2><p><strong>优点：</strong> </p>\n<ol>\n<li>堆可以动态维护一个集合中的最小值</li>\n<li>堆动态支持插入，删除，修改一个数</li>\n</ol>\n<p><strong>优化部分：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">for(int j=1;j&lt;=n;j++)\n{\n    if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n}\n//每次寻找一个最小值可以用堆来维护一个最小值\n//复杂度从O(n)-&gt;O(1)\n////////////////////////////////////////////\nfor(int j=1;j&lt;=n;j++)\n    dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n//每次将点更新在堆中修改复杂度为mlogm\n//复杂度从O(n)-&gt;O(mlogm)\n//////////////////////////////////////////////\n//总体复杂度从O(n^2)-&gt;O(mlogm)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/852/\">Dijkstra算法堆优化版</a></p>\n<p><strong>代码实现：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\n#define PII pair&lt;int, int&gt;\nusing namespace std;\n\nconst int N = 1e6 + 10, INF = 0x3f3f3f3f;\nint n, m;\nint h[N], e[N], ne[N], idx;\nint dis[N], w[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint dijkstra()\n{\n    fill(dis, dis + N, INF);\n    dis[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; //优先队列默认大根堆，这样子写可以维护小根堆,pair&lt;int,int&gt;第一个值存数值，第二个值存下标\n    heap.push({0, 1});\n    while (heap.size())\n    {\n        auto t = heap.top();\n        heap.pop();\n        int ver = t.second, distance = t.first;\n        if (st[ver])\n            continue; //每次处理均为最小值且未处理过的\n        st[ver] = true;\n        for (int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dis[j] &gt; dis[ver] + w[i]) //有更短路就替换\n            {\n                dis[j] = dis[ver] + w[i];\n                heap.push({dis[j], j}); //将新的方案加入到队列中\n            }\n        }\n    }\n    //队列为空即走完整个图\n    if (dis[n] == INF)\n        return -1;\n    return dis[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    fill(h, h + N, -1); //将头结点数组全部初始化成-1\n    while (m--)\n    {\n        int x, y, c;\n        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;\n        add(x, y, c);\n    }\n    cout &lt;&lt; dijkstra() &lt;&lt; endl;\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"SPFA算法（适用于稀疏图）\"><a href=\"#SPFA算法（适用于稀疏图）\" class=\"headerlink\" title=\"SPFA算法（适用于稀疏图）\"></a>SPFA算法（适用于稀疏图）</h2><p><del>Bellman-Ford太呆</del></p>\n<p><strong>优点：</strong></p>\n<ol>\n<li>每次只更新与结点有关点的最小距离</li>\n</ol>\n<p><em>例题：</em><a href=\"https://www.acwing.com/problem/content/853/\">SPFA求最短路</a></p>\n<p><strong>代码实现：</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N = 1e5 + 10, INF = 0x3f3f3f3f;\nint h[N], e[N], ne[N], w[N], idx; //稀疏图用邻接表来存图\nint n, m;\nint dist[N];\nbool st[N];\n\nvoid add(int a, int b, int c)\n{\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint spfa()\n{\n    fill(dist, dist + N, INF); //先将每个到源点的距离初始化成正无穷\n    dist[1] = 0;\n    queue&lt;int&gt; q;\n    q.push(1);\n    st[1] = true;\n    while (q.size())\n    {\n        int t = q.front();\n        q.pop();\n        st[t] = false; //出队了\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) //更新t结点的所有距离\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])\n                {\n                    q.push(j); //更新的点第一次访问就进度，后面可能还能再利用其更新其他点\n                    st[j] = true;\n                }\n            }\n        }\n    }\n    return dist[n];\n}\nint main()\n{\n    cin &gt;&gt; n &gt;&gt; m;\n    memset(h, -1, sizeof h);\n    while (m--)\n    {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        add(a, b, c);\n    }\n    int t = spfa();\n    if (t == INF) //如果到n点还无法更新距离说明无法连通\n        puts(\"impossible\");\n    else\n        cout &lt;&lt; t &lt;&lt; endl;\n    return 0;\n}\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","feature":false,"text":"朴素版Dijkstra算法(适用于稠密图)思路 初始化距离数组和邻接矩阵（无穷大） 处理重边问题在输入取最小值 每次找到一个最小的未更新的答案点 将其连边答案全部更新 例题：Dijkstra算法朴素版 代码实现如下： #include &lt;bits/stdc++.h&gt; ...","link":"","photos":[],"count_time":{"symbolsCount":"4.2k","symbolsTime":"4 mins."},"categories":[{"name":"图论","slug":"图论","count":3,"path":"api/categories/图论.json"}],"tags":[{"name":"最短路","slug":"最短路","count":1,"path":"api/tags/最短路.json"},{"name":"稠密图","slug":"稠密图","count":1,"path":"api/tags/稠密图.json"},{"name":"稀疏图","slug":"稀疏图","count":1,"path":"api/tags/稀疏图.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E7%89%88Dijkstra%E7%AE%97%E6%B3%95-%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%A0%E5%AF%86%E5%9B%BE\"><span class=\"toc-text\">朴素版Dijkstra算法(适用于稠密图)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88Dijkstra%E7%AE%97%E6%B3%95-%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%80%E7%96%8F%E5%9B%BE\"><span class=\"toc-text\">堆优化版Dijkstra算法(适用于稀疏图)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SPFA%E7%AE%97%E6%B3%95%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%89\"><span class=\"toc-text\">SPFA算法（适用于稀疏图）</span></a></li></ol>","author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"最小生成树","uid":"f83333b56248d745b141d3885b656c81","slug":"最小生成树","date":"2022-02-13T07:22:11.269Z","updated":"2022-02-16T03:02:44.803Z","comments":true,"path":"api/articles/最小生成树.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62091b402ab3f51d91da1db3.jpg","text":"假设表示图中点数，表示图中边数 朴素版Prim算法（适用于稠密图，复杂度O())思路：将条边到另一条边的距离初始化成从遍历到找到集合外距离最小的点标记为，用来更新它到集合的距离，标记一下 例题：Prim算法求最小生成树 核心代码： // st[i] 表示点i是否在当前生成树集合中...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"图论","slug":"图论","count":3,"path":"api/categories/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":2,"path":"api/tags/图论.json"},{"name":"生成树","slug":"生成树","count":1,"path":"api/tags/生成树.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"拓扑排序","uid":"01d132f13ac67dff21350f57c338a855","slug":"拓扑排序","date":"2022-02-13T07:19:11.215Z","updated":"2022-02-16T13:03:38.818Z","comments":true,"path":"api/articles/拓扑排序.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62091b702ab3f51d91da51dd.jpg","text":"拓扑排序应用场景在做某些事的时候他们之间有前后关系（顺序关系或者依赖关系），比如安排座位，穿衣服先后，课程学习等等。 拓扑排序只对于有向无环图而言(Directed Acyclic Graph简称DAG) 如果有a,b,c,d等件事情，a的优先级最高，d的优先级最低，那么abcd...","link":"","photos":[],"count_time":{"symbolsCount":865,"symbolsTime":"1 mins."},"categories":[{"name":"图论","slug":"图论","count":3,"path":"api/categories/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":2,"path":"api/tags/图论.json"},{"name":"排序","slug":"排序","count":1,"path":"api/tags/排序.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}