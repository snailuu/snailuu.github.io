{"title":"算法选择","uid":"60a84708f3c49aa5488e16601f40a652","slug":"最短路","date":"2022-02-12T14:21:45.818Z","updated":"2022-02-12T12:56:13.220Z","comments":true,"path":"api/articles/最短路.json","keywords":null,"cover":"https://pic.imgdb.cn/item/6207ae4e2ab3f51d91ae8070.jpg","content":"<h2 id=\"朴素版Dijkstra算法-适用于稠密图\"><a href=\"#朴素版Dijkstra算法-适用于稠密图\" class=\"headerlink\" title=\"朴素版Dijkstra算法(适用于稠密图)\"></a>朴素版Dijkstra算法(适用于稠密图)</h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ol>\n<li><p>初始化距离数组和邻接矩阵（无穷大）</p>\n</li>\n<li><p>处理重边问题在输入取最小值</p>\n</li>\n<li><p>每次找到一个最小的未更新的答案点</p>\n</li>\n<li><p>将其连边答案全部更新</p>\n</li>\n</ol>\n<p>代码实现如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nconst int N=520,INF=0x3f3f3f3f;\nint n,m;\nint g[N][N],dis[N];\nbool st[N];\n\nint dijkstra()\n{\n    dis[1]=0;//每个点到一号点的最短距离\n    //如需求到s点的一开始将dis[s]定义为0即可\n    for(int i=0;i&lt;n-1;i++)\n    {\n        int t=-1;\n        for(int j=1;j&lt;=n;j++)\n        {\n            if(!st[j]&amp;&amp;(t==-1||dis[t]&gt;dis[j])) t=j;//找到当前未更新的最小点\n        }\n        for(int j=1;j&lt;=n;j++)\n            dis[j]=min(dis[j],dis[t]+g[t][j]);//将t连接的点都更新最短距离\n        st[t]=true;\n    }\n    if(dis[n]==0x3f3f3f3f)return -1;//1~n之间不连通，无法构成路径，也就没有最短距离\n    return dis[n];\n}\nint main()\n{\n    cin&gt;&gt;n&gt;&gt;m;\n    fill(g[0],g[0]+N*N,INF);\n    fill(dis,dis+N,INF);\n    while(m--)\n    {\n        int x,y,c;\n        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;\n        g[x][y]=min(g[x][y],c);//处理重边\n    }\n    cout&lt;&lt;dijkstra()&lt;&lt;endl;\n    return 0;\n}<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"堆优化版Dijkstra算法-适用于稀疏图\"><a href=\"#堆优化版Dijkstra算法-适用于稀疏图\" class=\"headerlink\" title=\"堆优化版Dijkstra算法(适用于稀疏图)\"></a>堆优化版Dijkstra算法(适用于稀疏图)</h2><p><strong>优点：</strong> </p>\n<ol>\n<li>堆可以动态维护一个集合中的最小值</li>\n<li>堆动态支持插入，删除，修改一个数</li>\n</ol>\n","feature":true,"text":"朴素版Dijkstra算法(适用于稠密图)思路 初始化距离数组和邻接矩阵（无穷大） 处理重边问题在输入取最小值 每次找到一个最小的未更新的答案点 将其连边答案全部更新 代码实现如下： #include&lt;bits/stdc++.h&gt; using namespace st...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"图论","slug":"图论","count":2,"path":"api/categories/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":2,"path":"api/tags/图论.json"},{"name":"算法选择","slug":"算法选择","count":2,"path":"api/tags/算法选择.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E7%89%88Dijkstra%E7%AE%97%E6%B3%95-%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%A0%E5%AF%86%E5%9B%BE\"><span class=\"toc-text\">朴素版Dijkstra算法(适用于稠密图)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88Dijkstra%E7%AE%97%E6%B3%95-%E9%80%82%E7%94%A8%E4%BA%8E%E7%A8%80%E7%96%8F%E5%9B%BE\"><span class=\"toc-text\">堆优化版Dijkstra算法(适用于稀疏图)</span></a></li></ol>","author":{"name":"Snailuu","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/62035c342ab3f51d91f6154a.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"算法选择","uid":"60a84708f3c49aa5488e16601f40a652","slug":"算法选择","date":"2022-02-12T14:21:45.812Z","updated":"2022-02-12T10:40:00.810Z","comments":true,"path":"api/articles/算法选择.json","keywords":null,"cover":[],"text":" 一个图中，顶点数记为n，边数记为m 当m时，称之为稀疏图 当m相对比较大时，称之为稠密图 graph LR A(最短路) B(单源最短路) C(多源汇最短路) D(所有边权都是正数) E(存在负权边) F(朴素Dijkstra算法) G(堆优化版的Dijkstra算法) H(B...","link":"","photos":[],"count_time":{"symbolsCount":554,"symbolsTime":"1 mins."},"categories":[{"name":"图论","slug":"图论","count":2,"path":"api/categories/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":2,"path":"api/tags/图论.json"},{"name":"算法选择","slug":"算法选择","count":2,"path":"api/tags/算法选择.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://pic.imgdb.cn/item/62035c342ab3f51d91f6154a.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}