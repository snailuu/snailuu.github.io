{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"LCA问题","date":"2022-04-27T07:32:53.940Z","updated":"2022-04-28T01:48:49.105Z","comments":true,"path":"api/articles/LCA问题.json","keywords":null,"cover":null,"content":"<h2 id=\"树上倍增法求解\"><a href=\"#树上倍增法求解\" class=\"headerlink\" title=\"树上倍增法求解\"></a>树上倍增法求解</h2><p>${\\color{Red}复杂度：O(nlogn+m)}$</p>\n<p><code>f[i][j]</code>表示第 i 个节点的$2^j$的祖宗节点</p>\n<ul>\n<li>初始化深度数组和距离数组</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void dfs(int u)&#123;\n    for(int i&#x3D;h[u];~i;i&#x3D;ne[i])&#123;&#x2F;&#x2F;求深度、距离还有节点的祖先\n        int j&#x3D;e[i];\n        if(j&#x3D;&#x3D;f[u][0])continue;\n        deep[j]&#x3D;deep[u]+1;\n        dis[j]&#x3D;dis[u]+w[i];\n        f[j][0]&#x3D;u;\n        dfs(j);\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>创建st表</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void st_create()&#123;\n    for(int j&#x3D;1;j&lt;&#x3D;k;j++)\n        for(int i&#x3D;1;i&lt;&#x3D;n;i++)\n            f[i][j]&#x3D;f[f[i][j-1]][j-1];<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<ul>\n<li>询问LCA</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int query_lca(int x,int y)&#123;\n    if(deep[x]&gt;deep[y])swap(x,y);&#x2F;&#x2F;保证x的深度小于等于y\n    for(int i&#x3D;k;i&gt;&#x3D;0;i--)&#123;\n        if(deep[f[y][i]]&gt;&#x3D;deep[x]) y&#x3D;f[y][i];\n        &#x2F;&#x2F;深度大的点一直跳到两个点深度一样\n    &#125;\n    if(x&#x3D;&#x3D;y)return x;\n    for(int i&#x3D;k;i&gt;&#x3D;0;i--)&#123;\n        if(deep[f[x][i]]!&#x3D;deep[f[y][i]])&#123;&#x2F;&#x2F;找不到公共祖先一直跳\n            x&#x3D;f[x][i];\n            y&#x3D;f[y][i];\n        &#125;\n    &#125;\n    return f[x][0];&#x2F;&#x2F;此时x&#x3D;&#x3D;y,f[x][0]&#x3D;f[y][0]就是他俩的最近公共祖先\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"Tarjan-并查集（离线做法）\"><a href=\"#Tarjan-并查集（离线做法）\" class=\"headerlink\" title=\"Tarjan+并查集（离线做法）\"></a>Tarjan+并查集（离线做法）</h2><p>${\\color{Red}复杂度：O(n+m)}$</p>\n<ul>\n<li><p>初始化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void init()&#123;\n    memset(h,-1,sizeof h);\n    idx&#x3D;1;\n    memset(hq,-1,sizeof hq);\n    idxq&#x3D;1;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)p[i]&#x3D;i;&#x2F;&#x2F;并查集初始化\n    memset(vis,0,sizeof vis);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>添加、查找操作</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int find(int x)&#123;&#x2F;&#x2F;并查集找祖先\n    if(p[x]!&#x3D;x)p[x]&#x3D;find(p[x]);\n    return p[x];\n&#125;\n\nvoid add(int a,int b)&#123;&#x2F;&#x2F;构图\n    e[idx]&#x3D;b,ne[idx]&#x3D;h[a],h[a]&#x3D;idx++;\n&#125;\n\nvoid addq(int a,int b,int idd)&#123;&#x2F;&#x2F;x数组\n  eq[idxq]&#x3D;b,neq[idxq]&#x3D;hq[a],id[idxq]&#x3D;idd,hq[a]&#x3D;idxq++;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n</li>\n<li><p>存储每一个节点的祖宗</p>\n</li>\n<li><p>处理每个节点的距离数组时处理询问数组</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void tarjan(int u)&#123;\n    vis[u]&#x3D;1;\n    for(int i&#x3D;h[u];~i;i&#x3D;ne[i])&#123;\n        int j&#x3D;e[i];\n        if(vis[j])continue;\n        vis[j]&#x3D;1;\n        tarjan(j);\n        p[find(j)]&#x3D;find(u);&#x2F;&#x2F;修改每一个节点的祖宗节点\n    &#125;\n    for(int i&#x3D;hq[u];~i;i&#x3D;neq[i])&#123;&#x2F;&#x2F;离线询问数组\n        int j&#x3D;eq[i];\n        int idd&#x3D;id[i];\n        if(vis[j])&#123;&#x2F;&#x2F;当前子节点是否枚举到\n            ans[idd]&#x3D;find(j);\n        &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n","text":"树上倍增法求解${\\color{Red}复杂度：O(nlogn+m)}$ f[i][j]表示第 i 个节点的$2^j$的祖宗节点 初始化深度数组和距离数组 void dfs(int u)&#123; for(int i&#x3D;h[u];~i;i&#x3D;ne[i])&#12...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E%E6%B3%95%E6%B1%82%E8%A7%A3\"><span class=\"toc-text\">树上倍增法求解</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Tarjan-%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%88%E7%A6%BB%E7%BA%BF%E5%81%9A%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">Tarjan+并查集（离线做法）</span></a></li></ol>","author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"三元环","uid":"b906dec7c019d106b02095edae4e608a","slug":"三元环","date":"2022-05-11T00:56:59.379Z","updated":"2022-05-11T01:22:40.962Z","comments":true,"path":"api/articles/三元环.json","keywords":null,"cover":"https://pic.imgdb.cn/item/627b0f4109475431298d7de3.jpg","text":"参考链接：三元环 三元环定义 给定一张无重边、无自环的无向图 点数为，边数为，且同阶 问有多少个无序三元组，使得存在： 有一条连接的边 有一条连接的边 有一条连接的边 这张图中有三个三元环：(1,2,3),(1,3,4),(3,4,5)(1,2,3),(1,3,4),(3,4,5...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"图论","slug":"图论","count":5,"path":"api/categories/图论.json"}],"tags":[{"name":"图论","slug":"图论","count":4,"path":"api/tags/图论.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"组合数学","uid":"e9aa53c6c1b77921f8bd9d5efce0b5e9","slug":"组合数学","date":"2022-04-26T08:07:54.153Z","updated":"2022-04-26T08:10:14.038Z","comments":true,"path":"api/articles/组合数学.json","keywords":null,"cover":"https://pic.imgdb.cn/item/62091b402ab3f51d91da1db3.jpg","text":"引述棋盘的完美覆盖考虑一张普通的棋盘，它被分成8行8列共64个方格，假设有一些形状 ","link":"","photos":[],"count_time":{"symbolsCount":42,"symbolsTime":"1 mins."},"categories":[{"name":"组合数学","slug":"组合数学","count":1,"path":"api/categories/组合数学.json"}],"tags":[{"name":"数学","slug":"数学","count":4,"path":"api/tags/数学.json"}],"author":{"name":"Snailuu","slug":"blog-author","avatar":"https://s3.bmp.ovh/imgs/2022/02/cf596ea7a7a4830f.jpg","link":"/","description":"本就无一物，何惧世道无常","socials":{"github":"https://github.com/snailuu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}